"use strict";
exports.id = 388;
exports.ids = [388];
exports.modules = {

/***/ 6388:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

// ESM COMPAT FLAG
__webpack_require__.r(__webpack_exports__);

// EXPORTS
__webpack_require__.d(__webpack_exports__, {
  "default": () => (/* binding */ src_App)
});

// EXTERNAL MODULE: external "react"
var external_react_ = __webpack_require__(9297);
var external_react_default = /*#__PURE__*/__webpack_require__.n(external_react_);
// EXTERNAL MODULE: external "react-router-dom"
var external_react_router_dom_ = __webpack_require__(2146);
// EXTERNAL MODULE: ../common/dist/lib/index.js
var lib = __webpack_require__(9819);
// EXTERNAL MODULE: external "canvas-confetti"
var external_canvas_confetti_ = __webpack_require__(8243);
var external_canvas_confetti_default = /*#__PURE__*/__webpack_require__.n(external_canvas_confetti_);
// EXTERNAL MODULE: external "react/jsx-runtime"
var jsx_runtime_ = __webpack_require__(5282);
;// CONCATENATED MODULE: ./src/components/Confetti/index.tsx





const ConfettiContext = /*#__PURE__*/external_react_default().createContext(null);
const ConfettiProvider = ({
  children = null
}) => {
  const canvasRef = (0,external_react_.useRef)();
  const confettiRef = (0,external_react_.useRef)();
  const dropConfetti = (0,external_react_.useMemo)(() => () => {
    if (confettiRef.current && canvasRef.current) {
      var _confettiRef$current;

      canvasRef.current.style.visibility = 'visible';
      (_confettiRef$current = confettiRef.current({
        particleCount: 400,
        spread: 160,
        origin: {
          y: 0.3
        }
      })) === null || _confettiRef$current === void 0 ? void 0 : _confettiRef$current.finally(() => {
        if (canvasRef.current) {
          canvasRef.current.style.visibility = 'hidden';
        }
      });
    }
  }, []);
  (0,external_react_.useEffect)(() => {
    if (canvasRef.current && !confettiRef.current) {
      canvasRef.current.style.visibility = 'hidden';
      confettiRef.current = external_canvas_confetti_default().create(canvasRef.current, {
        resize: true,
        useWorker: true
      });
    }
  }, []);
  const canvasStyle = {
    width: '100vw',
    height: '100vh',
    position: 'absolute',
    zIndex: 1,
    top: 0,
    left: 0
  };
  return /*#__PURE__*/(0,jsx_runtime_.jsxs)(ConfettiContext.Provider, {
    value: {
      dropConfetti
    },
    children: [/*#__PURE__*/jsx_runtime_.jsx("canvas", {
      ref: canvasRef,
      style: canvasStyle
    }), children]
  });
};
const Confetti = () => {
  const {
    dropConfetti
  } = useConfetti();
  (0,external_react_.useEffect)(() => {
    dropConfetti();
  }, [dropConfetti]);
  return /*#__PURE__*/jsx_runtime_.jsx(jsx_runtime_.Fragment, {});
};
const useConfetti = () => {
  const context = (0,external_react_.useContext)(ConfettiContext);
  return context;
};
// EXTERNAL MODULE: external "antd"
var external_antd_ = __webpack_require__(953);
// EXTERNAL MODULE: external "@solana/wallet-adapter-react"
var wallet_adapter_react_ = __webpack_require__(5772);
// EXTERNAL MODULE: external "@ant-design/icons"
var icons_ = __webpack_require__(2372);
// EXTERNAL MODULE: external "@solana/wallet-adapter-base"
var wallet_adapter_base_ = __webpack_require__(384);
// EXTERNAL MODULE: external "@solana/spl-token"
var spl_token_ = __webpack_require__(4541);
;// CONCATENATED MODULE: ./src/actions/closePersonalEscrow.ts


 // When you are an artist and you receive royalties, due to the design of the system
// it is to a permanent ATA WSOL account. This is because the auctioneer can't transfer monies
// from your WSOL to your SOL wallet since you own both, and having the auctioneer temporarily
// own your WSOL account to the transfer is one hell of a security vulnerability for a little convenience.
// Instead we make the WSOL permanent, and you have to accept it on the UI via your "unsettled funds"
// notification. All we do is then transfer the lamports out of the account.

async function closePersonalEscrow(connection, wallet, ata) {
  if (!wallet.publicKey) throw new wallet_adapter_base_.WalletNotConnectedError();
  const PROGRAM_IDS = lib.utils.programIds();
  const signers = [];
  const instructions = [spl_token_.Token.createCloseAccountInstruction(PROGRAM_IDS.token, (0,lib.toPublicKey)(ata), wallet.publicKey, wallet.publicKey, [])];
  await (0,lib.sendTransactionWithRetry)(connection, wallet, instructions, signers, 'single');
}
// EXTERNAL MODULE: ../common/dist/lib/models/metaplex/index.js
var metaplex = __webpack_require__(4373);
// EXTERNAL MODULE: ../common/dist/lib/models/metaplex/decommissionAuctionManager.js
var decommissionAuctionManager = __webpack_require__(9260);
// EXTERNAL MODULE: external "bn.js"
var external_bn_js_ = __webpack_require__(2416);
var external_bn_js_default = /*#__PURE__*/__webpack_require__.n(external_bn_js_);
// EXTERNAL MODULE: external "@solana/web3.js"
var web3_js_ = __webpack_require__(5681);
// EXTERNAL MODULE: ../common/dist/lib/actions/account.js
var account = __webpack_require__(8839);
// EXTERNAL MODULE: ../common/dist/lib/actions/vault.js
var actions_vault = __webpack_require__(5620);
// EXTERNAL MODULE: ../common/dist/lib/models/account.js
var models_account = __webpack_require__(1161);
;// CONCATENATED MODULE: ./src/actions/closeVault.ts







 // This command "closes" the vault, by activating & combining it in one go, handing it over to the auction manager
// authority (that may or may not exist yet.)

async function closeVault(connection, wallet, vault, fractionMint, fractionTreasury, redeemTreasury, priceMint, externalPriceAccount) {
  if (!wallet.publicKey) throw new wallet_adapter_base_.WalletNotConnectedError();
  const accountRentExempt = await connection.getMinimumBalanceForRentExemption(spl_token_.AccountLayout.span);
  const signers = [];
  const instructions = [];
  await (0,actions_vault.activateVault)(new (external_bn_js_default())(0), vault, fractionMint, fractionTreasury, wallet.publicKey.toBase58(), instructions);
  const outstandingShareAccount = (0,account.createTokenAccount)(instructions, wallet.publicKey, accountRentExempt, (0,lib.toPublicKey)(fractionMint), wallet.publicKey, signers);
  const payingTokenAccount = (0,account.createTokenAccount)(instructions, wallet.publicKey, accountRentExempt, (0,lib.toPublicKey)(priceMint), wallet.publicKey, signers);
  const transferAuthority = web3_js_.Keypair.generate(); // Shouldn't need to pay anything since we activated vault with 0 shares, but we still
  // need this setup anyway.

  (0,models_account.approve)(instructions, [], payingTokenAccount, wallet.publicKey, 0, false, undefined, transferAuthority);
  (0,models_account.approve)(instructions, [], outstandingShareAccount, wallet.publicKey, 0, false, undefined, transferAuthority);
  signers.push(transferAuthority);
  await (0,actions_vault.combineVault)(vault, outstandingShareAccount.toBase58(), payingTokenAccount.toBase58(), fractionMint, fractionTreasury, redeemTreasury, wallet.publicKey.toBase58(), wallet.publicKey.toBase58(), transferAuthority.publicKey.toBase58(), externalPriceAccount, instructions);
  return {
    instructions,
    signers
  };
}
;// CONCATENATED MODULE: ./src/actions/unwindVault.ts




const BATCH_SIZE = 1; // Given a vault you own, unwind all the tokens out of it.

async function unwindVault(connection, wallet, vault, safetyDepositBoxesByVaultAndIndex) {
  if (!wallet.publicKey) throw new wallet_adapter_base_.WalletNotConnectedError();
  let batchCounter = 0;
  const PROGRAM_IDS = (0,lib.programIds)();
  const signers = [];
  const instructions = [];
  let currSigners = [];
  let currInstructions = [];

  if (vault.info.state === lib.VaultState.Inactive) {
    console.log('Vault is inactive, combining');
    const epa = await connection.getAccountInfo((0,lib.toPublicKey)(vault.info.pricingLookupAddress));

    if (epa) {
      const decoded = (0,lib.decodeExternalPriceAccount)(epa.data); // "Closing" it here actually brings it to Combined state which means we can withdraw tokens.

      const {
        instructions: cvInstructions,
        signers: cvSigners
      } = await closeVault(connection, wallet, vault.pubkey, vault.info.fractionMint, vault.info.fractionTreasury, vault.info.redeemTreasury, decoded.priceMint, vault.info.pricingLookupAddress);
      signers.push(cvSigners);
      instructions.push(cvInstructions);
    }
  }

  const vaultKey = vault.pubkey;
  const boxes = [];
  let box = safetyDepositBoxesByVaultAndIndex[vaultKey + '-0'];

  if (box) {
    boxes.push(box);
    let i = 1;

    while (box) {
      box = safetyDepositBoxesByVaultAndIndex[vaultKey + '-' + i.toString()];
      if (box) boxes.push(box);
      i++;
    }
  }

  console.log('Found boxes', boxes);

  for (let i = 0; i < boxes.length; i++) {
    const nft = boxes[i];
    const ata = (await (0,lib.findProgramAddress)([wallet.publicKey.toBuffer(), PROGRAM_IDS.token.toBuffer(), (0,lib.toPublicKey)(nft.info.tokenMint).toBuffer()], PROGRAM_IDS.associatedToken))[0];
    const existingAta = await connection.getAccountInfo((0,lib.toPublicKey)(ata));
    console.log('Existing ata?', existingAta);
    if (!existingAta) (0,lib.createAssociatedTokenAccountInstruction)(currInstructions, (0,lib.toPublicKey)(ata), wallet.publicKey, wallet.publicKey, (0,lib.toPublicKey)(nft.info.tokenMint));
    const value = await connection.getTokenAccountBalance((0,lib.toPublicKey)(nft.info.store));
    await (0,lib.withdrawTokenFromSafetyDepositBox)(new (external_bn_js_default())(value.value.uiAmount || 1), ata, nft.pubkey, nft.info.store, vault.pubkey, vault.info.fractionMint, wallet.publicKey.toBase58(), currInstructions);

    if (batchCounter === BATCH_SIZE) {
      signers.push(currSigners);
      instructions.push(currInstructions);
      batchCounter = 0;
      currSigners = [];
      currInstructions = [];
    }

    batchCounter++;
  }

  if (instructions[instructions.length - 1] !== currInstructions) {
    signers.push(currSigners);
    instructions.push(currInstructions);
  }

  await (0,lib.sendTransactionsWithManualRetry)(connection, wallet, instructions, signers);
}
;// CONCATENATED MODULE: ./src/actions/decommAuctionManagerAndReturnPrizes.ts





async function decommAuctionManagerAndReturnPrizes(connection, wallet, auctionView, safetyDepositBoxesByVaultAndIndex) {
  if (!wallet.publicKey) throw new wallet_adapter_base_.WalletNotConnectedError();
  const signers = [];
  const instructions = [];

  if (auctionView.auctionManager.status === metaplex.AuctionManagerStatus.Initialized) {
    const decomSigners = [];
    const decomInstructions = [];

    if (auctionView.auction.info.authority === wallet.publicKey.toBase58()) {
      await (0,lib.setAuctionAuthority)(auctionView.auction.pubkey, wallet.publicKey.toBase58(), auctionView.auctionManager.pubkey, decomInstructions);
    }

    if (auctionView.vault.info.authority === wallet.publicKey.toBase58()) {
      await (0,lib.setVaultAuthority)(auctionView.vault.pubkey, wallet.publicKey.toBase58(), auctionView.auctionManager.pubkey, decomInstructions);
    }

    await (0,decommissionAuctionManager/* decommissionAuctionManager */.A)(auctionView.auctionManager.pubkey, auctionView.auction.pubkey, wallet.publicKey.toBase58(), auctionView.vault.pubkey, decomInstructions);
    signers.push(decomSigners);
    instructions.push(decomInstructions);
  }

  await (0,lib.sendTransactionsWithManualRetry)(connection, wallet, instructions, signers); // now that is rightfully decommed, we have authority back properly to the vault,
  // and the auction manager is in disbursing, so we can unwind the vault.

  await unwindVault(connection, wallet, auctionView.vault, safetyDepositBoxesByVaultAndIndex);
}
;// CONCATENATED MODULE: ./src/actions/sendSignMetadata.ts


async function sendSignMetadata(connection, wallet, metadata) {
  if (!wallet.publicKey) throw new wallet_adapter_base_.WalletNotConnectedError();
  const signers = [];
  const instructions = [];
  await (0,lib.signMetadata)(metadata, wallet.publicKey.toBase58(), instructions);
  await (0,lib.sendTransactionWithRetry)(connection, wallet, instructions, signers, 'single');
}
// EXTERNAL MODULE: ../common/dist/lib/models/metaplex/claimBid.js
var claimBid = __webpack_require__(4173);
// EXTERNAL MODULE: ../common/dist/lib/models/metaplex/emptyPaymentAccount.js
var emptyPaymentAccount = __webpack_require__(6672);
// EXTERNAL MODULE: ../common/dist/lib/models/metaplex/deprecatedPopulateParticipationPrintingAccount.js
var deprecatedPopulateParticipationPrintingAccount = __webpack_require__(1739);
;// CONCATENATED MODULE: ./src/actions/createMintAndAccountWithOne.ts



async function createMintAndAccountWithOne(wallet, receiverWallet, mintRent, instructions, signers) {
  if (!wallet.publicKey) throw new wallet_adapter_base_.WalletNotConnectedError();
  const mint = (0,lib.createMint)(instructions, wallet.publicKey, mintRent, 0, wallet.publicKey, wallet.publicKey, signers);
  const PROGRAM_IDS = (0,lib.programIds)();
  const account = (await (0,lib.findProgramAddress)([(0,lib.toPublicKey)(receiverWallet).toBuffer(), PROGRAM_IDS.token.toBuffer(), mint.toBuffer()], PROGRAM_IDS.associatedToken))[0];
  (0,lib.createAssociatedTokenAccountInstruction)(instructions, (0,lib.toPublicKey)(account), wallet.publicKey, (0,lib.toPublicKey)(receiverWallet), mint);
  instructions.push(spl_token_.Token.createMintToInstruction(PROGRAM_IDS.token, mint, (0,lib.toPublicKey)(account), wallet.publicKey, [], 1));
  return {
    mint: mint.toBase58(),
    account
  };
}
;// CONCATENATED MODULE: ./src/constants/labels.ts
const LABELS = {
  STORE_NAME: 'Metaplex',
  CONNECT_LABEL: 'Connect Wallet',
  GIVE_SOL: 'Give me SOL',
  FAUCET_INFO: 'This faucet will help you fund your accounts outside of Solana main network.',
  ACCOUNT_FUNDED: 'Account funded.',
  MENU_HOME: 'Home',
  MENU_FAUCET: 'Faucet',
  CONNECT_BUTTON: 'Connect',
  WALLET_TOOLTIP: 'Wallet public key',
  WALLET_BALANCE: 'Wallet balance',
  SETTINGS_TOOLTIP: 'Settings',
  GO_BACK_ACTION: 'Go back',
  TOTAL_TITLE: 'Total',
  ENTER_AMOUNT: 'Enter an amount',
  TRANSFER: 'Transfer',
  SET_CORRECT_WALLET_NETWORK: 'Set correct wallet network'
};
;// CONCATENATED MODULE: ./src/constants/style.tsx
const GUTTER = [16, {
  xs: 8,
  sm: 16,
  md: 16,
  lg: 16
}];
const SMALL_STATISTIC = {
  fontSize: 10
};
;// CONCATENATED MODULE: ./src/constants/index.tsx



const QUOTE_MINT = lib.WRAPPED_SOL_MINT;
const MINIMUM_SAFE_FEE_AUCTION_CREATION = 0.06; //sol

const MAX_PACKS_CREATION_COUNT = 100;
;// CONCATENATED MODULE: ./src/actions/sendRedeemBid.ts














function eligibleForParticipationPrizeGivenWinningIndex(winnerIndex, auctionView, bidderMetadata, bidRedemption) {
  var _auctionView$auctionM, _auctionView$auctionM2, _auctionView$auctionM3;

  const index = (_auctionView$auctionM = auctionView.auctionManager.participationConfig) === null || _auctionView$auctionM === void 0 ? void 0 : _auctionView$auctionM.safetyDepositBoxIndex;

  if (index == undefined || index == null) {
    return false;
  }

  if (!bidderMetadata || bidRedemption !== null && bidRedemption !== void 0 && bidRedemption.info.getBidRedeemed(index)) return false;
  return winnerIndex === null && ((_auctionView$auctionM2 = auctionView.auctionManager.participationConfig) === null || _auctionView$auctionM2 === void 0 ? void 0 : _auctionView$auctionM2.nonWinningConstraint) !== metaplex.NonWinningConstraint.NoParticipationPrize || winnerIndex !== null && ((_auctionView$auctionM3 = auctionView.auctionManager.participationConfig) === null || _auctionView$auctionM3 === void 0 ? void 0 : _auctionView$auctionM3.winnerConstraint) !== metaplex.WinningConstraint.NoParticipationPrize;
}
async function sendRedeemBid(connection, wallet, payingAccount, auctionView, accountsByMint, prizeTrackingTickets, bidRedemptions, bids) {
  var _auctionView$myBidder, _auctionView$myBidder2;

  if (!wallet.publicKey) throw new wallet_adapter_base_.WalletNotConnectedError();
  const signers = [];
  const instructions = [];

  if (auctionView.auction.info.ended() && auctionView.auction.info.state !== lib.AuctionState.Ended) {
    await setupPlaceBid(connection, wallet, payingAccount, auctionView, accountsByMint, 0, instructions, signers);
  }

  const accountRentExempt = await connection.getMinimumBalanceForRentExemption(spl_token_.AccountLayout.span);
  const mintRentExempt = await connection.getMinimumBalanceForRentExemption(spl_token_.MintLayout.span);
  let winnerIndex = null;
  if ((_auctionView$myBidder = auctionView.myBidderPot) !== null && _auctionView$myBidder !== void 0 && _auctionView$myBidder.pubkey) winnerIndex = auctionView.auction.info.bidState.getWinnerIndex((_auctionView$myBidder2 = auctionView.myBidderPot) === null || _auctionView$myBidder2 === void 0 ? void 0 : _auctionView$myBidder2.info.bidderAct);

  if (winnerIndex !== null) {
    // items is a prebuilt array of arrays where each entry represents one
    // winning spot, and each entry in it represents one type of item that can
    // be received.
    const winningSet = auctionView.items[winnerIndex];

    for (let i = 0; i < winningSet.length; i++) {
      const item = winningSet[i];
      const safetyDeposit = item.safetyDeposit;

      switch (item.winningConfigType) {
        case metaplex.WinningConfigType.PrintingV1:
          console.log('Redeeming printing v1');
          await deprecatedSetupRedeemPrintingV1Instructions(auctionView, accountsByMint, accountRentExempt, mintRentExempt, wallet, safetyDeposit, item, winnerIndex, signers, instructions);
          break;

        case metaplex.WinningConfigType.PrintingV2:
          console.log('Redeeming printing v2');
          await setupRedeemPrintingV2Instructions(connection, auctionView, mintRentExempt, wallet, wallet.publicKey.toBase58(), safetyDeposit, item, signers, instructions, winnerIndex, prizeTrackingTickets);
          break;

        case metaplex.WinningConfigType.FullRightsTransfer:
          console.log('Redeeming Full Rights');
          await setupRedeemFullRightsTransferInstructions(auctionView, accountsByMint, accountRentExempt, wallet, safetyDeposit, item, winnerIndex, signers, instructions);
          break;

        case metaplex.WinningConfigType.TokenOnlyTransfer:
          console.log('Redeeming Token only');
          await setupRedeemInstructions(auctionView, accountsByMint, accountRentExempt, wallet, safetyDeposit, winnerIndex, signers, instructions);
          break;
      }
    }

    if (auctionView.myBidderMetadata && auctionView.myBidderPot) {
      var _auctionView$myBidder3;

      const claimSigners = [];
      const claimInstructions = [];
      instructions.push(claimInstructions);
      signers.push(claimSigners);
      console.log('Claimed');
      await (0,claimBid/* claimBid */.G)(auctionView.auctionManager.acceptPayment, auctionView.myBidderMetadata.info.bidderPubkey, (_auctionView$myBidder3 = auctionView.myBidderPot) === null || _auctionView$myBidder3 === void 0 ? void 0 : _auctionView$myBidder3.info.bidderPot, auctionView.vault.pubkey, auctionView.auction.info.tokenMint, claimInstructions);
    }
  } else {
    // If you didnt win, you must have a bid we can refund before we check for open editions.
    await setupCancelBid(auctionView, accountsByMint, accountRentExempt, wallet, signers, instructions, connection);
  }

  if (auctionView.participationItem && eligibleForParticipationPrizeGivenWinningIndex(winnerIndex, auctionView, auctionView.myBidderMetadata, auctionView.myBidRedemption)) {
    var _item$masterEdition;

    console.log('eligible for participation');
    const item = auctionView.participationItem;
    const safetyDeposit = item.safetyDeposit;

    if (((_item$masterEdition = item.masterEdition) === null || _item$masterEdition === void 0 ? void 0 : _item$masterEdition.info.key) == lib.MetadataKey.MasterEditionV1) {
      await deprecatedSetupRedeemParticipationInstructions(connection, auctionView, accountsByMint, accountRentExempt, mintRentExempt, wallet, safetyDeposit, item, signers, instructions);
    } else {
      await setupRedeemParticipationInstructions(connection, auctionView, accountsByMint, accountRentExempt, mintRentExempt, wallet, wallet.publicKey.toBase58(), safetyDeposit, auctionView.myBidRedemption, auctionView.myBidderMetadata, item, signers, instructions);
    }
  }

  if (wallet.publicKey.toBase58() === auctionView.auctionManager.authority) {
    await claimUnusedPrizes(connection, wallet, auctionView, accountsByMint, bids, bidRedemptions, prizeTrackingTickets, signers, instructions);
  }

  await (0,lib.sendTransactionsWithManualRetry)(connection, wallet, instructions, signers);
}

async function setupRedeemInstructions(auctionView, accountsByMint, accountRentExempt, wallet, safetyDeposit, winnerIndex, signers, instructions) {
  if (!wallet.publicKey) throw new wallet_adapter_base_.WalletNotConnectedError();
  const winningPrizeSigner = [];
  const winningPrizeInstructions = [];
  signers.push(winningPrizeSigner);
  instructions.push(winningPrizeInstructions);
  const claimed = auctionView.auctionManager.isItemClaimed(winnerIndex, safetyDeposit.info.order);

  if (!claimed && auctionView.myBidderMetadata) {
    var _accountsByMint$get;

    let newTokenAccount = (_accountsByMint$get = accountsByMint.get(safetyDeposit.info.tokenMint)) === null || _accountsByMint$get === void 0 ? void 0 : _accountsByMint$get.pubkey;
    if (!newTokenAccount) newTokenAccount = (0,account.createTokenAccount)(winningPrizeInstructions, wallet.publicKey, accountRentExempt, (0,lib.toPublicKey)(safetyDeposit.info.tokenMint), wallet.publicKey, winningPrizeSigner).toBase58();
    await (0,metaplex.redeemBid)(auctionView.auctionManager.vault, safetyDeposit.info.store, newTokenAccount, safetyDeposit.pubkey, auctionView.vault.info.fractionMint, auctionView.myBidderMetadata.info.bidderPubkey, wallet.publicKey.toBase58(), undefined, undefined, false, winningPrizeInstructions);
    const metadata = await (0,lib.getMetadata)(safetyDeposit.info.tokenMint);
    await (0,lib.updatePrimarySaleHappenedViaToken)(metadata, wallet.publicKey.toBase58(), newTokenAccount, winningPrizeInstructions);
  }
}

async function setupRedeemFullRightsTransferInstructions(auctionView, accountsByMint, accountRentExempt, wallet, safetyDeposit, item, winnerIndex, signers, instructions) {
  if (!wallet.publicKey) throw new wallet_adapter_base_.WalletNotConnectedError();
  const winningPrizeSigner = [];
  const winningPrizeInstructions = [];
  signers.push(winningPrizeSigner);
  instructions.push(winningPrizeInstructions);
  const claimed = auctionView.auctionManager.isItemClaimed(winnerIndex, safetyDeposit.info.order);

  if (!claimed && auctionView.myBidderMetadata) {
    var _accountsByMint$get2;

    let newTokenAccount = (_accountsByMint$get2 = accountsByMint.get(safetyDeposit.info.tokenMint)) === null || _accountsByMint$get2 === void 0 ? void 0 : _accountsByMint$get2.pubkey;
    if (!newTokenAccount) newTokenAccount = (0,account.createTokenAccount)(winningPrizeInstructions, wallet.publicKey, accountRentExempt, (0,lib.toPublicKey)(safetyDeposit.info.tokenMint), wallet.publicKey, winningPrizeSigner).toBase58();
    await (0,metaplex.redeemFullRightsTransferBid)(auctionView.auctionManager.vault, safetyDeposit.info.store, newTokenAccount, safetyDeposit.pubkey, auctionView.vault.info.fractionMint, auctionView.myBidderMetadata.info.bidderPubkey, wallet.publicKey.toBase58(), winningPrizeInstructions, item.metadata.pubkey, wallet.publicKey.toBase58());
    const metadata = await (0,lib.getMetadata)(safetyDeposit.info.tokenMint);
    await (0,lib.updatePrimarySaleHappenedViaToken)(metadata, wallet.publicKey.toBase58(), newTokenAccount, winningPrizeInstructions);
  }
}

async function setupRedeemPrintingV2Instructions(connection, auctionView, mintRentExempt, wallet, receiverWallet, safetyDeposit, item, signers, instructions, winningIndex, prizeTrackingTickets) {
  if (!wallet.publicKey) throw new wallet_adapter_base_.WalletNotConnectedError();

  if (!item.masterEdition || !item.metadata) {
    return;
  }

  const me = item.masterEdition;
  const myPrizeTrackingTicketKey = await (0,metaplex.getPrizeTrackingTicket)(auctionView.auctionManager.pubkey, item.metadata.info.mint);
  const myPrizeTrackingTicket = prizeTrackingTickets[myPrizeTrackingTicketKey]; // We are not entirely guaranteed this is right. Someone could be clicking at the same time. Contract will throw error if this
  // is the case and they'll need to refresh to get tracking ticket which may not have existed when they first clicked.

  const editionBase = myPrizeTrackingTicket ? myPrizeTrackingTicket.info.supplySnapshot : me.info.supply;
  let offset = new external_bn_js_.BN(1);
  auctionView.items.forEach((wc, index) => index < winningIndex && wc.forEach(i => {
    if (i.safetyDeposit.info.order === item.safetyDeposit.info.order && i.winningConfigType === item.winningConfigType) {
      offset = offset.add(i.amount);
    }
  }));

  for (let i = 0; i < item.amount.toNumber(); i++) {
    const myInstructions = [];
    const mySigners = [];
    const {
      mint,
      account
    } = await createMintAndAccountWithOne(wallet, receiverWallet, mintRentExempt, myInstructions, mySigners);
    const winIndex = auctionView.auction.info.bidState.getWinnerIndex(receiverWallet) || 0;
    const desiredEdition = editionBase.add(offset.add(new external_bn_js_.BN(i)));
    const editionMarkPda = await (0,lib.getEditionMarkPda)(item.metadata.info.mint, desiredEdition);

    try {
      const editionData = await connection.getAccountInfo((0,lib.toPublicKey)(editionMarkPda));

      if (editionData) {
        const marker = (0,lib.decodeEditionMarker)(editionData.data);

        if (marker.editionTaken(desiredEdition.toNumber())) {
          console.log('Edition', desiredEdition, 'taken, continuing');
          continue;
        }
      }
    } catch (e) {
      console.error(e);
    }

    await (0,metaplex.redeemPrintingV2Bid)(auctionView.vault.pubkey, safetyDeposit.info.store, account, safetyDeposit.pubkey, receiverWallet, wallet.publicKey.toBase58(), item.metadata.pubkey, me.pubkey, item.metadata.info.mint, mint, desiredEdition, new external_bn_js_.BN(offset.add(new external_bn_js_.BN(i))), new external_bn_js_.BN(winIndex), myInstructions);
    const metadata = await (0,lib.getMetadata)(mint);

    if (wallet.publicKey.toBase58() === receiverWallet) {
      await (0,lib.updatePrimarySaleHappenedViaToken)(metadata, wallet.publicKey.toBase58(), account, myInstructions);
    }

    instructions.push(myInstructions);
    signers.push(mySigners);
  }
}

async function deprecatedSetupRedeemPrintingV1Instructions(auctionView, accountsByMint, accountRentExempt, mintRentExempt, wallet, safetyDeposit, item, winnerIndex, signers, instructions) {
  if (!wallet.publicKey) throw new wallet_adapter_base_.WalletNotConnectedError();

  if (!item.masterEdition || !item.metadata) {
    return;
  }

  const updateAuth = item.metadata.info.updateAuthority;
  const reservationList = await (0,lib.deprecatedGetReservationList)(item.masterEdition.pubkey, auctionView.auctionManager.pubkey);
  const me = item.masterEdition;
  const newTokenAccount = accountsByMint.get(me.info.printingMint);
  let newTokenAccountKey = newTokenAccount === null || newTokenAccount === void 0 ? void 0 : newTokenAccount.pubkey;
  let newTokenAccountBalance = newTokenAccount ? newTokenAccount.info.amount.toNumber() : 0;
  const claimed = auctionView.auctionManager.isItemClaimed(winnerIndex, safetyDeposit.info.order);

  if (updateAuth && auctionView.myBidderMetadata) {
    console.log('This state item is', claimed);

    if (!claimed) {
      const winningPrizeSigner = [];
      const winningPrizeInstructions = [];
      signers.push(winningPrizeSigner);
      instructions.push(winningPrizeInstructions);
      if (!newTokenAccountKey) // TODO: switch to ATA
        newTokenAccountKey = (0,account.createTokenAccount)(winningPrizeInstructions, wallet.publicKey, accountRentExempt, (0,lib.toPublicKey)(me.info.printingMint), wallet.publicKey, winningPrizeSigner).toBase58();
      await (0,metaplex.redeemBid)(auctionView.auctionManager.vault, safetyDeposit.info.store, newTokenAccountKey, safetyDeposit.pubkey, auctionView.vault.info.fractionMint, auctionView.myBidderMetadata.info.bidderPubkey, wallet.publicKey.toBase58(), item.masterEdition.pubkey, reservationList, true, winningPrizeInstructions);
      newTokenAccountBalance = auctionView.auctionManager.getAmountForWinner(winnerIndex, safetyDeposit.info.order).toNumber();
    }

    if (newTokenAccountKey && newTokenAccountBalance > 0) for (let i = 0; i < newTokenAccountBalance; i++) {
      console.log('Redeeming v1 token', i);
      await deprecatedRedeemPrintingV1Token(wallet, updateAuth, item, newTokenAccountKey, mintRentExempt, accountRentExempt, signers, instructions, reservationList);
    }
  }
}

async function deprecatedRedeemPrintingV1Token(wallet, updateAuth, item, newTokenAccount, mintRentExempt, accountRentExempt, signers, instructions, reservationList) {
  if (!wallet.publicKey) throw new wallet_adapter_base_.WalletNotConnectedError();
  if (!item.masterEdition) return;
  const cashInLimitedPrizeAuthorizationTokenSigner = [];
  const cashInLimitedPrizeAuthorizationTokenInstruction = [];
  signers.push(cashInLimitedPrizeAuthorizationTokenSigner);
  instructions.push(cashInLimitedPrizeAuthorizationTokenInstruction);
  const newLimitedEditionMint = (0,lib.createMint)(cashInLimitedPrizeAuthorizationTokenInstruction, wallet.publicKey, mintRentExempt, 0, wallet.publicKey, wallet.publicKey, cashInLimitedPrizeAuthorizationTokenSigner).toBase58();
  const newLimitedEdition = (0,account.createTokenAccount)(cashInLimitedPrizeAuthorizationTokenInstruction, wallet.publicKey, accountRentExempt, (0,lib.toPublicKey)(newLimitedEditionMint), wallet.publicKey, cashInLimitedPrizeAuthorizationTokenSigner);
  cashInLimitedPrizeAuthorizationTokenInstruction.push(spl_token_.Token.createMintToInstruction((0,lib.programIds)().token, (0,lib.toPublicKey)(newLimitedEditionMint), newLimitedEdition, wallet.publicKey, [], 1));
  const burnAuthority = (0,models_account.approve)(cashInLimitedPrizeAuthorizationTokenInstruction, [], (0,lib.toPublicKey)(newTokenAccount), wallet.publicKey, 1);
  cashInLimitedPrizeAuthorizationTokenSigner.push(burnAuthority);
  const me = item.masterEdition;
  await (0,lib.deprecatedMintNewEditionFromMasterEditionViaPrintingToken)(newLimitedEditionMint, item.metadata.info.mint, wallet.publicKey.toBase58(), me.info.printingMint, newTokenAccount, burnAuthority.publicKey.toBase58(), updateAuth, reservationList, cashInLimitedPrizeAuthorizationTokenInstruction, wallet.publicKey.toBase58());
  const metadata = await (0,lib.getMetadata)(newLimitedEditionMint);
  await (0,lib.updatePrimarySaleHappenedViaToken)(metadata, wallet.publicKey.toBase58(), newLimitedEdition.toBase58(), cashInLimitedPrizeAuthorizationTokenInstruction);
}

async function setupRedeemParticipationInstructions(connection, auctionView, accountsByMint, accountRentExempt, mintRentExempt, wallet, receiverWallet, safetyDeposit, bidRedemption, bid, item, signers, instructions) {
  var _bidRedemption$info;

  if (!wallet.publicKey) throw new wallet_adapter_base_.WalletNotConnectedError();

  if (!item.masterEdition || !item.metadata) {
    return;
  } // Forgive me, for i have sinned. I had to split up the commands
  // here into multiple txns because participation redemption is huge.


  if (!(bidRedemption !== null && bidRedemption !== void 0 && (_bidRedemption$info = bidRedemption.info) !== null && _bidRedemption$info !== void 0 && _bidRedemption$info.getBidRedeemed(safetyDeposit.info.order))) {
    var _auctionView$auctionM4;

    const me = item.masterEdition; // Super unfortunate but cant fit this all in one txn

    const mintingInstructions = [];
    const mintingSigners = [];
    const cleanupInstructions = [];
    const {
      mint,
      account
    } = await createMintAndAccountWithOne(wallet, receiverWallet, mintRentExempt, mintingInstructions, mintingSigners);
    const fixedPrice = (_auctionView$auctionM4 = auctionView.auctionManager.participationConfig) === null || _auctionView$auctionM4 === void 0 ? void 0 : _auctionView$auctionM4.fixedPrice;
    const price = fixedPrice !== undefined && fixedPrice !== null ? fixedPrice.toNumber() : (bid === null || bid === void 0 ? void 0 : bid.info.lastBid.toNumber()) || 0;
    let tokenAccount = accountsByMint.get(auctionView.auction.info.tokenMint);
    console.log('Have token account', tokenAccount);

    if (!tokenAccount) {
      // In case accountsByMint missed it(which it does sometimes)
      const allAccounts = await connection.getTokenAccountsByOwner(wallet.publicKey, {
        mint: QUOTE_MINT
      });

      if (allAccounts.value.length > 0) {
        tokenAccount = (0,lib.TokenAccountParser)(allAccounts.value[0].pubkey.toBase58(), allAccounts.value[0].account);
      }

      console.log('Found token account', tokenAccount);
    }

    let receivingSolAccountOrAta = '';

    if (auctionView.auction.info.tokenMint == lib.WRAPPED_SOL_MINT.toBase58()) {
      receivingSolAccountOrAta = (0,lib.ensureWrappedAccount)(mintingInstructions, cleanupInstructions, tokenAccount, wallet.publicKey, price + accountRentExempt, mintingSigners);
    } else {
      receivingSolAccountOrAta = await findAta(auctionView, wallet, connection);
    }

    instructions.push(mintingInstructions);
    signers.push(mintingSigners);
    const myInstructions = [];
    const mySigners = [];
    const transferAuthority = (0,models_account.approve)(myInstructions, cleanupInstructions, (0,lib.toPublicKey)(receivingSolAccountOrAta), wallet.publicKey, price);
    mySigners.push(transferAuthority);
    const winnerIndex = auctionView.auction.info.bidState.getWinnerIndex(wallet.publicKey.toBase58());
    await (0,metaplex.redeemParticipationBidV3)(auctionView.vault.pubkey, safetyDeposit.info.store, account, safetyDeposit.pubkey, receiverWallet, wallet.publicKey.toBase58(), item.metadata.pubkey, me.pubkey, item.metadata.info.mint, transferAuthority.publicKey.toBase58(), auctionView.auctionManager.acceptPayment, (0,lib.pubkeyToString)(receivingSolAccountOrAta), mint, me.info.supply.add(new external_bn_js_.BN(1)), winnerIndex != null && winnerIndex != undefined ? new external_bn_js_.BN(winnerIndex) : null, myInstructions);
    instructions.push([...myInstructions, ...cleanupInstructions.reverse()]);
    signers.push(mySigners);
    const metadata = await (0,lib.getMetadata)(mint);

    if (receiverWallet === wallet.publicKey.toBase58()) {
      const updatePrimarySaleHappenedInstructions = [];
      const updatePrimarySaleHappenedSigners = [];
      await (0,lib.updatePrimarySaleHappenedViaToken)(metadata, wallet.publicKey.toBase58(), account, updatePrimarySaleHappenedInstructions);
      instructions.push(updatePrimarySaleHappenedInstructions);
      signers.push(updatePrimarySaleHappenedSigners);
    }
  } else {
    console.log('Item is already claimed!', item.metadata.info.mint);
  }
}

async function deprecatedSetupRedeemParticipationInstructions(connection, auctionView, accountsByMint, accountRentExempt, mintRentExempt, wallet, safetyDeposit, item, signers, instructions) {
  var _state, _accountsByMint$get3, _accountsByMint$get4, _auctionView$myBidRed;

  if (!wallet.publicKey) throw new wallet_adapter_base_.WalletNotConnectedError();
  const me = item.masterEdition;
  const participationState = (_state = auctionView.auctionManager.instance.info.state) === null || _state === void 0 ? void 0 : _state.participationState;
  if (!participationState || !(participationState !== null && participationState !== void 0 && participationState.printingAuthorizationTokenAccount) || !(me !== null && me !== void 0 && me.info.oneTimePrintingAuthorizationMint) || !item.metadata) return;
  const updateAuth = item.metadata.info.updateAuthority;
  const tokenAccount = accountsByMint.get(auctionView.auction.info.tokenMint);
  const mint = lib.cache.get(auctionView.auction.info.tokenMint);
  const participationBalance = await connection.getTokenAccountBalance((0,lib.toPublicKey)(participationState.printingAuthorizationTokenAccount));
  const tokenBalance = await connection.getTokenAccountBalance((0,lib.toPublicKey)(safetyDeposit.info.store));

  if (participationBalance.value.uiAmount === 0 && tokenBalance.value.uiAmount === 1) {
    // I'm the first, I need to populate for the others with a crank turn.
    const fillParticipationStashSigners = [];
    const fillParticipationStashInstructions = [];
    const oneTimeTransient = (0,account.createTokenAccount)(fillParticipationStashInstructions, wallet.publicKey, accountRentExempt, (0,lib.toPublicKey)(me === null || me === void 0 ? void 0 : me.info.oneTimePrintingAuthorizationMint), (0,lib.toPublicKey)(auctionView.auctionManager.pubkey), fillParticipationStashSigners).toBase58();
    await (0,deprecatedPopulateParticipationPrintingAccount/* deprecatedPopulateParticipationPrintingAccount */.z)(auctionView.vault.pubkey, auctionView.auctionManager.pubkey, auctionView.auction.pubkey, safetyDeposit.info.store, oneTimeTransient, participationState.printingAuthorizationTokenAccount, safetyDeposit.pubkey, auctionView.vault.info.fractionMint, me.info.printingMint, me.info.oneTimePrintingAuthorizationMint, me.pubkey, item.metadata.pubkey, wallet.publicKey.toBase58(), fillParticipationStashInstructions);
    signers.push(fillParticipationStashSigners);
    instructions.push(fillParticipationStashInstructions);
  }

  let newTokenAccount = (_accountsByMint$get3 = accountsByMint.get(me.info.printingMint)) === null || _accountsByMint$get3 === void 0 ? void 0 : _accountsByMint$get3.pubkey;
  let newTokenBalance = ((_accountsByMint$get4 = accountsByMint.get(me.info.printingMint)) === null || _accountsByMint$get4 === void 0 ? void 0 : _accountsByMint$get4.info.amount) || 0;

  if (me && updateAuth && auctionView.myBidderMetadata && mint && !((_auctionView$myBidRed = auctionView.myBidRedemption) !== null && _auctionView$myBidRed !== void 0 && _auctionView$myBidRed.info.getBidRedeemed(safetyDeposit.info.order))) {
    var _auctionView$myBidRed2;

    if (!((_auctionView$myBidRed2 = auctionView.myBidRedemption) !== null && _auctionView$myBidRed2 !== void 0 && _auctionView$myBidRed2.info.getBidRedeemed(safetyDeposit.info.order))) {
      var _auctionView$auctionM5;

      const winningPrizeSigner = [];
      const winningPrizeInstructions = [];
      const cleanupInstructions = [];

      if (!newTokenAccount) {
        // made a separate txn because we're over the txn limit by like 10 bytes.
        const newTokenAccountSigner = [];
        const newTokenAccountInstructions = [];
        signers.push(newTokenAccountSigner);
        instructions.push(newTokenAccountInstructions);
        newTokenAccount = (0,account.createTokenAccount)(newTokenAccountInstructions, wallet.publicKey, accountRentExempt, (0,lib.toPublicKey)(me.info.printingMint), wallet.publicKey, newTokenAccountSigner).toBase58();
      }

      signers.push(winningPrizeSigner);
      const fixedPrice = (_auctionView$auctionM5 = auctionView.auctionManager.participationConfig) === null || _auctionView$auctionM5 === void 0 ? void 0 : _auctionView$auctionM5.fixedPrice;
      const price = fixedPrice !== undefined && fixedPrice !== null ? fixedPrice.toNumber() : auctionView.myBidderMetadata.info.lastBid.toNumber() || 0;
      let receivingSolAccountOrAta = '';

      if (auctionView.auction.info.tokenMint == lib.WRAPPED_SOL_MINT.toBase58()) {
        receivingSolAccountOrAta = (0,lib.ensureWrappedAccount)(winningPrizeInstructions, cleanupInstructions, tokenAccount, wallet.publicKey, price + accountRentExempt, winningPrizeSigner);
      } else {
        receivingSolAccountOrAta = await findAta(auctionView, wallet, connection);
      }

      const transferAuthority = (0,models_account.approve)(winningPrizeInstructions, cleanupInstructions, (0,lib.toPublicKey)(receivingSolAccountOrAta), wallet.publicKey, price);
      winningPrizeSigner.push(transferAuthority);
      await (0,metaplex.deprecatedRedeemParticipationBid)(auctionView.auctionManager.vault, safetyDeposit.info.store, newTokenAccount, safetyDeposit.pubkey, auctionView.myBidderMetadata.info.bidderPubkey, wallet.publicKey.toBase58(), winningPrizeInstructions, participationState.printingAuthorizationTokenAccount, transferAuthority.publicKey.toBase58(), auctionView.auctionManager.acceptPayment, receivingSolAccountOrAta);
      newTokenBalance = 1;
      instructions.push([...winningPrizeInstructions, ...cleanupInstructions.reverse()]);
    }
  }

  if (newTokenAccount && newTokenBalance === 1) {
    await deprecatedRedeemPrintingV1Token(wallet, updateAuth, item, newTokenAccount, mintRentExempt, accountRentExempt, signers, instructions, undefined);
  }
}
;// CONCATENATED MODULE: ./src/actions/claimUnusedPrizes.ts






async function findEligibleParticipationBidsForRedemption(auctionView, bids, bidRedemptions) {
  const unredeemedParticipations = [];

  for (let i = 0; i < bids.length; i++) {
    const bid = bids[i];

    if (!bid.info.cancelled) {
      const winnerIndex = auctionView.auction.info.bidState.getWinnerIndex(bid.info.bidderPubkey);
      const bidRedemption = bidRedemptions[await (0,metaplex.getBidRedemption)(auctionView.auction.pubkey, bid.pubkey)];
      const eligible = eligibleForParticipationPrizeGivenWinningIndex(winnerIndex, auctionView, bid, bidRedemption);
      console.log(bid.pubkey, 'eligible?', eligible);

      if (eligible) {
        unredeemedParticipations.push({
          bid,
          bidRedemption
        });
      }
    }
  }

  return unredeemedParticipations;
}
async function claimUnusedPrizes(connection, wallet, auctionView, accountsByMint, bids, bidRedemptions, prizeTrackingTickets, signers, instructions) {
  var _auctionView$particip;

  const accountRentExempt = await connection.getMinimumBalanceForRentExemption(spl_token_.AccountLayout.span);
  const mintRentExempt = await connection.getMinimumBalanceForRentExemption(spl_token_.MintLayout.span);

  if (auctionView.participationItem && auctionView.participationItem.safetyDeposit && ((_auctionView$particip = auctionView.participationItem.masterEdition) === null || _auctionView$particip === void 0 ? void 0 : _auctionView$particip.info.key) == lib.MetadataKey.MasterEditionV2) {
    const balance = await connection.getTokenAccountBalance((0,lib.toPublicKey)(auctionView.participationItem.safetyDeposit.info.store));

    if (balance.value.uiAmount || 0 > 0) {
      // before we can redeem, check if we need to print other people's stuff.
      const unredeemedParticipations = await findEligibleParticipationBidsForRedemption(auctionView, bids, bidRedemptions);
      await Promise.all(unredeemedParticipations.map(p => auctionView.participationItem && setupRedeemParticipationInstructions(connection, auctionView, accountsByMint, accountRentExempt, mintRentExempt, wallet, p.bid.info.bidderPubkey, auctionView.participationItem.safetyDeposit, p.bidRedemption, p.bid, auctionView.participationItem, signers, instructions)));
      await setupWithdrawMasterEditionInstructions(connection, auctionView, wallet, auctionView.participationItem.safetyDeposit, auctionView.participationItem, signers, instructions);
    }
  }

  const printingV2ByMint = {};

  for (let winnerIndex = 0; winnerIndex < auctionView.auctionManager.numWinners.toNumber(); winnerIndex++) {
    const winningSet = auctionView.items[winnerIndex];

    for (let i = 0; i < winningSet.length; i++) {
      const item = winningSet[i];
      const safetyDeposit = item.safetyDeposit;
      const tokenBalance = await connection.getTokenAccountBalance((0,lib.toPublicKey)(safetyDeposit.info.store)); // If box is empty, we cant redeem this. Could be broken AM we are claiming against.

      if (tokenBalance.value.uiAmount === 0) {
        console.log('Skipping', i, ' due to empty balance');
        continue;
      }

      if (winnerIndex < auctionView.auction.info.bidState.bids.length && item.winningConfigType != metaplex.WinningConfigType.PrintingV2) {
        continue;
      }

      switch (item.winningConfigType) {
        case metaplex.WinningConfigType.PrintingV1:
          console.log('Redeeming printing v1 same way we redeem a normal bid because we arent printing it');
          await deprecatedSetupRedeemPrintingInstructions(auctionView, accountsByMint, accountRentExempt, wallet, safetyDeposit, item, signers, instructions, winnerIndex);
          break;

        case metaplex.WinningConfigType.PrintingV2:
          {
            const winningBidder = auctionView.auction.info.bidState.getWinnerAt(winnerIndex);

            if (winningBidder) {
              const bidderMetadata = bids.find(b => b.info.bidderPubkey === winningBidder);

              if (bidderMetadata) {
                console.log('Redeeming v2 for bid by wallet', winningBidder);
                await setupRedeemPrintingV2Instructions(connection, auctionView, mintRentExempt, wallet, winningBidder, item.safetyDeposit, item, signers, instructions, winnerIndex, prizeTrackingTickets);
              }
            }

            printingV2ByMint[item.metadata.info.mint] = item;
            break;
          }

        case metaplex.WinningConfigType.FullRightsTransfer:
          console.log('Redeeming Full Rights');
          await claimUnusedPrizes_setupRedeemFullRightsTransferInstructions(auctionView, accountsByMint, accountRentExempt, wallet, safetyDeposit, item, signers, instructions, winnerIndex);
          break;

        case metaplex.WinningConfigType.TokenOnlyTransfer:
          console.log('Redeeming Token only');
          await claimUnusedPrizes_setupRedeemInstructions(auctionView, accountsByMint, accountRentExempt, wallet, safetyDeposit, signers, instructions, winnerIndex);
          break;
      }
    }
  }

  const allV2s = Object.values(printingV2ByMint);

  for (let i = 0; i < allV2s.length; i++) {
    const item = allV2s[i];
    await setupWithdrawMasterEditionInstructions(connection, auctionView, wallet, item.safetyDeposit, item, signers, instructions);
  }
}

async function claimUnusedPrizes_setupRedeemInstructions(auctionView, accountsByMint, accountRentExempt, wallet, safetyDeposit, signers, instructions, winningConfigIndex) {
  if (!wallet.publicKey) throw new wallet_adapter_base_.WalletNotConnectedError();
  const winningPrizeSigner = [];
  const winningPrizeInstructions = [];
  signers.push(winningPrizeSigner);
  instructions.push(winningPrizeInstructions);
  const claimed = auctionView.auctionManager.isItemClaimed(winningConfigIndex, safetyDeposit.info.order);

  if (!claimed) {
    var _accountsByMint$get;

    let newTokenAccount = (_accountsByMint$get = accountsByMint.get(safetyDeposit.info.tokenMint)) === null || _accountsByMint$get === void 0 ? void 0 : _accountsByMint$get.pubkey;
    if (!newTokenAccount) newTokenAccount = (0,account.createTokenAccount)(winningPrizeInstructions, wallet.publicKey, accountRentExempt, (0,lib.toPublicKey)(safetyDeposit.info.tokenMint), wallet.publicKey, winningPrizeSigner).toBase58();
    await (0,metaplex.redeemBid)(auctionView.auctionManager.vault, safetyDeposit.info.store, newTokenAccount, safetyDeposit.pubkey, auctionView.vault.info.fractionMint, wallet.publicKey.toBase58(), wallet.publicKey.toBase58(), undefined, undefined, false, winningPrizeInstructions, winningConfigIndex);
  }
}

async function claimUnusedPrizes_setupRedeemFullRightsTransferInstructions(auctionView, accountsByMint, accountRentExempt, wallet, safetyDeposit, item, signers, instructions, winningConfigIndex) {
  if (!wallet.publicKey) throw new wallet_adapter_base_.WalletNotConnectedError();
  const winningPrizeSigner = [];
  const winningPrizeInstructions = [];
  const claimed = auctionView.auctionManager.isItemClaimed(winningConfigIndex, safetyDeposit.info.order);
  signers.push(winningPrizeSigner);
  instructions.push(winningPrizeInstructions);

  if (!claimed) {
    var _accountsByMint$get2;

    let newTokenAccount = (_accountsByMint$get2 = accountsByMint.get(safetyDeposit.info.tokenMint)) === null || _accountsByMint$get2 === void 0 ? void 0 : _accountsByMint$get2.pubkey;
    if (!newTokenAccount) newTokenAccount = (0,account.createTokenAccount)(winningPrizeInstructions, wallet.publicKey, accountRentExempt, (0,lib.toPublicKey)(safetyDeposit.info.tokenMint), wallet.publicKey, winningPrizeSigner).toBase58();
    await (0,metaplex.redeemFullRightsTransferBid)(auctionView.auctionManager.vault, safetyDeposit.info.store, newTokenAccount, safetyDeposit.pubkey, auctionView.vault.info.fractionMint, wallet.publicKey.toBase58(), wallet.publicKey.toBase58(), winningPrizeInstructions, item.metadata.pubkey, wallet.publicKey.toBase58(), winningConfigIndex);
  }
}

async function setupWithdrawMasterEditionInstructions(connection, auctionView, wallet, safetyDeposit, item, signers, instructions) {
  if (!wallet.publicKey) throw new wallet_adapter_base_.WalletNotConnectedError();

  if (!item.masterEdition || !item.metadata) {
    return;
  }

  const myInstructions = [];
  const mySigners = [];
  const ata = (await (0,lib.findProgramAddress)([wallet.publicKey.toBuffer(), (0,lib.programIds)().token.toBuffer(), (0,lib.toPublicKey)(item.metadata.info.mint).toBuffer()], (0,lib.programIds)().associatedToken))[0];
  const existingAta = await connection.getAccountInfo((0,lib.toPublicKey)(ata));
  console.log('Existing ata?', existingAta);

  if (!existingAta) {
    (0,lib.createAssociatedTokenAccountInstruction)(myInstructions, (0,lib.toPublicKey)(ata), wallet.publicKey, wallet.publicKey, (0,lib.toPublicKey)(item.metadata.info.mint));
  }

  await (0,metaplex.withdrawMasterEdition)(auctionView.vault.pubkey, safetyDeposit.info.store, ata, safetyDeposit.pubkey, auctionView.vault.info.fractionMint, item.metadata.info.mint, myInstructions);
  instructions.push(myInstructions);
  signers.push(mySigners);
}

async function deprecatedSetupRedeemPrintingInstructions(auctionView, accountsByMint, accountRentExempt, wallet, safetyDeposit, item, signers, instructions, winningConfigIndex) {
  if (!wallet.publicKey) throw new wallet_adapter_base_.WalletNotConnectedError();

  if (!item.masterEdition || !item.metadata) {
    return;
  }

  const updateAuth = item.metadata.info.updateAuthority;
  const me = item.masterEdition;
  const reservationList = await (0,lib.deprecatedGetReservationList)(item.masterEdition.pubkey, auctionView.auctionManager.pubkey);
  const newTokenAccount = accountsByMint.get(me.info.printingMint);
  let newTokenAccountKey = newTokenAccount === null || newTokenAccount === void 0 ? void 0 : newTokenAccount.pubkey;

  if (updateAuth) {
    const claimed = auctionView.auctionManager.isItemClaimed(winningConfigIndex, safetyDeposit.info.order);
    console.log('This state item is', claimed);

    if (!claimed) {
      const winningPrizeSigner = [];
      const winningPrizeInstructions = [];
      signers.push(winningPrizeSigner);
      instructions.push(winningPrizeInstructions);
      if (!newTokenAccountKey) // TODO: switch to ATA
        newTokenAccountKey = (0,account.createTokenAccount)(winningPrizeInstructions, wallet.publicKey, accountRentExempt, (0,lib.toPublicKey)(me.info.printingMint), wallet.publicKey, winningPrizeSigner).toBase58();
      await (0,metaplex.redeemBid)(auctionView.auctionManager.vault, safetyDeposit.info.store, newTokenAccountKey, safetyDeposit.pubkey, auctionView.vault.info.fractionMint, wallet.publicKey.toBase58(), wallet.publicKey.toBase58(), item.masterEdition.pubkey, reservationList, true, winningPrizeInstructions, winningConfigIndex);
    }
  }
}
;// CONCATENATED MODULE: ./src/actions/cancelBid.ts





async function sendCancelBid(connection, wallet, payingAccount, auctionView, accountsByMint, bids, bidRedemptions, prizeTrackingTickets) {
  if (!wallet.publicKey) throw new wallet_adapter_base_.WalletNotConnectedError();
  const signers = [];
  const instructions = [];

  if (auctionView.auction.info.ended() && auctionView.auction.info.state !== lib.AuctionState.Ended) {
    await setupPlaceBid(connection, wallet, payingAccount, auctionView, accountsByMint, 0, instructions, signers);
  }

  const accountRentExempt = await connection.getMinimumBalanceForRentExemption(spl_token_.AccountLayout.span);
  await setupCancelBid(auctionView, accountsByMint, accountRentExempt, wallet, signers, instructions, connection);

  if (wallet.publicKey.equals((0,lib.toPublicKey)(auctionView.auctionManager.authority)) && auctionView.auction.info.ended()) {
    await claimUnusedPrizes(connection, wallet, auctionView, accountsByMint, bids, bidRedemptions, prizeTrackingTickets, signers, instructions);
  }

  instructions.length === 1 ? await (0,lib.sendTransactionWithRetry)(connection, wallet, instructions[0], signers[0], 'single') : await (0,lib.sendTransactions)(connection, wallet, instructions, signers, lib.SequenceType.StopOnFailure, 'single');
}
async function setupCancelBid(auctionView, accountsByMint, accountRentExempt, wallet, signers, instructions, connection) {
  if (!wallet.publicKey) throw new wallet_adapter_base_.WalletNotConnectedError();
  const cancelSigners = [];
  const cancelInstructions = [];
  const cleanupInstructions = [];
  const tokenAccount = accountsByMint.get(auctionView.auction.info.tokenMint);
  const mint = lib.cache.get(auctionView.auction.info.tokenMint);

  if (mint && auctionView.myBidderPot) {
    let receivingSolAccountOrAta = '';

    if (auctionView.auction.info.tokenMint == lib.WRAPPED_SOL_MINT.toBase58()) {
      receivingSolAccountOrAta = (0,lib.ensureWrappedAccount)(cancelInstructions, cleanupInstructions, tokenAccount, wallet.publicKey, accountRentExempt, cancelSigners);
    } else {
      receivingSolAccountOrAta = await findAta(auctionView, wallet, connection);
    }

    await (0,lib.cancelBid)(wallet.publicKey.toBase58(), (0,lib.pubkeyToString)(receivingSolAccountOrAta), auctionView.myBidderPot.info.bidderPot, auctionView.auction.info.tokenMint, auctionView.vault.pubkey, cancelInstructions);
    signers.push(cancelSigners);
    instructions.push([...cancelInstructions, ...cleanupInstructions.reverse()]);
  }
}
;// CONCATENATED MODULE: ./src/actions/sendPlaceBid.ts








async function sendPlaceBid(connection, wallet, bidderTokenAccount, auctionView, accountsByMint, // value entered by the user adjust to decimals of the mint
amount, commitment) {
  const signers = [];
  const instructions = [];
  const bid = await setupPlaceBid(connection, wallet, bidderTokenAccount, auctionView, accountsByMint, amount, instructions, signers);
  const {
    txid
  } = await (0,lib.sendTransactionWithRetry)(connection, wallet, instructions[0], signers[0], commitment);

  if (commitment) {
    await connection.confirmTransaction(txid, commitment);
  }

  return {
    amount: bid
  };
}
async function setupPlaceBid(connection, wallet, bidderTokenAccount, auctionView, accountsByMint, // value entered by the user adjust to decimals of the mint
// If BN, then assume instant sale and decimals already adjusted.
amount, overallInstructions, overallSigners) {
  if (!wallet.publicKey) throw new wallet_adapter_base_.WalletNotConnectedError();
  let signers = [];
  let instructions = [];
  const cleanupInstructions = [];
  const accountRentExempt = await connection.getMinimumBalanceForRentExemption(spl_token_.AccountLayout.span);
  const tokenAccount = bidderTokenAccount ? lib.cache.get(bidderTokenAccount) : undefined;
  const mint = lib.cache.get(tokenAccount ? tokenAccount.info.mint : QUOTE_MINT);
  const lamports = accountRentExempt + (typeof amount === 'number' ? (0,lib.toLamports)(amount, mint.info) : amount.toNumber());
  let bidderPotTokenAccount;

  if (auctionView.myBidderPot) {
    var _auctionView$myBidder;

    bidderPotTokenAccount = (_auctionView$myBidder = auctionView.myBidderPot) === null || _auctionView$myBidder === void 0 ? void 0 : _auctionView$myBidder.info.bidderPot;

    if (!auctionView.auction.info.ended()) {
      const cancelSigners = [];
      const cancelInstr = [];
      await setupCancelBid(auctionView, accountsByMint, accountRentExempt, wallet, cancelSigners, cancelInstr, connection);
      signers = [...signers, ...cancelSigners[0]];
      instructions = [...cancelInstr[0], ...instructions];
    }
  }

  let receivingSolAccountOrAta = '';

  if (auctionView.auction.info.tokenMint == lib.WRAPPED_SOL_MINT.toBase58()) {
    receivingSolAccountOrAta = (0,lib.ensureWrappedAccount)(instructions, cleanupInstructions, tokenAccount, wallet.publicKey, lamports + accountRentExempt * 2, signers);
  } else {
    receivingSolAccountOrAta = await findAta(auctionView, wallet, connection);
  }

  const transferAuthority = (0,models_account.approve)(instructions, cleanupInstructions, (0,lib.toPublicKey)(receivingSolAccountOrAta), wallet.publicKey, lamports - accountRentExempt);
  signers.push(transferAuthority);
  const bid = new (external_bn_js_default())(lamports - accountRentExempt);
  await (0,lib.placeBid)(wallet.publicKey.toBase58(), (0,lib.pubkeyToString)(receivingSolAccountOrAta), bidderPotTokenAccount, auctionView.auction.info.tokenMint, transferAuthority.publicKey.toBase58(), wallet.publicKey.toBase58(), auctionView.auctionManager.vault, bid, instructions);
  overallInstructions.push([...instructions, ...cleanupInstructions.reverse()]);
  overallSigners.push(signers);
  return bid;
}
const findAta = async (auctionView, wallet, connection) => {
  if (!wallet.publicKey) throw new wallet_adapter_base_.WalletNotConnectedError();
  let receivingSolAccountOrAta = ''; // if alternative currency is set, go for it

  const PROGRAM_IDS = (0,lib.programIds)();
  const auctionTokenMint = new web3_js_.PublicKey(auctionView.auction.info.tokenMint);
  const ata = (await web3_js_.PublicKey.findProgramAddress([wallet.publicKey.toBuffer(), PROGRAM_IDS.token.toBuffer(), auctionTokenMint.toBuffer()], PROGRAM_IDS.associatedToken))[0];
  receivingSolAccountOrAta = (0,lib.pubkeyToString)(ata);
  const settleInstructions = [];
  const existingAta = await connection.getAccountInfo(ata); // create a new ATA if there is none

  console.log('Looking for existing ata?', existingAta);

  if (!existingAta) {
    (0,lib.createAssociatedTokenAccountInstruction)(settleInstructions, (0,lib.toPublicKey)(receivingSolAccountOrAta), wallet.publicKey, wallet.publicKey, auctionTokenMint);
  }

  return receivingSolAccountOrAta;
};
;// CONCATENATED MODULE: ./src/actions/settle.ts





const settle_BATCH_SIZE = 10;
const SETTLE_TRANSACTION_SIZE = 6;
const CLAIM_TRANSACTION_SIZE = 6;
async function settle(connection, wallet, auctionView, bidsToClaim, payingAccount, accountsByMint) {
  if (auctionView.auction.info.ended() && auctionView.auction.info.state !== lib.AuctionState.Ended) {
    const signers = [];
    const instructions = [];
    await setupPlaceBid(connection, wallet, payingAccount, auctionView, accountsByMint, 0, instructions, signers);
    await (0,lib.sendTransactionWithRetry)(connection, wallet, instructions[0], signers[0]);
  }

  await claimAllBids(connection, wallet, auctionView, bidsToClaim);
  await emptyPaymentAccountForAllTokens(connection, wallet, auctionView);
}

async function emptyPaymentAccountForAllTokens(connection, wallet, auctionView) {
  if (!wallet.publicKey) throw new wallet_adapter_base_.WalletNotConnectedError();
  const PROGRAM_IDS = (0,lib.programIds)();
  const signers = [];
  const instructions = [];
  let currSignerBatch = [];
  let currInstrBatch = [];
  let settleSigners = [];
  let settleInstructions = [];
  const ataLookup = {}; // TODO replace all this with payer account so user doesnt need to click approve several times.
  // Overall we have 10 parallel txns, of up to 4 settlements per txn
  // That's what this loop is building.

  const prizeArrays = [...auctionView.items, ...(auctionView.participationItem ? [[auctionView.participationItem]] : [])];

  for (let i = 0; i < prizeArrays.length; i++) {
    const items = prizeArrays[i];

    for (let j = 0; j < items.length; j++) {
      const item = items[j];
      const creators = item.metadata.info.data.creators;
      const edgeCaseWhereCreatorIsAuctioneer = !!(creators !== null && creators !== void 0 && creators.map(c => c.address).find(c => c === auctionView.auctionManager.authority));
      const addresses = [...(creators ? creators.map(c => c.address) : []), ...[auctionView.auctionManager.authority]];

      for (let k = 0; k < addresses.length; k++) {
        var _item$masterEdition;

        const ata = (await (0,lib.findProgramAddress)([(0,lib.toPublicKey)(addresses[k]).toBuffer(), PROGRAM_IDS.token.toBuffer(), (0,lib.toPublicKey)(auctionView.auction.info.tokenMint).toBuffer()], PROGRAM_IDS.associatedToken))[0];
        const existingAta = await connection.getAccountInfo((0,lib.toPublicKey)(ata));
        console.log('Existing ata?', existingAta);
        if (!existingAta && !ataLookup[ata]) (0,lib.createAssociatedTokenAccountInstruction)(settleInstructions, (0,lib.toPublicKey)(ata), wallet.publicKey, (0,lib.toPublicKey)(addresses[k]), (0,lib.toPublicKey)(auctionView.auction.info.tokenMint));
        ataLookup[ata] = true;
        const creatorIndex = creators ? creators.map(c => c.address).indexOf(addresses[k]) : null;
        await (0,emptyPaymentAccount/* emptyPaymentAccount */.C)(auctionView.auctionManager.acceptPayment, ata, auctionView.auctionManager.pubkey, item.metadata.pubkey, (_item$masterEdition = item.masterEdition) === null || _item$masterEdition === void 0 ? void 0 : _item$masterEdition.pubkey, item.safetyDeposit.pubkey, item.safetyDeposit.info.vault, auctionView.auction.pubkey, wallet.publicKey.toBase58(), addresses[k], item === auctionView.participationItem ? null : i, item === auctionView.participationItem ? null : j, creatorIndex === -1 || creatorIndex === null || edgeCaseWhereCreatorIsAuctioneer && k === addresses.length - 1 ? null : creatorIndex, settleInstructions);

        if (settleInstructions.length >= SETTLE_TRANSACTION_SIZE) {
          currSignerBatch.push(settleSigners);
          currInstrBatch.push(settleInstructions);
          settleSigners = [];
          settleInstructions = [];
        }

        if (currInstrBatch.length === settle_BATCH_SIZE) {
          signers.push(currSignerBatch);
          instructions.push(currInstrBatch);
          currSignerBatch = [];
          currInstrBatch = [];
        }
      }
    }
  }

  if (settleInstructions.length < SETTLE_TRANSACTION_SIZE && settleInstructions.length > 0) {
    currSignerBatch.push(settleSigners);
    currInstrBatch.push(settleInstructions);
  }

  if (currInstrBatch.length <= settle_BATCH_SIZE && currInstrBatch.length > 0) {
    // add the last one on
    signers.push(currSignerBatch);
    instructions.push(currInstrBatch);
  }

  for (let i = 0; i < instructions.length; i++) {
    const instructionBatch = instructions[i];
    const signerBatch = signers[i];
    if (instructionBatch.length >= 2) // Pump em through!
      await (0,lib.sendTransactions)(connection, wallet, instructionBatch, signerBatch, lib.SequenceType.StopOnFailure, 'single');else await (0,lib.sendTransactionWithRetry)(connection, wallet, instructionBatch[0], signerBatch[0], 'single');
  }
}

async function claimAllBids(connection, wallet, auctionView, bids) {
  const signers = [];
  const instructions = [];
  let currSignerBatch = [];
  let currInstrBatch = [];
  let claimBidSigners = [];
  let claimBidInstructions = []; // TODO replace all this with payer account so user doesnt need to click approve several times.
  // Overall we have 10 parallel txns, of up to 7 claims in each txn
  // That's what this loop is building.

  for (let i = 0; i < bids.length; i++) {
    const bid = bids[i];
    console.log('Claiming', bid.info.bidderAct);
    await (0,claimBid/* claimBid */.G)(auctionView.auctionManager.acceptPayment, bid.info.bidderAct, bid.info.bidderPot, auctionView.vault.pubkey, auctionView.auction.info.tokenMint, claimBidInstructions);

    if (claimBidInstructions.length === CLAIM_TRANSACTION_SIZE) {
      currSignerBatch.push(claimBidSigners);
      currInstrBatch.push(claimBidInstructions);
      claimBidSigners = [];
      claimBidInstructions = [];
    }

    if (currInstrBatch.length === settle_BATCH_SIZE) {
      signers.push(currSignerBatch);
      instructions.push(currInstrBatch);
      currSignerBatch = [];
      currInstrBatch = [];
    }
  }

  if (claimBidInstructions.length < CLAIM_TRANSACTION_SIZE && claimBidInstructions.length > 0) {
    currSignerBatch.push(claimBidSigners);
    currInstrBatch.push(claimBidInstructions);
  }

  if (currInstrBatch.length <= settle_BATCH_SIZE && currInstrBatch.length > 0) {
    // add the last one on
    signers.push(currSignerBatch);
    instructions.push(currInstrBatch);
  }

  console.log('Instructions', instructions);

  for (let i = 0; i < instructions.length; i++) {
    const instructionBatch = instructions[i];
    const signerBatch = signers[i];
    console.log('Running batch', i);
    if (instructionBatch.length >= 2) // Pump em through!
      await (0,lib.sendTransactions)(connection, wallet, instructionBatch, signerBatch, lib.SequenceType.StopOnFailure, 'single');else await (0,lib.sendTransactionWithRetry)(connection, wallet, instructionBatch[0], signerBatch[0], 'single');
    console.log('Done');
  }
}
;// CONCATENATED MODULE: ./src/actions/startAuctionManually.ts


async function startAuctionManually(connection, wallet, auctionView) {
  try {
    const signers = [];
    const instructions = [];
    await (0,metaplex.startAuction)(auctionView.vault.pubkey, auctionView.auctionManager.authority, instructions);
    await (0,lib.sendTransactionWithRetry)(connection, wallet, instructions, signers);
    (0,lib.notify)({
      message: 'Auction started',
      type: 'success'
    });
  } catch (e) {
    (0,lib.notify)({
      message: 'Transaction failed...',
      description: 'Failed to start the auction',
      type: 'error'
    });
    return Promise.reject(e);
  }
}
// EXTERNAL MODULE: ../common/dist/lib/contexts/meta/meta.js
var meta = __webpack_require__(5778);
;// CONCATENATED MODULE: ./src/contexts/coingecko.tsx


const COINGECKO_POOL_INTERVAL = 1000 * 60; // 60 sec

const COINGECKO_API = 'https://api.coingecko.com/api/v3/';
const COINGECKO_COIN_PRICE_API = `${COINGECKO_API}simple/price`;
const solToUSD = async () => {
  const url = `${COINGECKO_COIN_PRICE_API}?ids=solana&vs_currencies=usd`;
  const resp = await window.fetch(url).then(resp => resp.json());
  return resp.solana.usd;
};
const altSplToUSD = async cgTokenName => {
  var _resp$cg_spl_token_id;

  if ( false || "kinXdEcpDQeHPEuQnqmUgtYykqKGVFq6CeVX5iAHJq6,ETAtLmCmsoiEEKfNrHKJ2kYy3MoABhU6NQvpSfij5tDs,BLwTnYKqf7u4qjgZrrsKeNs2EzWkMLqVCu6j8iHyrNA3,ATLASXmbPQxBUYbxPsV97usA3fPQYEqzQBUHgiFCUsXx,EPjFWdd5AufqSSqeM2qN1xzybapC8G4wEGGkZwyTDt1v".length == 0) return 0;
  const cg_spl_token_id = cgTokenName ? cgTokenName.toLowerCase().split(' ').join('-') : process.env.NEXT_CG_SPL_TOKEN_ID || '';
  const url = `${COINGECKO_COIN_PRICE_API}?ids=${cg_spl_token_id}&vs_currencies=usd`;
  const resp = await window.fetch(url).then(resp => resp.json()); //console.log("[--P]Processing", cgTokenName, resp)

  return (_resp$cg_spl_token_id = resp[cg_spl_token_id]) === null || _resp$cg_spl_token_id === void 0 ? void 0 : _resp$cg_spl_token_id.usd;
};
const CoingeckoContext = /*#__PURE__*/external_react_default().createContext(null);
function CoingeckoProvider({
  children = null
}) {
  const {
    0: solPrice,
    1: setSolPrice
  } = (0,external_react_.useState)(0);
  const {
    0: allSplPrices,
    1: setAllSplPrices
  } = (0,external_react_.useState)([]);
  (0,external_react_.useEffect)(() => {
    let timerId = 0;

    const queryPrice = async () => {
      const solprice = await solToUSD();
      setSolPrice(solprice);
      const subscribedTokenMints =  true ? "kinXdEcpDQeHPEuQnqmUgtYykqKGVFq6CeVX5iAHJq6,ETAtLmCmsoiEEKfNrHKJ2kYy3MoABhU6NQvpSfij5tDs,BLwTnYKqf7u4qjgZrrsKeNs2EzWkMLqVCu6j8iHyrNA3,ATLASXmbPQxBUYbxPsV97usA3fPQYEqzQBUHgiFCUsXx,EPjFWdd5AufqSSqeM2qN1xzybapC8G4wEGGkZwyTDt1v".split(',') : 0;
      const subscribedTokenIDS =  true ? "kin,media-network,boring-protocol,star-atlas,usd-coin".split(',') : 0;
      const splPricePromises = [];

      for (let i = 0; i < subscribedTokenMints.length; i++) {
        const splName = subscribedTokenIDS[i];
        const splMint = subscribedTokenMints[i]; //console.log("[--P]PROCESSING TOKEN",i,  splName, splMint)

        splPricePromises.push((async () => {
          try {
            const splPrice = await altSplToUSD(splName); //console.log("[--P]PRICE", splPrice)

            return {
              tokenMint: splMint,
              tokenName: splName,
              tokenPrice: splPrice
            };
          } catch (e) {//console.log("[--P] error setting", e)
          }
        })());
      }

      const allSplPrices = await Promise.all(splPricePromises);
      setAllSplPrices(allSplPrices.filter(Boolean)); //console.log("[--P]SUBSCRIBED TOKENS", allSplPrices)

      startTimer();
    };

    const startTimer = () => {
      timerId = window.setTimeout(async () => {
        queryPrice();
      }, COINGECKO_POOL_INTERVAL);
    };

    queryPrice();
    return () => {
      clearTimeout(timerId);
    };
  }, [setSolPrice, setAllSplPrices]);
  return /*#__PURE__*/jsx_runtime_.jsx(CoingeckoContext.Provider, {
    value: {
      solPrice,
      allSplPrices
    },
    children: children
  });
}
const useCoingecko = () => {
  const context = (0,external_react_.useContext)(CoingeckoContext);
  return context;
};
const useSolPrice = () => {
  const {
    solPrice
  } = useCoingecko();
  return solPrice;
};
const useAllSplPrices = () => {
  const {
    allSplPrices
  } = useCoingecko();
  return allSplPrices;
};
;// CONCATENATED MODULE: ./src/contexts/index.tsx


;// CONCATENATED MODULE: ./src/types/index.ts
let ArtType;

(function (ArtType) {
  ArtType[ArtType["Master"] = 0] = "Master";
  ArtType[ArtType["Print"] = 1] = "Print";
  ArtType[ArtType["NFT"] = 2] = "NFT";
})(ArtType || (ArtType = {}));
// EXTERNAL MODULE: external "three"
var external_three_ = __webpack_require__(2293);
// EXTERNAL MODULE: external "react-intersection-observer"
var external_react_intersection_observer_ = __webpack_require__(2889);
// EXTERNAL MODULE: external "buffer-layout"
var external_buffer_layout_ = __webpack_require__(2949);
;// CONCATENATED MODULE: ./src/utils/layout.ts




/**
 * Layout for a public key
 */

const publicKey = (property = 'publicKey') => {
  const publicKeyLayout = BufferLayout.blob(32, property);

  const _decode = publicKeyLayout.decode.bind(publicKeyLayout);

  const _encode = publicKeyLayout.encode.bind(publicKeyLayout);

  publicKeyLayout.decode = (buffer, offset) => {
    const data = _decode(buffer, offset);

    return new PublicKey(data);
  };

  publicKeyLayout.encode = (key, buffer, offset) => {
    return _encode(key.toBuffer(), buffer, offset);
  };

  return publicKeyLayout;
};
/**
 * Layout for a 64bit unsigned value
 */

const uint64 = (property = 'uint64') => {
  const layout = BufferLayout.blob(8, property);

  const _decode = layout.decode.bind(layout);

  const _encode = layout.encode.bind(layout);

  layout.decode = (buffer, offset) => {
    const data = _decode(buffer, offset);

    return new BN([...data].reverse().map(i => `00${i.toString(16)}`.slice(-2)).join(''), 16);
  };

  layout.encode = (num, buffer, offset) => {
    const a = num.toArray().reverse();
    let b = Buffer.from(a);

    if (b.length !== 8) {
      const zeroPad = Buffer.alloc(8);
      b.copy(zeroPad);
      b = zeroPad;
    }

    return _encode(b, buffer, offset);
  };

  return layout;
}; // TODO: wrap in BN (what about decimals?)

const uint128 = (property = 'uint128') => {
  const layout = BufferLayout.blob(16, property);

  const _decode = layout.decode.bind(layout);

  const _encode = layout.encode.bind(layout);

  layout.decode = (buffer, offset) => {
    const data = _decode(buffer, offset);

    return new BN([...data].reverse().map(i => `00${i.toString(16)}`.slice(-2)).join(''), 16);
  };

  layout.encode = (num, buffer, offset) => {
    const a = num.toArray().reverse();
    let b = Buffer.from(a);

    if (b.length !== 16) {
      const zeroPad = Buffer.alloc(16);
      b.copy(zeroPad);
      b = zeroPad;
    }

    return _encode(b, buffer, offset);
  };

  return layout;
};
/**
 * Layout for a Rust String type
 */

const rustString = (property = 'string') => {
  const rsl = BufferLayout.struct([BufferLayout.u32('length'), BufferLayout.u32('lengthPadding'), BufferLayout.blob(BufferLayout.offset(BufferLayout.u32(), -8), 'chars')], property);

  const _decode = rsl.decode.bind(rsl);

  const _encode = rsl.encode.bind(rsl);

  rsl.decode = (buffer, offset) => {
    const data = _decode(buffer, offset);

    return data.chars.toString('utf8');
  };

  rsl.encode = (str, buffer, offset) => {
    const data = {
      chars: Buffer.from(str, 'utf8')
    };
    return _encode(data, buffer, offset);
  };

  return rsl;
};

function getWindowDimensions() {
  const {
    innerWidth: width,
    innerHeight: height
  } = window;
  return {
    width,
    height
  };
}

function useWindowDimensions() {
  const {
    0: windowDimensions,
    1: setWindowDimensions
  } = (0,external_react_.useState)(getWindowDimensions());
  (0,external_react_.useEffect)(() => {
    function handleResize() {
      setWindowDimensions(getWindowDimensions());
    }

    window.addEventListener('resize', handleResize);
    return () => window.removeEventListener('resize', handleResize);
  }, []);
  return windowDimensions;
}
;// CONCATENATED MODULE: ./src/hooks/useArt.ts







const metadataToArt = (info, editions, masterEditions, whitelistedCreatorsByCreator) => {
  let type = ArtType.NFT;
  let editionNumber = undefined;
  let maxSupply = undefined;
  let supply = undefined;

  if (info) {
    const masterEdition = masterEditions[info.masterEdition || ''];
    const edition = editions[info.edition || ''];

    if (edition) {
      const myMasterEdition = masterEditions[edition.info.parent || ''];

      if (myMasterEdition) {
        var _myMasterEdition$info;

        type = ArtType.Print;
        editionNumber = edition.info.edition.toNumber();
        supply = ((_myMasterEdition$info = myMasterEdition.info) === null || _myMasterEdition$info === void 0 ? void 0 : _myMasterEdition$info.supply.toNumber()) || 0;
      }
    } else if (masterEdition) {
      var _masterEdition$info$m;

      type = ArtType.Master;
      maxSupply = (_masterEdition$info$m = masterEdition.info.maxSupply) === null || _masterEdition$info$m === void 0 ? void 0 : _masterEdition$info$m.toNumber();
      supply = masterEdition.info.supply.toNumber();
    }
  }

  return {
    uri: (info === null || info === void 0 ? void 0 : info.data.uri) || '',
    mint: info === null || info === void 0 ? void 0 : info.mint,
    title: info === null || info === void 0 ? void 0 : info.data.name,
    creators: ((info === null || info === void 0 ? void 0 : info.data.creators) || []).map(creator => {
      const knownCreator = whitelistedCreatorsByCreator[creator.address];
      return {
        address: creator.address,
        verified: creator.verified,
        share: creator.share,
        image: (knownCreator === null || knownCreator === void 0 ? void 0 : knownCreator.info.image) || '',
        name: (knownCreator === null || knownCreator === void 0 ? void 0 : knownCreator.info.name) || '',
        link: (knownCreator === null || knownCreator === void 0 ? void 0 : knownCreator.info.twitter) || ''
      };
    }).sort((a, b) => {
      const share = (b.share || 0) - (a.share || 0);

      if (share === 0) {
        return a.name.localeCompare(b.name);
      }

      return share;
    }),
    seller_fee_basis_points: (info === null || info === void 0 ? void 0 : info.data.sellerFeeBasisPoints) || 0,
    edition: editionNumber,
    maxSupply,
    supply,
    type
  };
};
const cachedImages = new Map();
const useCachedImage = (uri, cacheMesh) => {
  const {
    0: cachedBlob,
    1: setCachedBlob
  } = (0,external_react_.useState)(undefined);
  const {
    0: isLoading,
    1: setIsLoading
  } = (0,external_react_.useState)(true);
  (0,external_react_.useEffect)(() => {
    if (!uri) {
      return;
    }

    const result = cachedImages.get(uri);

    if (result) {
      setCachedBlob(result);
      return;
    }

    (async () => {
      let response;
      let blob;

      try {
        response = await fetch(uri, {
          cache: 'force-cache'
        });
        blob = await response.blob();

        if (blob.size === 0) {
          throw new Error('No content');
        }
      } catch {
        try {
          response = await fetch(uri, {
            cache: 'reload'
          });
          blob = await response.blob();
        } catch {
          // If external URL, just use the uri
          if (uri !== null && uri !== void 0 && uri.startsWith('http')) {
            setCachedBlob(uri);
          }

          setIsLoading(false);
          return;
        }
      }

      if (blob.size === 0) {
        setIsLoading(false);
        return;
      }

      if (cacheMesh) {
        // extra caching for meshviewer
        external_three_.Cache.enabled = true;
        external_three_.Cache.add(uri, await blob.arrayBuffer());
      }

      const blobURI = URL.createObjectURL(blob);
      cachedImages.set(uri, blobURI);
      setCachedBlob(blobURI);
      setIsLoading(false);
    })();
  }, [uri, setCachedBlob, setIsLoading]);
  return {
    cachedBlob,
    isLoading
  };
};
const useArt = key => {
  const {
    metadata,
    editions,
    masterEditions,
    whitelistedCreatorsByCreator
  } = (0,meta.useMeta)();
  const account = (0,external_react_.useMemo)(() => metadata.find(a => a.pubkey === key), [key, metadata]);
  const art = (0,external_react_.useMemo)(() => metadataToArt(account === null || account === void 0 ? void 0 : account.info, editions, masterEditions, whitelistedCreatorsByCreator), [account, editions, masterEditions, whitelistedCreatorsByCreator]);
  return art;
};
const useExtendedArt = id => {
  const {
    metadata
  } = (0,meta.useMeta)();
  const {
    0: data,
    1: setData
  } = (0,external_react_.useState)();
  const {
    width
  } = useWindowDimensions();
  const {
    ref,
    inView
  } = (0,external_react_intersection_observer_.useInView)({
    root: null,
    rootMargin: '-100px 0px'
  });
  const localStorage = (0,lib.useLocalStorage)();
  const key = (0,lib.pubkeyToString)(id);
  const account = (0,external_react_.useMemo)(() => metadata.find(a => a.pubkey === key), [key, metadata]);
  (0,external_react_.useEffect)(() => {
    if ((inView || width < 768) && id && !data) {
      const USE_CDN = false;

      const routeCDN = uri => {
        let result = uri;

        if (USE_CDN) {
          result = uri.replace('https://arweave.net/', 'https://coldcdn.com/api/cdn/bronil/');
        }

        return result;
      };

      if (account && account.info.data.uri) {
        const uri = routeCDN(account.info.data.uri);

        const processJson = extended => {
          var _extended$properties, _extended$properties$;

          if (!extended || (extended === null || extended === void 0 ? void 0 : (_extended$properties = extended.properties) === null || _extended$properties === void 0 ? void 0 : (_extended$properties$ = _extended$properties.files) === null || _extended$properties$ === void 0 ? void 0 : _extended$properties$.length) === 0) {
            return;
          }

          if (extended !== null && extended !== void 0 && extended.image) {
            const file = extended.image.startsWith('http') ? extended.image : `${account.info.data.uri}/${extended.image}`;
            extended.image = routeCDN(file);
          }

          return extended;
        };

        try {
          const cached = localStorage.getItem(uri);

          if (cached) {
            setData(processJson(JSON.parse(cached)));
          } else {
            // TODO: BL handle concurrent calls to avoid double query
            fetch(uri).then(async _ => {
              try {
                const data = await _.json();

                try {
                  localStorage.setItem(uri, JSON.stringify(data));
                } catch {// ignore
                }

                setData(processJson(data));
              } catch {
                return undefined;
              }
            }).catch(() => {
              return undefined;
            });
          }
        } catch (ex) {
          console.error(ex);
        }
      }
    }
  }, [inView, id, data, setData, account]);
  return {
    ref,
    data
  };
};
;// CONCATENATED MODULE: ./src/hooks/useAuctions.ts






let AuctionViewState; // Flattened surface item for easy display

(function (AuctionViewState) {
  AuctionViewState["Live"] = "0";
  AuctionViewState["Upcoming"] = "1";
  AuctionViewState["Ended"] = "2";
  AuctionViewState["BuyNow"] = "3";
  AuctionViewState["Defective"] = "-1";
})(AuctionViewState || (AuctionViewState = {}));

function useStoreAuctionsList() {
  const {
    auctions,
    auctionManagersByAuction
  } = (0,meta.useMeta)();
  const result = (0,external_react_.useMemo)(() => {
    return Object.values(auctionManagersByAuction).map(manager => auctions[manager.info.auction]).filter(Boolean);
  }, [Object.keys(auctions).length, auctionManagersByAuction]);
  return result;
}
function useCachedRedemptionKeysByWallet() {
  const {
    bidRedemptions
  } = (0,meta.useMeta)();
  const auctions = useStoreAuctionsList();
  const {
    publicKey
  } = (0,wallet_adapter_react_.useWallet)();
  const {
    0: cachedRedemptionKeys,
    1: setCachedRedemptionKeys
  } = (0,external_react_.useState)({});
  (0,external_react_.useEffect)(() => {
    if (!publicKey) return;

    (async () => {
      const temp = Object.assign({}, cachedRedemptionKeys);
      await (0,lib.createPipelineExecutor)(auctions.values(), async auction => {
        if (!cachedRedemptionKeys[auction.pubkey]) {
          const key = await (0,metaplex.getBidderKeys)(auction.pubkey, publicKey.toBase58());
          temp[auction.pubkey] = bidRedemptions[key.bidRedemption] ? bidRedemptions[key.bidRedemption] : {
            pubkey: key.bidRedemption,
            info: null
          };
        } else if (!cachedRedemptionKeys[auction.pubkey].info) {
          temp[auction.pubkey] = bidRedemptions[cachedRedemptionKeys[auction.pubkey].pubkey] || cachedRedemptionKeys[auction.pubkey];
        }
      }, {
        delay: 1,
        sequence: 2
      });

      if (Object.keys(temp).length) {
        setCachedRedemptionKeys(temp);
      }
    })();
  }, [auctions, bidRedemptions, publicKey]);
  return cachedRedemptionKeys;
}
const useAuctions = state => {
  const {
    0: auctionViews,
    1: setAuctionViews
  } = (0,external_react_.useState)([]);
  const {
    publicKey
  } = (0,wallet_adapter_react_.useWallet)();
  const cachedRedemptionKeys = useCachedRedemptionKeysByWallet();
  const auctions = useStoreAuctionsList();
  const {
    auctionManagersByAuction,
    safetyDepositBoxesByVaultAndIndex,
    metadataByMint,
    bidderMetadataByAuctionAndBidder,
    bidderPotsByAuctionAndBidder,
    vaults,
    masterEditions,
    masterEditionsByPrintingMint,
    masterEditionsByOneTimeAuthMint,
    metadataByMasterEdition,
    safetyDepositConfigsByAuctionManagerAndIndex,
    bidRedemptionV2sByAuctionManagerAndWinningIndex,
    auctionDataExtended,
    metadataByAuction
  } = (0,meta.useMeta)();
  (0,external_react_.useEffect)(() => {
    const auctionViews = [];
    auctions.map(auction => {
      const auctionView = processAccountsIntoAuctionView(publicKey === null || publicKey === void 0 ? void 0 : publicKey.toBase58(), auction, auctionDataExtended, auctionManagersByAuction, safetyDepositBoxesByVaultAndIndex, metadataByMint, bidderMetadataByAuctionAndBidder, bidderPotsByAuctionAndBidder, bidRedemptionV2sByAuctionManagerAndWinningIndex, masterEditions, vaults, safetyDepositConfigsByAuctionManagerAndIndex, masterEditionsByPrintingMint, masterEditionsByOneTimeAuthMint, metadataByMasterEdition, cachedRedemptionKeys, metadataByAuction, state);

      if (auctionView) {
        auctionViews.push(auctionView);
      }
    });
    setAuctionViews(auctionViews.sort(sortByEnded));
  }, [state, auctions, auctionDataExtended, auctionManagersByAuction, safetyDepositBoxesByVaultAndIndex, metadataByMint, bidderMetadataByAuctionAndBidder, bidderPotsByAuctionAndBidder, bidRedemptionV2sByAuctionManagerAndWinningIndex, vaults, safetyDepositConfigsByAuctionManagerAndIndex, masterEditions, masterEditionsByPrintingMint, masterEditionsByOneTimeAuthMint, metadataByMasterEdition, publicKey, cachedRedemptionKeys, metadataByAuction, setAuctionViews]);
  return auctionViews;
};

function sortByEnded(a, b) {
  var _b$auction$info$ended, _a$auction$info$ended;

  return (((_b$auction$info$ended = b.auction.info.endedAt) === null || _b$auction$info$ended === void 0 ? void 0 : _b$auction$info$ended.toNumber()) || 0) - (((_a$auction$info$ended = a.auction.info.endedAt) === null || _a$auction$info$ended === void 0 ? void 0 : _a$auction$info$ended.toNumber()) || 0);
}

function isInstantSale(auctionDataExt, auction) {
  return !!(auctionDataExt !== null && auctionDataExt !== void 0 && auctionDataExt.info.instantSalePrice && auction.info.priceFloor.minPrice && auctionDataExt !== null && auctionDataExt !== void 0 && auctionDataExt.info.instantSalePrice.eq(auction.info.priceFloor.minPrice));
}

function buildListWhileNonZero(hash, key) {
  const list = [];
  let ticket = hash[key + '-0'];

  if (ticket) {
    list.push(ticket);
    let i = 1;

    while (ticket) {
      ticket = hash[key + '-' + i.toString()];
      if (ticket) list.push(ticket);
      i++;
    }
  }

  return list;
}
function processAccountsIntoAuctionView(walletPubkey, auction, auctionDataExtended, auctionManagersByAuction, safetyDepositBoxesByVaultAndIndex, metadataByMint, bidderMetadataByAuctionAndBidder, bidderPotsByAuctionAndBidder, bidRedemptionV2sByAuctionManagerAndWinningIndex, masterEditions, vaults, safetyDepositConfigsByAuctionManagerAndIndex, masterEditionsByPrintingMint, masterEditionsByOneTimeAuthMint, metadataByMasterEdition, cachedRedemptionKeysByWallet, metadataByAuction, desiredState) {
  let state;

  if (auction.info.ended()) {
    state = AuctionViewState.Ended;
  } else if (auction.info.state === lib.AuctionState.Started) {
    state = AuctionViewState.Live;
  } else if (auction.info.state === lib.AuctionState.Created) {
    state = AuctionViewState.Upcoming;
  } else {
    state = AuctionViewState.BuyNow;
  }

  const auctionManagerInstance = auctionManagersByAuction[auction.pubkey || '']; // The defective auction view state really applies to auction managers, not auctions, so we ignore it here

  if (desiredState && desiredState !== AuctionViewState.Defective && desiredState !== state) return undefined;

  if (auctionManagerInstance) {
    var _cachedRedemptionKeys;

    // instead we apply defective state to auction managers
    if (desiredState === AuctionViewState.Defective && auctionManagerInstance.info.state.status !== metaplex.AuctionManagerStatus.Initialized) return undefined; // Generally the only way an initialized auction manager can get through is if you are asking for defective ones.
    else if (desiredState !== AuctionViewState.Defective && auctionManagerInstance.info.state.status === metaplex.AuctionManagerStatus.Initialized) return undefined;
    const vault = vaults[auctionManagerInstance.info.vault];
    const auctionManagerKey = auctionManagerInstance.pubkey;
    const safetyDepositConfigs = buildListWhileNonZero(safetyDepositConfigsByAuctionManagerAndIndex, auctionManagerKey);
    const bidRedemptions = buildListWhileNonZero(bidRedemptionV2sByAuctionManagerAndWinningIndex, auctionManagerKey);
    const auctionManager = new metaplex.AuctionManager({
      instance: auctionManagerInstance,
      auction,
      vault,
      safetyDepositConfigs,
      bidRedemptions
    });
    const auctionDataExtendedKey = auctionManagerInstance.info.key == metaplex.MetaplexKey.AuctionManagerV2 ? auctionManagerInstance.info.auctionDataExtended : null;
    const auctionDataExt = auctionDataExtendedKey ? auctionDataExtended[auctionDataExtendedKey] : null;
    const boxesExpected = auctionManager.safetyDepositBoxesExpected.toNumber();
    const bidRedemption = (_cachedRedemptionKeys = cachedRedemptionKeysByWallet[auction.pubkey]) !== null && _cachedRedemptionKeys !== void 0 && _cachedRedemptionKeys.info ? cachedRedemptionKeysByWallet[auction.pubkey] : undefined;
    const bidderMetadata = bidderMetadataByAuctionAndBidder[auction.pubkey + '-' + walletPubkey];
    const bidderPot = bidderPotsByAuctionAndBidder[auction.pubkey + '-' + walletPubkey];
    const vaultKey = auctionManager.vault;
    const boxes = buildListWhileNonZero(safetyDepositBoxesByVaultAndIndex, vaultKey);
    let participationMetadata = undefined;
    let participationBox = undefined;
    let participationMaster = undefined;

    if (auctionManager.participationConfig !== null && auctionManager.participationConfig !== undefined && boxes.length > 0) {
      var _auctionManager$parti, _masterEditionsByOneT;

      participationBox = boxes[(_auctionManager$parti = auctionManager.participationConfig) === null || _auctionManager$parti === void 0 ? void 0 : _auctionManager$parti.safetyDepositBoxIndex]; // Cover case of V1 master edition (where we're using one time auth mint in storage)
      // and case of v2 master edition where the edition itself is stored

      participationMetadata = metadataByMasterEdition[(_masterEditionsByOneT = masterEditionsByOneTimeAuthMint[participationBox.info.tokenMint]) === null || _masterEditionsByOneT === void 0 ? void 0 : _masterEditionsByOneT.pubkey] || metadataByMint[participationBox.info.tokenMint];

      if (participationMetadata) {
        participationMaster = masterEditionsByOneTimeAuthMint[participationBox.info.tokenMint] || participationMetadata.info.masterEdition && masterEditions[participationMetadata.info.masterEdition];
      }
    }

    const view = {
      auction,
      auctionManager,
      state,
      vault,
      auctionDataExtended: auctionDataExt || undefined,
      safetyDepositBoxes: boxes,
      items: auctionManager.getItemsFromSafetyDepositBoxes(metadataByMint, masterEditionsByPrintingMint, metadataByMasterEdition, masterEditions, boxes),
      participationItem: participationMetadata && participationBox ? {
        metadata: participationMetadata,
        safetyDeposit: participationBox,
        masterEdition: participationMaster,
        amount: new (external_bn_js_default())(1),
        winningConfigType: metaplex.WinningConfigType.Participation
      } : undefined,
      myBidderMetadata: bidderMetadata,
      myBidderPot: bidderPot,
      myBidRedemption: bidRedemption
    };
    view.thumbnail = ((view.items || [])[0] || [])[0] || view.participationItem || (metadataByAuction[auction.pubkey] ? {
      metadata: metadataByAuction[auction.pubkey][0]
    } : null);
    view.isInstantSale = isInstantSale(auctionDataExt, auction);
    view.totallyComplete = !!(view.thumbnail && boxesExpected === (view.items || []).length + (auctionManager.participationConfig === null || auctionManager.participationConfig === undefined ? 0 : 1) && (auctionManager.participationConfig === null || auctionManager.participationConfig === undefined || auctionManager.participationConfig !== null && view.participationItem) && view.vault);
    if ((!view.thumbnail || !view.thumbnail.metadata) && desiredState != AuctionViewState.Defective) return undefined;
    return view;
  }

  return undefined;
}
;// CONCATENATED MODULE: ./src/hooks/useUserArts.ts




const useUserArts = () => {
  const {
    metadata,
    masterEditions,
    editions
  } = (0,meta.useMeta)();
  const {
    accountByMint
  } = (0,lib.useUserAccounts)();
  const ownedMetadata = metadata.filter(m => {
    var _accountByMint$get, _accountByMint$get$in, _accountByMint$get$in2;

    return accountByMint.has(m.info.mint) && ((accountByMint === null || accountByMint === void 0 ? void 0 : (_accountByMint$get = accountByMint.get(m.info.mint)) === null || _accountByMint$get === void 0 ? void 0 : (_accountByMint$get$in = _accountByMint$get.info) === null || _accountByMint$get$in === void 0 ? void 0 : (_accountByMint$get$in2 = _accountByMint$get$in.amount) === null || _accountByMint$get$in2 === void 0 ? void 0 : _accountByMint$get$in2.toNumber()) || 0) > 0;
  });
  const possibleEditions = ownedMetadata.map(m => m.info.edition ? editions[m.info.edition] : undefined);
  const possibleMasterEditions = ownedMetadata.map(m => m.info.masterEdition ? masterEditions[m.info.masterEdition] : undefined);
  const safetyDeposits = [];
  let i = 0;
  ownedMetadata.forEach(m => {
    const a = accountByMint.get(m.info.mint);
    let masterA;
    const masterEdition = possibleMasterEditions[i];

    if ((masterEdition === null || masterEdition === void 0 ? void 0 : masterEdition.info.key) == lib.MetadataKey.MasterEditionV1) {
      masterA = accountByMint.get((masterEdition === null || masterEdition === void 0 ? void 0 : masterEdition.info.printingMint) || '');
    }

    let winningConfigType;

    if ((masterEdition === null || masterEdition === void 0 ? void 0 : masterEdition.info.key) == lib.MetadataKey.MasterEditionV1) {
      winningConfigType = metaplex.WinningConfigType.PrintingV1;
    } else if ((masterEdition === null || masterEdition === void 0 ? void 0 : masterEdition.info.key) == lib.MetadataKey.MasterEditionV2) {
      if (masterEdition.info.maxSupply) {
        winningConfigType = metaplex.WinningConfigType.PrintingV2;
      } else {
        winningConfigType = metaplex.WinningConfigType.Participation;
      }
    } else {
      winningConfigType = metaplex.WinningConfigType.TokenOnlyTransfer;
    }

    if (a) {
      var _masterA;

      safetyDeposits.push({
        holding: a.pubkey,
        edition: possibleEditions[i],
        masterEdition,
        metadata: m,
        printingMintHolding: (_masterA = masterA) === null || _masterA === void 0 ? void 0 : _masterA.pubkey,
        winningConfigType,
        amountRanges: [],
        participationConfig: winningConfigType == metaplex.WinningConfigType.Participation ? new metaplex.ParticipationConfigV2({
          winnerConstraint: metaplex.WinningConstraint.ParticipationPrizeGiven,
          nonWinningConstraint: metaplex.NonWinningConstraint.GivenForFixedPrice,
          fixedPrice: new (external_bn_js_default())(0)
        }) : undefined
      });
    }

    i++;
  });
  return safetyDeposits;
};
;// CONCATENATED MODULE: ./src/hooks/useAuction.ts




const useAuction = id => {
  const {
    publicKey
  } = (0,wallet_adapter_react_.useWallet)();
  const cachedRedemptionKeys = useCachedRedemptionKeysByWallet();
  const {
    0: existingAuctionView,
    1: setAuctionView
  } = (0,external_react_.useState)(undefined);
  const walletPubkey = publicKey === null || publicKey === void 0 ? void 0 : publicKey.toBase58();
  const {
    auctions,
    auctionManagersByAuction,
    safetyDepositBoxesByVaultAndIndex,
    metadataByMint,
    bidderMetadataByAuctionAndBidder,
    bidderPotsByAuctionAndBidder,
    masterEditions,
    vaults,
    safetyDepositConfigsByAuctionManagerAndIndex,
    masterEditionsByOneTimeAuthMint,
    masterEditionsByPrintingMint,
    metadataByMasterEdition,
    bidRedemptionV2sByAuctionManagerAndWinningIndex,
    auctionDataExtended,
    metadataByAuction,
    isLoading
  } = (0,meta.useMeta)();
  (0,external_react_.useEffect)(() => {
    const auction = auctions[id];

    if (!isLoading && auction) {
      const auctionView = processAccountsIntoAuctionView(walletPubkey, auction, auctionDataExtended, auctionManagersByAuction, safetyDepositBoxesByVaultAndIndex, metadataByMint, bidderMetadataByAuctionAndBidder, bidderPotsByAuctionAndBidder, bidRedemptionV2sByAuctionManagerAndWinningIndex, masterEditions, vaults, safetyDepositConfigsByAuctionManagerAndIndex, masterEditionsByPrintingMint, masterEditionsByOneTimeAuthMint, metadataByMasterEdition, cachedRedemptionKeys, metadataByAuction, undefined);
      if (auctionView) setAuctionView(auctionView);
    }
  }, [auctions, walletPubkey, auctionManagersByAuction, safetyDepositBoxesByVaultAndIndex, metadataByMint, bidderMetadataByAuctionAndBidder, bidderPotsByAuctionAndBidder, bidRedemptionV2sByAuctionManagerAndWinningIndex, vaults, safetyDepositConfigsByAuctionManagerAndIndex, masterEditions, masterEditionsByPrintingMint, masterEditionsByOneTimeAuthMint, metadataByMasterEdition, cachedRedemptionKeys, metadataByAuction, isLoading]);
  return existingAuctionView;
};
;// CONCATENATED MODULE: ./src/hooks/useBidsForAuction.ts


const useHighestBidForAuction = auctionPubkey => {
  const bids = useBidsForAuction(auctionPubkey);
  const winner = (0,external_react_.useMemo)(() => {
    return bids === null || bids === void 0 ? void 0 : bids[0];
  }, [bids]);
  return winner;
};
const useBidsForAuction = auctionPubkey => {
  const id = (0,external_react_.useMemo)(() => typeof auctionPubkey === 'string' ? auctionPubkey !== '' ? auctionPubkey : undefined : auctionPubkey, [auctionPubkey]);
  const {
    bidderMetadataByAuctionAndBidder
  } = (0,lib.useMeta)();
  const {
    0: bids,
    1: setBids
  } = (0,external_react_.useState)([]);
  (0,external_react_.useEffect)(() => {
    const dispose = lib.cache.emitter.onCache(args => {
      if (args.parser === lib.BidderMetadataParser) {
        setBids(getBids(bidderMetadataByAuctionAndBidder, id));
      }
    });
    setBids(getBids(bidderMetadataByAuctionAndBidder, id));
    return () => {
      dispose();
    };
  }, [id]);
  return bids;
};

const getBids = (bidderMetadataByAuctionAndBidder, id) => {
  // I have no idea why, but cache doesnt work with speed run and i couldnt figure it out for the life of me,
  // because that file is so confusing I have no idea how it works.
  // so we use the tempCache for pulling bids. B come save me.- J
  let bids;

  if (lib.USE_SPEED_RUN) {
    bids = Object.values(bidderMetadataByAuctionAndBidder).filter(b => b.info.auctionPubkey === id);
  } else {
    bids = lib.cache.byParser(lib.BidderMetadataParser).filter(key => {
      const bidder = lib.cache.get(key);

      if (!bidder) {
        return false;
      }

      return id === bidder.info.auctionPubkey;
    }).map(key => {
      const bidder = lib.cache.get(key);
      return bidder;
    });
  }

  return bids.sort((a, b) => {
    const lastBidDiff = b.info.lastBid.sub(a.info.lastBid).toNumber();

    if (lastBidDiff === 0) {
      return a.info.lastBidTimestamp.sub(b.info.lastBidTimestamp).toNumber();
    }

    return lastBidDiff;
  }).map(item => {
    return item;
  });
};
;// CONCATENATED MODULE: ./src/hooks/useUserBalance.ts



function useUserBalance(mintAddress, account) {
  var _useAllSplPrices$filt;

  const mint = (0,external_react_.useMemo)(() => typeof mintAddress === 'string' ? mintAddress : mintAddress, [mintAddress]);
  const {
    userAccounts
  } = (0,lib.useUserAccounts)();
  const {
    0: balanceInUSD,
    1: setBalanceInUSD
  } = (0,external_react_.useState)(0); // TODO: add option to register for different token prices without having to set them in env

  /*  console.log(
    '[--P]MINTADDRESS',
    mintAddress,
    useAllSplPrices(),
    useSolPrice(),
  ); */

  const solPrice = useSolPrice();
  const altSplPrice = (_useAllSplPrices$filt = useAllSplPrices().filter(a => a.tokenMint == mintAddress)[0]) === null || _useAllSplPrices$filt === void 0 ? void 0 : _useAllSplPrices$filt.tokenPrice;
  const tokenPrice = mintAddress == lib.WRAPPED_SOL_MINT.toBase58() ? solPrice : altSplPrice;
  const mintInfo = (0,lib.useMint)(mint);
  const accounts = (0,external_react_.useMemo)(() => {
    return userAccounts.filter(acc => mint === acc.info.mint.toBase58() && (!account || account === acc.pubkey)).sort((a, b) => b.info.amount.sub(a.info.amount).toNumber());
  }, [userAccounts, mint, account]);
  const balanceLamports = (0,external_react_.useMemo)(() => {
    return accounts.reduce( // TODO: Edge-case: If a number is too big (more than 10Mil) and the decimals
    //    for the token are > 8, the lamports.toNumber() crashes, as it is more then 53 bits.
    (res, item) => res += item.info.amount.toNumber(), 0);
  }, [accounts]);
  const balance = (0,external_react_.useMemo)(() => (0,lib.fromLamports)(balanceLamports, mintInfo), [mintInfo, balanceLamports]);
  (0,external_react_.useEffect)(() => {
    setBalanceInUSD(balance * tokenPrice);
  }, [balance, tokenPrice, mint, setBalanceInUSD]);
  return {
    balance,
    balanceLamports,
    balanceInUSD,
    accounts,
    hasBalance: accounts.length > 0 && balance > 0
  };
}
;// CONCATENATED MODULE: ./src/hooks/useCreator.ts


const useCreator = id => {
  const {
    whitelistedCreatorsByCreator
  } = (0,meta.useMeta)();
  const key = (0,lib.pubkeyToString)(id);
  const creator = Object.values(whitelistedCreatorsByCreator).find(creator => creator.info.address === key);
  return creator;
};
;// CONCATENATED MODULE: ./src/hooks/useCreatorArts.ts

const useCreatorArts = id => {
  const {
    metadata
  } = (0,meta.useMeta)();
  const filtered = metadata.filter(m => {
    var _m$info$data$creators;

    return (_m$info$data$creators = m.info.data.creators) === null || _m$info$data$creators === void 0 ? void 0 : _m$info$data$creators.some(c => c.address === id);
  });
  return filtered;
};
;// CONCATENATED MODULE: ./src/hooks/useCreators.ts


const useCreators = auction => {
  const {
    whitelistedCreatorsByCreator
  } = (0,meta.useMeta)();
  const creators = (0,external_react_.useMemo)(() => {
    var _auction$thumbnail;

    return [...([...((auction === null || auction === void 0 ? void 0 : auction.items) || []).flat().map(item => item === null || item === void 0 ? void 0 : item.metadata), auction === null || auction === void 0 ? void 0 : (_auction$thumbnail = auction.thumbnail) === null || _auction$thumbnail === void 0 ? void 0 : _auction$thumbnail.metadata].filter(item => item && item.info).map(item => (item === null || item === void 0 ? void 0 : item.info.data.creators) || []).flat() || []).filter(creator => creator.verified).reduce((agg, item) => {
      agg.set(item.address, item.share);
      return agg;
    }, new Map()).entries()].map(creatorArray => {
      const [creator, share] = creatorArray;
      const knownCreator = whitelistedCreatorsByCreator[creator];
      return {
        address: creator,
        verified: true,
        share: share,
        image: (knownCreator === null || knownCreator === void 0 ? void 0 : knownCreator.info.image) || '',
        name: (knownCreator === null || knownCreator === void 0 ? void 0 : knownCreator.info.name) || '',
        link: (knownCreator === null || knownCreator === void 0 ? void 0 : knownCreator.info.twitter) || ''
      };
    });
  }, [auction, whitelistedCreatorsByCreator]);
  return creators;
};
;// CONCATENATED MODULE: ./src/hooks/index.ts









;// CONCATENATED MODULE: ./src/components/Notifications/index.tsx
function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }



















var RunActionState;

(function (RunActionState) {
  RunActionState[RunActionState["NotRunning"] = 0] = "NotRunning";
  RunActionState[RunActionState["Running"] = 1] = "Running";
  RunActionState[RunActionState["Success"] = 2] = "Success";
  RunActionState[RunActionState["Failed"] = 3] = "Failed";
})(RunActionState || (RunActionState = {}));

function RunAction({
  id,
  action,
  onFinish,
  icon
}) {
  const {
    0: state,
    1: setRunState
  } = (0,external_react_.useState)(RunActionState.NotRunning);
  (0,external_react_.useMemo)(() => setRunState(RunActionState.NotRunning), [id]);

  const run = async () => {
    await setRunState(RunActionState.Running);
    const result = await action();

    if (result) {
      await setRunState(RunActionState.Success);
      setTimeout(() => onFinish ? onFinish() : null, 2000); // Give user a sense of completion before removal from list
    } else {
      await setRunState(RunActionState.Failed);
    }
  };

  let component;

  switch (state) {
    case RunActionState.NotRunning:
      component = /*#__PURE__*/jsx_runtime_.jsx("span", {
        className: "hover-button",
        onClick: run,
        children: icon
      });
      break;

    case RunActionState.Failed:
      component = /*#__PURE__*/jsx_runtime_.jsx("span", {
        className: "hover-button",
        onClick: run,
        children: /*#__PURE__*/jsx_runtime_.jsx(icons_.SyncOutlined, {})
      });
      break;

    case RunActionState.Running:
      component = /*#__PURE__*/jsx_runtime_.jsx(icons_.LoadingOutlined, {});
      break;

    case RunActionState.Success:
      component = /*#__PURE__*/jsx_runtime_.jsx(icons_.CheckCircleTwoTone, {
        twoToneColor: "#52c41a"
      });
  }

  return component;
}

async function getPersonalEscrowAta(wallet) {
  const PROGRAM_IDS = (0,lib.programIds)();
  if (!(wallet !== null && wallet !== void 0 && wallet.publicKey)) return;
  return (await (0,lib.findProgramAddress)([wallet.publicKey.toBuffer(), PROGRAM_IDS.token.toBuffer(), QUOTE_MINT.toBuffer()], PROGRAM_IDS.associatedToken))[0];
}
function useCollapseWrappedSol({
  connection,
  wallet,
  notifications
}) {
  const {
    0: showNotification,
    1: setShowNotification
  } = (0,external_react_.useState)(false);

  const fn = async () => {
    const ata = await getPersonalEscrowAta(wallet);

    if (ata) {
      try {
        const balance = await connection.getTokenAccountBalance((0,lib.toPublicKey)(ata));

        if (balance && balance.value.uiAmount || 0 > 0) {
          setShowNotification(true);
        } // eslint-disable-next-line no-empty

      } catch (e) {}
    }

    setTimeout(fn, 60000);
  };

  (0,external_react_.useEffect)(() => {
    fn();
  }, []);

  if (showNotification) {
    notifications.push({
      id: 'unsettled',
      title: 'Unsettled funds!',
      description: 'You have unsettled royalties in your personal escrow account.',
      action: async () => {
        try {
          const ata = await getPersonalEscrowAta(wallet);

          if (ata) {
            const data = await connection.getAccountInfo((0,lib.toPublicKey)(ata));
            if (data !== null && data !== void 0 && data.data.length || 0 > 0) await closePersonalEscrow(connection, wallet, ata);
          }
        } catch (e) {
          console.error(e);
          return false;
        }

        return true;
      }
    });
  }
}
const CALLING_MUTEX = {};
function useSettlementAuctions({
  connection,
  wallet,
  notifications
}) {
  var _wallet$publicKey;

  const {
    accountByMint
  } = (0,lib.useUserAccounts)();
  const walletPubkey = wallet === null || wallet === void 0 ? void 0 : (_wallet$publicKey = wallet.publicKey) === null || _wallet$publicKey === void 0 ? void 0 : _wallet$publicKey.toBase58();
  const {
    bidderPotsByAuctionAndBidder,
    pullAuctionPage
  } = (0,meta.useMeta)();
  const auctionsNeedingSettling = [...useAuctions(AuctionViewState.Ended), ...useAuctions(AuctionViewState.BuyNow)];
  const {
    0: validDiscoveredEndedAuctions,
    1: setValidDiscoveredEndedAuctions
  } = (0,external_react_.useState)({});
  (0,external_react_.useMemo)(() => {
    const f = async () => {
      const nextBatch = auctionsNeedingSettling.filter(a => {
        const isEndedInstantSale = a.isInstantSale && a.items.length === a.auction.info.bidState.bids.length;
        return walletPubkey && a.auctionManager.authority === walletPubkey && (a.auction.info.ended() || isEndedInstantSale);
      }).sort((a, b) => {
        var _b$auction$info$ended, _a$auction$info$ended;

        return (((_b$auction$info$ended = b.auction.info.endedAt) === null || _b$auction$info$ended === void 0 ? void 0 : _b$auction$info$ended.toNumber()) || 0) - (((_a$auction$info$ended = a.auction.info.endedAt) === null || _a$auction$info$ended === void 0 ? void 0 : _a$auction$info$ended.toNumber()) || 0);
      });

      for (let i = 0; i < nextBatch.length; i++) {
        const av = nextBatch[i];

        if (!CALLING_MUTEX[av.auctionManager.pubkey]) {
          CALLING_MUTEX[av.auctionManager.pubkey] = true;

          try {
            const balance = await connection.getTokenAccountBalance((0,lib.toPublicKey)(av.auctionManager.acceptPayment));

            if ((balance.value.uiAmount || 0) === 0 && av.auction.info.bidState.bids.map(b => b.amount.toNumber()).reduce((acc, r) => acc += r, 0) > 0 || // FIXME: Why 0.01? If this is used,
            //        no auctions with lower prices (e.g. 0.0001) appear in notifications,
            //        thus making settlement of such an auction impossible.
            //        Temporarily making the number a lesser one.
            // (balance.value.uiAmount || 0) > 0.01
            (balance.value.uiAmount || 0) > 0.00001) {
              setValidDiscoveredEndedAuctions(old => _objectSpread(_objectSpread({}, old), {}, {
                [av.auctionManager.pubkey]: balance.value.uiAmount || 0
              }));
            }
          } catch (e) {
            console.error(e);
          }
        }
      }
    };

    f();
  }, [auctionsNeedingSettling.length, walletPubkey]);
  Object.keys(validDiscoveredEndedAuctions).forEach(auctionViewKey => {
    const auctionView = auctionsNeedingSettling.find(a => a.auctionManager.pubkey === auctionViewKey);
    if (!auctionView) return;
    const winners = [...auctionView.auction.info.bidState.bids].reverse().slice(0, auctionView.auctionManager.numWinners.toNumber()).reduce((acc, r) => {
      acc[r.key] = true;
      return acc;
    }, {});
    const myPayingAccount = accountByMint.get(auctionView.auction.info.tokenMint);
    const auctionKey = auctionView.auction.pubkey;
    const bidsToClaim = Object.values(bidderPotsByAuctionAndBidder).filter(b => winners[b.info.bidderAct] && !b.info.emptied && b.info.auctionAct === auctionKey);
    if (bidsToClaim.length || validDiscoveredEndedAuctions[auctionViewKey] > 0) notifications.push({
      id: auctionViewKey,
      title: 'You have an ended auction that needs settling!',
      description: /*#__PURE__*/(0,jsx_runtime_.jsxs)("span", {
        children: ["One of your auctions ended and it has monies that can be claimed. For more detail,", ' ', /*#__PURE__*/jsx_runtime_.jsx(external_react_router_dom_.Link, {
          to: `/auction/${auctionKey}/billing`,
          children: "click here."
        })]
      }),
      action: async () => {
        try {
          // pull missing data and complete the auction view to settle.
          const {
            auctionDataExtended,
            auctionManagersByAuction,
            safetyDepositBoxesByVaultAndIndex,
            metadataByMint,
            bidderMetadataByAuctionAndBidder: updatedBidderMetadataByAuctionAndBidder,
            bidderPotsByAuctionAndBidder,
            bidRedemptionV2sByAuctionManagerAndWinningIndex,
            masterEditions,
            vaults,
            safetyDepositConfigsByAuctionManagerAndIndex,
            masterEditionsByPrintingMint,
            masterEditionsByOneTimeAuthMint,
            metadataByMasterEdition,
            metadataByAuction
          } = await pullAuctionPage(auctionView.auction.pubkey);
          const completeAuctionView = processAccountsIntoAuctionView(auctionView.auction.pubkey, auctionView.auction, auctionDataExtended, auctionManagersByAuction, safetyDepositBoxesByVaultAndIndex, metadataByMint, updatedBidderMetadataByAuctionAndBidder, bidderPotsByAuctionAndBidder, bidRedemptionV2sByAuctionManagerAndWinningIndex, masterEditions, vaults, safetyDepositConfigsByAuctionManagerAndIndex, masterEditionsByPrintingMint, masterEditionsByOneTimeAuthMint, metadataByMasterEdition, {}, metadataByAuction, undefined);

          if (completeAuctionView) {
            await settle(connection, wallet, completeAuctionView, // Just claim all bidder pots
            bidsToClaim, myPayingAccount === null || myPayingAccount === void 0 ? void 0 : myPayingAccount.pubkey, accountByMint); // accept funds (open WSOL & close WSOL) only if Auction currency SOL

            if (wallet.publicKey && auctionView.auction.info.tokenMint == lib.WRAPPED_SOL_MINT.toBase58()) {
              const ata = await getPersonalEscrowAta(wallet);
              if (ata) await closePersonalEscrow(connection, wallet, ata);
            }
          }
        } catch (e) {
          console.error(e);
          return false;
        }

        return true;
      }
    });
  });
}
function Notifications() {
  var _wallet$publicKey2;

  const {
    metadata,
    whitelistedCreatorsByCreator,
    store,
    vaults,
    safetyDepositBoxesByVaultAndIndex,
    pullAllSiteData
  } = (0,meta.useMeta)();
  const possiblyBrokenAuctionManagerSetups = useAuctions(AuctionViewState.Defective);
  const upcomingAuctions = useAuctions(AuctionViewState.Upcoming);
  const connection = (0,lib.useConnection)();
  const wallet = (0,wallet_adapter_react_.useWallet)();
  const notifications = [];
  const walletPubkey = ((_wallet$publicKey2 = wallet.publicKey) === null || _wallet$publicKey2 === void 0 ? void 0 : _wallet$publicKey2.toBase58()) || '';
  useCollapseWrappedSol({
    connection,
    wallet,
    notifications
  });
  useSettlementAuctions({
    connection,
    wallet,
    notifications
  });
  const vaultsNeedUnwinding = (0,external_react_.useMemo)(() => Object.values(vaults).filter(v => v.info.authority === walletPubkey && v.info.state !== lib.VaultState.Deactivated && v.info.tokenTypeCount > 0), [vaults, walletPubkey]);
  vaultsNeedUnwinding.forEach(v => {
    notifications.push({
      id: v.pubkey,
      title: 'You have items locked in a defective auction!',
      description: /*#__PURE__*/jsx_runtime_.jsx("span", {
        children: "During an auction creation process that probably had some issues, you lost an item. Reclaim it now."
      }),
      action: async () => {
        try {
          await unwindVault(connection, wallet, v, safetyDepositBoxesByVaultAndIndex);
        } catch (e) {
          console.error(e);
          return false;
        }

        return true;
      }
    });
  });
  notifications.push({
    id: 'none',
    title: 'Search for other auctions.',
    description: /*#__PURE__*/jsx_runtime_.jsx("span", {
      children: "Load all auctions (including defectives) by pressing here. Then you can close them."
    }),
    action: async () => {
      try {
        await pullAllSiteData();
      } catch (e) {
        console.error(e);
        return false;
      }

      return true;
    }
  });
  possiblyBrokenAuctionManagerSetups.filter(v => v.auctionManager.authority === walletPubkey).forEach(v => {
    notifications.push({
      id: v.auctionManager.pubkey,
      title: 'You have items locked in a defective auction!',
      description: /*#__PURE__*/jsx_runtime_.jsx("span", {
        children: "During an auction creation process that probably had some issues, you lost an item. Reclaim it now."
      }),
      action: async () => {
        try {
          await decommAuctionManagerAndReturnPrizes(connection, wallet, v, safetyDepositBoxesByVaultAndIndex);
        } catch (e) {
          console.error(e);
          return false;
        }

        return true;
      }
    });
  });
  const metaNeedsApproving = (0,external_react_.useMemo)(() => metadata.filter(m => {
    var _whitelistedCreatorsB, _whitelistedCreatorsB2;

    return m.info.data.creators && (((_whitelistedCreatorsB = whitelistedCreatorsByCreator[m.info.updateAuthority]) === null || _whitelistedCreatorsB === void 0 ? void 0 : (_whitelistedCreatorsB2 = _whitelistedCreatorsB.info) === null || _whitelistedCreatorsB2 === void 0 ? void 0 : _whitelistedCreatorsB2.activated) || (store === null || store === void 0 ? void 0 : store.info.public)) && m.info.data.creators.find(c => c.address === walletPubkey && !c.verified);
  }), [metadata, whitelistedCreatorsByCreator, walletPubkey]);
  metaNeedsApproving.forEach(m => {
    var _whitelistedCreatorsB3, _whitelistedCreatorsB4;

    notifications.push({
      id: m.pubkey,
      title: 'You have a new artwork to approve!',
      description: /*#__PURE__*/(0,jsx_runtime_.jsxs)("span", {
        children: [((_whitelistedCreatorsB3 = whitelistedCreatorsByCreator[m.info.updateAuthority]) === null || _whitelistedCreatorsB3 === void 0 ? void 0 : (_whitelistedCreatorsB4 = _whitelistedCreatorsB3.info) === null || _whitelistedCreatorsB4 === void 0 ? void 0 : _whitelistedCreatorsB4.name) || m.pubkey, ' ', "wants you to approve that you helped create their art", ' ', /*#__PURE__*/jsx_runtime_.jsx(external_react_router_dom_.Link, {
          to: `/art/${m.pubkey}`,
          children: "here."
        })]
      }),
      action: async () => {
        try {
          await sendSignMetadata(connection, wallet, m.pubkey);
        } catch (e) {
          console.error(e);
          return false;
        }

        return true;
      }
    });
  });
  upcomingAuctions.filter(v => v.auctionManager.authority === walletPubkey).forEach(v => {
    notifications.push({
      id: v.auctionManager.pubkey,
      title: 'You have an auction which is not started yet!',
      description: /*#__PURE__*/jsx_runtime_.jsx("span", {
        children: "You can activate it now if you wish."
      }),
      action: async () => {
        try {
          await startAuctionManually(connection, wallet, v);
        } catch (e) {
          console.error(e);
          return false;
        }

        return true;
      }
    });
  });
  const content = notifications.length ? /*#__PURE__*/jsx_runtime_.jsx("div", {
    style: {
      width: '300px',
      color: 'white'
    },
    className: 'notifications-container',
    children: /*#__PURE__*/jsx_runtime_.jsx(external_antd_.List, {
      itemLayout: "vertical",
      size: "small",
      dataSource: notifications.slice(0, 10),
      renderItem: item => /*#__PURE__*/jsx_runtime_.jsx(external_antd_.List.Item, {
        extra: /*#__PURE__*/(0,jsx_runtime_.jsxs)(jsx_runtime_.Fragment, {
          children: [/*#__PURE__*/jsx_runtime_.jsx(RunAction, {
            id: item.id,
            action: item.action,
            icon: /*#__PURE__*/jsx_runtime_.jsx(icons_.PlayCircleOutlined, {})
          }), item.dismiss && /*#__PURE__*/jsx_runtime_.jsx(RunAction, {
            id: item.id,
            action: item.dismiss,
            icon: /*#__PURE__*/jsx_runtime_.jsx(icons_.PlayCircleOutlined, {})
          })]
        }),
        children: /*#__PURE__*/jsx_runtime_.jsx(external_antd_.List.Item.Meta, {
          title: /*#__PURE__*/jsx_runtime_.jsx("span", {
            children: item.title
          }),
          description: /*#__PURE__*/jsx_runtime_.jsx("span", {
            children: /*#__PURE__*/jsx_runtime_.jsx("i", {
              children: item.description
            })
          })
        })
      })
    })
  }) : /*#__PURE__*/jsx_runtime_.jsx("span", {
    children: "No notifications"
  });

  const justContent = /*#__PURE__*/(0,jsx_runtime_.jsxs)(external_antd_.Popover, {
    placement: "bottomLeft",
    content: content,
    trigger: "click",
    children: [/*#__PURE__*/jsx_runtime_.jsx("img", {
      src: '/bell.svg',
      style: {
        cursor: 'pointer'
      }
    }), !!notifications.length && /*#__PURE__*/jsx_runtime_.jsx("div", {
      className: "mobile-notification",
      children: notifications.length - 1
    })]
  });

  if (notifications.length === 0) return justContent;else return /*#__PURE__*/jsx_runtime_.jsx(external_antd_.Badge, {
    count: notifications.length - 1,
    style: {
      backgroundColor: 'white',
      color: 'black'
    },
    children: justContent
  });
}
// EXTERNAL MODULE: external "@solana/spl-token-registry"
var spl_token_registry_ = __webpack_require__(4590);
// EXTERNAL MODULE: external "@project-serum/serum/lib/token-instructions"
var token_instructions_ = __webpack_require__(9298);
;// CONCATENATED MODULE: ./src/contexts/tokenList.tsx



 // Tag in the spl-token-registry for sollet wrapped tokens.


const SPL_REGISTRY_SOLLET_TAG = "wrapped-sollet"; // Tag in the spl-token-registry for wormhole wrapped tokens.

const SPL_REGISTRY_WORM_TAG = "wormhole";
const TokenListContext = /*#__PURE__*/external_react_default().createContext(null);
function SPLTokenListProvider({
  children = null
}) {
  const {
    0: tokenList,
    1: setTokenList
  } = (0,external_react_.useState)(null);
  const subscribedTokenMints =  true ? [token_instructions_.WRAPPED_SOL_MINT, ..."kinXdEcpDQeHPEuQnqmUgtYykqKGVFq6CeVX5iAHJq6,ETAtLmCmsoiEEKfNrHKJ2kYy3MoABhU6NQvpSfij5tDs,BLwTnYKqf7u4qjgZrrsKeNs2EzWkMLqVCu6j8iHyrNA3,ATLASXmbPQxBUYbxPsV97usA3fPQYEqzQBUHgiFCUsXx,EPjFWdd5AufqSSqeM2qN1xzybapC8G4wEGGkZwyTDt1v".split(",")] : 0;
  const {
    tokens
  } = (0,lib.useConnectionConfig)();
  (0,external_react_.useEffect)(() => {
    setTokenList(new spl_token_registry_.TokenListContainer(Array.from(tokens.values())));
  }, [setTokenList, tokens]);
  const hasOtherTokens = !!"kinXdEcpDQeHPEuQnqmUgtYykqKGVFq6CeVX5iAHJq6,ETAtLmCmsoiEEKfNrHKJ2kYy3MoABhU6NQvpSfij5tDs,BLwTnYKqf7u4qjgZrrsKeNs2EzWkMLqVCu6j8iHyrNA3,ATLASXmbPQxBUYbxPsV97usA3fPQYEqzQBUHgiFCUsXx,EPjFWdd5AufqSSqeM2qN1xzybapC8G4wEGGkZwyTDt1v"; // Added tokenList to know in which currency the auction is (SOL or other SPL)

  const subscribedTokens = tokenList ? tokenList.getList().filter(f => subscribedTokenMints.some(s => s == f.address)) : [];
  const tokenMap = (0,external_react_.useMemo)(() => {
    const tokenMap = new Map();
    subscribedTokens.forEach(t => {
      tokenMap.set(t.address, t);
    });
    return tokenMap;
  }, [tokenList]); // Tokens with USD(x) quoted markets.

  const swappableTokens = (0,external_react_.useMemo)(() => {
    const tokens = subscribedTokens.filter(t => {
      var _t$extensions, _t$extensions2;

      const isUsdxQuoted = ((_t$extensions = t.extensions) === null || _t$extensions === void 0 ? void 0 : _t$extensions.serumV3Usdt) || ((_t$extensions2 = t.extensions) === null || _t$extensions2 === void 0 ? void 0 : _t$extensions2.serumV3Usdc);
      return isUsdxQuoted;
    });
    tokens.sort((a, b) => a.symbol < b.symbol ? -1 : a.symbol > b.symbol ? 1 : 0);
    return tokens;
  }, [tokenList, tokenMap]); // Sollet wrapped tokens.

  const {
    0: swappableTokensSollet,
    1: solletMap
  } = (0,external_react_.useMemo)(() => {
    const tokens = subscribedTokens.filter(t => {
      var _t$tags;

      const isSollet = (_t$tags = t.tags) === null || _t$tags === void 0 ? void 0 : _t$tags.includes(SPL_REGISTRY_SOLLET_TAG);
      return isSollet;
    });
    tokens.sort((a, b) => a.symbol < b.symbol ? -1 : a.symbol > b.symbol ? 1 : 0);
    return [tokens, new Map(tokens.map(t => [t.address, t]))];
  }, [tokenList]); // Wormhole wrapped tokens.

  const {
    0: swappableTokensWormhole,
    1: wormholeMap
  } = (0,external_react_.useMemo)(() => {
    const tokens = subscribedTokens.filter(t => {
      var _t$tags2;

      const isSollet = (_t$tags2 = t.tags) === null || _t$tags2 === void 0 ? void 0 : _t$tags2.includes(SPL_REGISTRY_WORM_TAG);
      return isSollet;
    });
    tokens.sort((a, b) => a.symbol < b.symbol ? -1 : a.symbol > b.symbol ? 1 : 0);
    return [tokens, new Map(tokens.map(t => [t.address, t]))];
  }, [tokenList]);
  return /*#__PURE__*/jsx_runtime_.jsx(TokenListContext.Provider, {
    value: {
      subscribedTokens,
      tokenMap,
      wormholeMap,
      solletMap,
      swappableTokens,
      swappableTokensWormhole,
      swappableTokensSollet,
      hasOtherTokens
    },
    children: children
  });
}
const useTokenMap = () => {
  const {
    tokenMap
  } = useTokenList();
  return tokenMap;
};
const useSwappableTokens = () => {
  const {
    swappableTokens,
    swappableTokensWormhole,
    swappableTokensSollet
  } = useTokenList();
  return {
    swappableTokens,
    swappableTokensWormhole,
    swappableTokensSollet
  };
};
const queryTokenList = () => {
  const {
    subscribedTokens
  } = useTokenList();
  return subscribedTokens;
};
const useTokenList = () => {
  const context = (0,external_react_.useContext)(TokenListContext);
  return context;
};
;// CONCATENATED MODULE: ./src/components/Custom/index.tsx
function Custom_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

function Custom_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { Custom_ownKeys(Object(source), true).forEach(function (key) { Custom_defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { Custom_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function Custom_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }



const TokenCircle = props => {
  const {
    iconSize = 24,
    iconFile = undefined,
    style = {}
  } = props;
  const filePath = iconFile ? iconFile : "/unknown_token.png";
  return /*#__PURE__*/jsx_runtime_.jsx("span", {
    style: Custom_objectSpread({
      background: 'rgba(255, 255, 255, 0.05)',
      borderRadius: '50%',
      height: iconSize,
      width: iconSize,
      display: 'inline-flex',
      overflow: 'hidden'
    }, style),
    children: /*#__PURE__*/jsx_runtime_.jsx("img", {
      src: filePath
    })
  });
};
;// CONCATENATED MODULE: ./src/components/CurrentUserBadge/index.tsx












'@solana/wallet-adapter-base';
const btnStyle = {
  border: 'none',
  height: 40
};

const UserActions = props => {
  const {
    publicKey
  } = (0,wallet_adapter_react_.useWallet)();
  const {
    whitelistedCreatorsByCreator,
    store
  } = (0,meta.useMeta)();
  const pubkey = (publicKey === null || publicKey === void 0 ? void 0 : publicKey.toBase58()) || '';
  const canCreate = (0,external_react_.useMemo)(() => {
    var _store$info, _whitelistedCreatorsB, _whitelistedCreatorsB2;

    return (store === null || store === void 0 ? void 0 : (_store$info = store.info) === null || _store$info === void 0 ? void 0 : _store$info.public) || ((_whitelistedCreatorsB = whitelistedCreatorsByCreator[pubkey]) === null || _whitelistedCreatorsB === void 0 ? void 0 : (_whitelistedCreatorsB2 = _whitelistedCreatorsB.info) === null || _whitelistedCreatorsB2 === void 0 ? void 0 : _whitelistedCreatorsB2.activated);
  }, [pubkey, whitelistedCreatorsByCreator, store]);
  return /*#__PURE__*/jsx_runtime_.jsx(jsx_runtime_.Fragment, {
    children: store && (props.mobile ? /*#__PURE__*/(0,jsx_runtime_.jsxs)("div", {
      className: "actions-buttons actions-user",
      children: [canCreate && /*#__PURE__*/jsx_runtime_.jsx(external_react_router_dom_.Link, {
        to: `/art/create`,
        children: /*#__PURE__*/jsx_runtime_.jsx(external_antd_.Button, {
          onClick: () => {
            props.onClick ? props.onClick() : null;
          },
          className: "black-btn",
          children: "Create"
        })
      }), /*#__PURE__*/jsx_runtime_.jsx(external_react_router_dom_.Link, {
        to: `/auction/create/0`,
        children: /*#__PURE__*/jsx_runtime_.jsx(external_antd_.Button, {
          onClick: () => {
            props.onClick ? props.onClick() : null;
          },
          className: "black-btn",
          children: "Sell"
        })
      })]
    }) : /*#__PURE__*/(0,jsx_runtime_.jsxs)("div", {
      style: {
        display: 'flex'
      },
      children: [canCreate && /*#__PURE__*/(0,jsx_runtime_.jsxs)(jsx_runtime_.Fragment, {
        children: [/*#__PURE__*/jsx_runtime_.jsx(external_react_router_dom_.Link, {
          to: `/art/create`,
          style: {
            width: '100%'
          },
          children: /*#__PURE__*/jsx_runtime_.jsx(external_antd_.Button, {
            className: "metaplex-button-default",
            style: btnStyle,
            children: "Create"
          })
        }), "\xA0\xA0"]
      }), /*#__PURE__*/jsx_runtime_.jsx(external_react_router_dom_.Link, {
        to: `/auction/create/0`,
        style: {
          width: '100%'
        },
        children: /*#__PURE__*/jsx_runtime_.jsx(external_antd_.Button, {
          className: "metaplex-button-default",
          style: btnStyle,
          children: "Sell"
        })
      })]
    }))
  });
};

const AddFundsModal = props => {
  return /*#__PURE__*/jsx_runtime_.jsx(lib.MetaplexModal, {
    visible: props.showAddFundsModal,
    onCancel: () => props.setShowAddFundsModal(false),
    title: "Add Funds",
    bodyStyle: {
      alignItems: 'start'
    },
    children: /*#__PURE__*/(0,jsx_runtime_.jsxs)("div", {
      style: {
        maxWidth: '100%'
      },
      children: [/*#__PURE__*/(0,jsx_runtime_.jsxs)("p", {
        style: {
          color: 'white'
        },
        children: ["We partner with ", /*#__PURE__*/jsx_runtime_.jsx("b", {
          children: "FTX"
        }), " to make it simple to start purchasing digital collectibles."]
      }), /*#__PURE__*/(0,jsx_runtime_.jsxs)("div", {
        style: {
          width: '100%',
          background: '#242424',
          borderRadius: 12,
          marginBottom: 10,
          height: 50,
          display: 'flex',
          alignItems: 'center',
          padding: '0 10px',
          justifyContent: 'space-between',
          fontWeight: 700
        },
        children: [/*#__PURE__*/jsx_runtime_.jsx("span", {
          style: {
            color: 'rgba(255, 255, 255, 0.5)'
          },
          children: "Balance"
        }), /*#__PURE__*/(0,jsx_runtime_.jsxs)("span", {
          children: [lib.formatNumber.format(props.balance), "\xA0\xA0", /*#__PURE__*/jsx_runtime_.jsx("span", {
            style: {
              borderRadius: '50%',
              background: 'black',
              display: 'inline-block',
              padding: '1px 4px 4px 4px',
              lineHeight: 1
            },
            children: /*#__PURE__*/jsx_runtime_.jsx("img", {
              src: "/sol.svg",
              width: "10"
            })
          }), ' ', "SOL"]
        })]
      }), /*#__PURE__*/jsx_runtime_.jsx("p", {
        children: "If you have not used FTX Pay before, it may take a few moments to get set up."
      }), /*#__PURE__*/jsx_runtime_.jsx(external_antd_.Button, {
        onClick: () => props.setShowAddFundsModal(false),
        style: {
          background: '#454545',
          borderRadius: 14,
          width: '30%',
          padding: 10,
          height: 'auto'
        },
        children: "Close"
      }), /*#__PURE__*/jsx_runtime_.jsx(external_antd_.Button, {
        onClick: () => {
          var _props$publicKey;

          window.open(`https://ftx.com/pay/request?coin=SOL&address=${(_props$publicKey = props.publicKey) === null || _props$publicKey === void 0 ? void 0 : _props$publicKey.toBase58()}&tag=&wallet=sol&memoIsRequired=false`, '_blank', 'resizable,width=680,height=860');
        },
        style: {
          background: 'black',
          borderRadius: 14,
          width: '68%',
          marginLeft: '2%',
          padding: 10,
          height: 'auto',
          borderColor: 'black'
        },
        children: /*#__PURE__*/(0,jsx_runtime_.jsxs)("div", {
          style: {
            display: 'flex',
            placeContent: 'center',
            justifyContent: 'center',
            alignContent: 'center',
            alignItems: 'center',
            fontSize: 16
          },
          children: [/*#__PURE__*/jsx_runtime_.jsx("span", {
            style: {
              marginRight: 5
            },
            children: "Sign with"
          }), /*#__PURE__*/jsx_runtime_.jsx("img", {
            src: "/ftxpay.png",
            width: "80"
          })]
        })
      })]
    })
  });
};

const CurrentUserBadge = props => {
  const {
    wallet,
    publicKey,
    disconnect
  } = (0,wallet_adapter_react_.useWallet)();
  const {
    account
  } = (0,lib.useNativeAccount)();
  const solPrice = useSolPrice();
  const {
    0: showAddFundsModal,
    1: setShowAddFundsModal
  } = (0,external_react_.useState)(false);
  const tokenList = useTokenList();

  if (!wallet || !publicKey) {
    return null;
  }

  const balance = ((account === null || account === void 0 ? void 0 : account.lamports) || 0) / web3_js_.LAMPORTS_PER_SOL;
  const balanceInUSD = balance * solPrice;
  const solMintInfo = tokenList.tokenMap.get(lib.WRAPPED_SOL_MINT.toString());
  const iconStyle = {
    display: 'flex',
    width: props.iconSize,
    borderRadius: 50
  };
  let name = props.showAddress ? (0,lib.shortenAddress)(`${publicKey}`) : '';
  const unknownWallet = wallet;

  if (unknownWallet.name && !props.showAddress) {
    name = unknownWallet.name;
  }

  let image = /*#__PURE__*/jsx_runtime_.jsx(lib.Identicon, {
    address: publicKey === null || publicKey === void 0 ? void 0 : publicKey.toBase58(),
    style: iconStyle
  });

  if (unknownWallet.image) {
    image = /*#__PURE__*/jsx_runtime_.jsx("img", {
      src: unknownWallet.image,
      style: iconStyle
    });
  }

  return /*#__PURE__*/(0,jsx_runtime_.jsxs)("div", {
    className: "wallet-wrapper",
    children: [props.showBalance && /*#__PURE__*/(0,jsx_runtime_.jsxs)("span", {
      children: [lib.formatNumber.format(((account === null || account === void 0 ? void 0 : account.lamports) || 0) / web3_js_.LAMPORTS_PER_SOL), " SOL"]
    }), /*#__PURE__*/jsx_runtime_.jsx(external_antd_.Popover, {
      trigger: "click",
      placement: "bottomRight",
      content: /*#__PURE__*/jsx_runtime_.jsx(lib.Settings, {
        additionalSettings: /*#__PURE__*/(0,jsx_runtime_.jsxs)("div", {
          style: {
            width: 250
          },
          children: [/*#__PURE__*/jsx_runtime_.jsx("h5", {
            style: {
              color: 'rgba(255, 255, 255, 0.7)',
              letterSpacing: '0.02em'
            },
            children: "BALANCE"
          }), /*#__PURE__*/(0,jsx_runtime_.jsxs)("div", {
            style: {
              marginBottom: 10
            },
            children: [/*#__PURE__*/jsx_runtime_.jsx(TokenCircle, {
              iconFile: solMintInfo ? solMintInfo.logoURI : ''
            }), "\xA0", /*#__PURE__*/(0,jsx_runtime_.jsxs)("span", {
              style: {
                fontWeight: 600,
                color: '#FFFFFF'
              },
              children: [lib.formatNumber.format(balance), " SOL"]
            }), "\xA0", /*#__PURE__*/jsx_runtime_.jsx("span", {
              style: {
                color: 'rgba(255, 255, 255, 0.5)'
              },
              children: lib.formatUSD.format(balanceInUSD)
            }), "\xA0"]
          }), /*#__PURE__*/(0,jsx_runtime_.jsxs)("div", {
            style: {
              display: 'flex',
              marginBottom: 10
            },
            children: [/*#__PURE__*/jsx_runtime_.jsx(external_antd_.Button, {
              className: "metaplex-button-default",
              onClick: () => setShowAddFundsModal(true),
              style: btnStyle,
              children: "Add Funds"
            }), "\xA0\xA0", /*#__PURE__*/jsx_runtime_.jsx(external_antd_.Button, {
              className: "metaplex-button-default",
              onClick: disconnect,
              style: btnStyle,
              children: "Disconnect"
            })]
          }), /*#__PURE__*/jsx_runtime_.jsx(UserActions, {})]
        })
      }),
      children: /*#__PURE__*/(0,jsx_runtime_.jsxs)(external_antd_.Button, {
        className: "wallet-key",
        children: [image, name && /*#__PURE__*/jsx_runtime_.jsx("span", {
          style: {
            marginLeft: '0.5rem',
            fontWeight: 600
          },
          children: name
        })]
      })
    }), /*#__PURE__*/jsx_runtime_.jsx(AddFundsModal, {
      setShowAddFundsModal: setShowAddFundsModal,
      showAddFundsModal: showAddFundsModal,
      publicKey: publicKey,
      balance: balance
    })]
  });
};
const Cog = () => {
  const {
    endpoint
  } = (0,lib.useConnectionConfig)();
  const routerSearchParams = (0,lib.useQuerySearch)();
  const {
    setVisible
  } = (0,lib.useWalletModal)();
  const open = (0,external_react_.useCallback)(() => setVisible(true), [setVisible]);
  return /*#__PURE__*/jsx_runtime_.jsx("div", {
    className: "wallet-wrapper",
    children: /*#__PURE__*/jsx_runtime_.jsx(external_antd_.Popover, {
      trigger: "click",
      placement: "bottomRight",
      content: /*#__PURE__*/(0,jsx_runtime_.jsxs)("div", {
        style: {
          width: 250
        },
        children: [/*#__PURE__*/jsx_runtime_.jsx("h5", {
          style: {
            color: 'rgba(255, 255, 255, 0.7)',
            letterSpacing: '0.02em'
          },
          children: "NETWORK"
        }), /*#__PURE__*/jsx_runtime_.jsx(external_antd_.Select, {
          onSelect: network => {
            // Reload the page, forward user selection to the URL querystring.
            // The app will be re-initialized with the correct network
            // (which will also be saved to local storage for future visits)
            // for all its lifecycle.
            // Because we use react-router's HashRouter, we must append
            // the query parameters to the window location's hash & reload
            // explicitly. We cannot update the window location's search
            // property the standard way, see examples below.
            // doesn't work: https://localhost/?network=devnet#/
            // works: https://localhost/#/?network=devnet
            const windowHash = window.location.hash;
            routerSearchParams.set('network', network);
            const nextLocationHash = `${windowHash.split('?')[0]}?${routerSearchParams.toString()}`;
            window.location.hash = nextLocationHash;
            window.location.reload();
          },
          value: endpoint.name,
          bordered: false,
          style: {
            background: 'rgba(255, 255, 255, 0.05)',
            borderRadius: 8,
            width: '100%',
            marginBottom: 10
          },
          children: lib.ENDPOINTS.map(({
            name
          }) => /*#__PURE__*/jsx_runtime_.jsx(external_antd_.Select.Option, {
            value: name,
            children: name
          }, endpoint.name))
        }), /*#__PURE__*/jsx_runtime_.jsx(external_antd_.Button, {
          className: "metaplex-button-default",
          style: btnStyle,
          onClick: open,
          children: "Change wallet"
        })]
      }),
      children: /*#__PURE__*/jsx_runtime_.jsx(external_antd_.Button, {
        className: "wallet-key",
        children: /*#__PURE__*/jsx_runtime_.jsx("img", {
          src: "/cog.svg"
        })
      })
    })
  });
};
const CurrentUserBadgeMobile = props => {
  const {
    wallet,
    publicKey,
    disconnect
  } = (0,wallet_adapter_react_.useWallet)();
  const {
    account
  } = (0,lib.useNativeAccount)();
  const solPrice = useSolPrice();
  const {
    0: showAddFundsModal,
    1: setShowAddFundsModal
  } = (0,external_react_.useState)(false);

  if (!wallet || !publicKey) {
    return null;
  }

  const balance = ((account === null || account === void 0 ? void 0 : account.lamports) || 0) / web3_js_.LAMPORTS_PER_SOL;
  const balanceInUSD = balance * solPrice;
  const iconStyle = {
    display: 'flex',
    width: props.iconSize,
    borderRadius: 50
  };
  let name = props.showAddress ? (0,lib.shortenAddress)(`${publicKey}`) : '';
  const unknownWallet = wallet;

  if (unknownWallet.name && !props.showAddress) {
    name = unknownWallet.name;
  }

  let image = /*#__PURE__*/jsx_runtime_.jsx(lib.Identicon, {
    address: publicKey === null || publicKey === void 0 ? void 0 : publicKey.toBase58(),
    style: iconStyle
  });

  if (unknownWallet.image) {
    image = /*#__PURE__*/jsx_runtime_.jsx("img", {
      src: unknownWallet.image,
      style: iconStyle
    });
  }

  return /*#__PURE__*/(0,jsx_runtime_.jsxs)("div", {
    className: "current-user-mobile-badge",
    children: [/*#__PURE__*/(0,jsx_runtime_.jsxs)("div", {
      className: "mobile-badge",
      children: [image, name && /*#__PURE__*/jsx_runtime_.jsx("span", {
        style: {
          marginLeft: '0.5rem',
          fontWeight: 600
        },
        children: name
      })]
    }), /*#__PURE__*/(0,jsx_runtime_.jsxs)("div", {
      className: "balance-container",
      children: [/*#__PURE__*/jsx_runtime_.jsx("span", {
        className: "balance-title",
        children: "Balance"
      }), /*#__PURE__*/(0,jsx_runtime_.jsxs)("span", {
        children: [/*#__PURE__*/jsx_runtime_.jsx("span", {
          className: "sol-img-wrapper",
          children: /*#__PURE__*/jsx_runtime_.jsx("img", {
            src: "/sol.svg",
            width: "10"
          })
        }), ' ', lib.formatNumber.format(balance), "\xA0\xA0 SOL", ' ', /*#__PURE__*/jsx_runtime_.jsx("span", {
          style: {
            marginLeft: 5,
            fontWeight: 'normal',
            color: 'rgba(255, 255, 255, 0.5)'
          },
          children: lib.formatUSD.format(balanceInUSD)
        })]
      })]
    }), /*#__PURE__*/(0,jsx_runtime_.jsxs)("div", {
      className: "actions-buttons",
      children: [/*#__PURE__*/jsx_runtime_.jsx(external_antd_.Button, {
        className: "secondary-btn",
        onClick: () => {
          props.closeModal ? props.closeModal() : null;
          setShowAddFundsModal(true);
        },
        children: "Add Funds"
      }), "\xA0\xA0", /*#__PURE__*/jsx_runtime_.jsx(external_antd_.Button, {
        className: "black-btn",
        onClick: disconnect,
        children: "Disconnect"
      })]
    }), /*#__PURE__*/jsx_runtime_.jsx("div", {
      className: "actions-buttons",
      children: /*#__PURE__*/jsx_runtime_.jsx(UserActions, {
        mobile: true,
        onClick: () => {
          props.closeModal ? props.closeModal() : null;
        }
      })
    }), /*#__PURE__*/jsx_runtime_.jsx(AddFundsModal, {
      setShowAddFundsModal: setShowAddFundsModal,
      showAddFundsModal: showAddFundsModal,
      publicKey: publicKey,
      balance: balance
    })]
  });
};
;// CONCATENATED MODULE: ./src/components/MobileNavbar/index.tsx






const MobileNavbar = () => {
  const {
    connected
  } = (0,wallet_adapter_react_.useWallet)();
  return /*#__PURE__*/(0,jsx_runtime_.jsxs)("div", {
    id: "mobile-navbar",
    children: [/*#__PURE__*/jsx_runtime_.jsx(LogoLink, {}), /*#__PURE__*/(0,jsx_runtime_.jsxs)("div", {
      className: "mobile-menu",
      children: [connected && /*#__PURE__*/jsx_runtime_.jsx(Notifications, {}), /*#__PURE__*/jsx_runtime_.jsx(MetaplexMenu, {})]
    })]
  });
};
;// CONCATENATED MODULE: ./src/components/AppBar/index.tsx














const getDefaultLinkActions = connected => {
  return [/*#__PURE__*/jsx_runtime_.jsx(external_react_router_dom_.Link, {
    to: `/`,
    children: /*#__PURE__*/jsx_runtime_.jsx(external_antd_.Button, {
      className: "app-btn",
      children: "Explore"
    })
  }, 'explore'), /*#__PURE__*/jsx_runtime_.jsx(external_react_router_dom_.Link, {
    to: `/artworks`,
    children: /*#__PURE__*/jsx_runtime_.jsx(external_antd_.Button, {
      className: "app-btn",
      children: connected ? 'My Items' : 'Artwork'
    })
  }, 'artwork'), /*#__PURE__*/jsx_runtime_.jsx(external_react_router_dom_.Link, {
    to: `/artists`,
    children: /*#__PURE__*/jsx_runtime_.jsx(external_antd_.Button, {
      className: "app-btn",
      children: "Creators"
    })
  }, 'artists')];
};

const DefaultActions = ({
  vertical = false
}) => {
  const {
    connected
  } = (0,wallet_adapter_react_.useWallet)();
  return /*#__PURE__*/jsx_runtime_.jsx("div", {
    style: {
      display: 'flex',
      flexDirection: vertical ? 'column' : 'row'
    },
    children: getDefaultLinkActions(connected)
  });
};

const MetaplexMenu = () => {
  const {
    width
  } = useWindowDimensions();
  const {
    0: isModalVisible,
    1: setIsModalVisible
  } = (0,external_react_.useState)(false);
  const {
    connected
  } = (0,wallet_adapter_react_.useWallet)();
  if (width < 768) return /*#__PURE__*/(0,jsx_runtime_.jsxs)(jsx_runtime_.Fragment, {
    children: [/*#__PURE__*/jsx_runtime_.jsx(external_antd_.Modal, {
      title: /*#__PURE__*/jsx_runtime_.jsx("img", {
        src: '/metaplex-logo.svg',
        style: {
          width: "180px"
        }
      }),
      visible: isModalVisible,
      footer: null,
      className: 'modal-box',
      closeIcon: /*#__PURE__*/jsx_runtime_.jsx("img", {
        onClick: () => setIsModalVisible(false),
        src: '/modals/close.svg'
      }),
      children: /*#__PURE__*/(0,jsx_runtime_.jsxs)("div", {
        className: "site-card-wrapper mobile-menu-modal",
        children: [/*#__PURE__*/jsx_runtime_.jsx(external_antd_.Menu, {
          onClick: () => setIsModalVisible(false),
          children: getDefaultLinkActions(connected).map((item, idx) => /*#__PURE__*/jsx_runtime_.jsx(external_antd_.Menu.Item, {
            children: item
          }, idx))
        }), /*#__PURE__*/jsx_runtime_.jsx("div", {
          className: "actions",
          children: !connected ? /*#__PURE__*/jsx_runtime_.jsx("div", {
            className: "actions-buttons",
            children: /*#__PURE__*/jsx_runtime_.jsx(lib.ConnectButton, {
              onClick: () => setIsModalVisible(false),
              className: "secondary-btn"
            })
          }) : /*#__PURE__*/(0,jsx_runtime_.jsxs)(jsx_runtime_.Fragment, {
            children: [/*#__PURE__*/jsx_runtime_.jsx(CurrentUserBadgeMobile, {
              showBalance: false,
              showAddress: true,
              iconSize: 24,
              closeModal: () => {
                setIsModalVisible(false);
              }
            }), /*#__PURE__*/jsx_runtime_.jsx(Notifications, {}), /*#__PURE__*/jsx_runtime_.jsx(Cog, {})]
          })
        })]
      })
    }), /*#__PURE__*/jsx_runtime_.jsx(icons_.MenuOutlined, {
      onClick: () => setIsModalVisible(true),
      style: {
        fontSize: '1.4rem'
      }
    })]
  });
  return /*#__PURE__*/jsx_runtime_.jsx(DefaultActions, {});
};
const LogoLink = () => {
  return /*#__PURE__*/jsx_runtime_.jsx(external_react_router_dom_.Link, {
    to: `/`,
    children: /*#__PURE__*/jsx_runtime_.jsx("img", {
      src: '/metaplex-logo.svg'
    })
  });
};
const AppBar = () => {
  const {
    connected
  } = (0,wallet_adapter_react_.useWallet)();
  return /*#__PURE__*/(0,jsx_runtime_.jsxs)(jsx_runtime_.Fragment, {
    children: [/*#__PURE__*/jsx_runtime_.jsx(MobileNavbar, {}), /*#__PURE__*/(0,jsx_runtime_.jsxs)("div", {
      id: "desktop-navbar",
      children: [/*#__PURE__*/(0,jsx_runtime_.jsxs)("div", {
        className: "app-left",
        children: [/*#__PURE__*/jsx_runtime_.jsx(LogoLink, {}), "\xA0\xA0\xA0", /*#__PURE__*/jsx_runtime_.jsx(MetaplexMenu, {})]
      }), /*#__PURE__*/(0,jsx_runtime_.jsxs)("div", {
        className: "app-right",
        children: [!connected && /*#__PURE__*/jsx_runtime_.jsx(lib.ConnectButton, {
          style: {
            height: 48
          },
          allowWalletChange: true
        }), connected && /*#__PURE__*/(0,jsx_runtime_.jsxs)(jsx_runtime_.Fragment, {
          children: [/*#__PURE__*/jsx_runtime_.jsx(CurrentUserBadge, {
            showBalance: false,
            showAddress: true,
            iconSize: 24
          }), /*#__PURE__*/jsx_runtime_.jsx(Notifications, {}), /*#__PURE__*/jsx_runtime_.jsx(Cog, {})]
        })]
      })]
    })]
  });
};
;// CONCATENATED MODULE: ./src/components/Layout/index.tsx


 // eslint-disable-next-line @typescript-eslint/no-unused-vars




const {
  Header,
  Content
} = external_antd_.Layout;
const AppLayout = /*#__PURE__*/external_react_default().memo(function AppLayoutImpl(props) {
  return /*#__PURE__*/jsx_runtime_.jsx(jsx_runtime_.Fragment, {
    children: /*#__PURE__*/(0,jsx_runtime_.jsxs)(external_antd_.Layout, {
      id: 'main-layout',
      children: [/*#__PURE__*/jsx_runtime_.jsx("span", {
        id: 'main-bg'
      }), /*#__PURE__*/jsx_runtime_.jsx("span", {
        id: 'bg-gradient'
      }), /*#__PURE__*/jsx_runtime_.jsx("span", {
        id: 'static-header-gradient'
      }), /*#__PURE__*/jsx_runtime_.jsx("span", {
        id: 'static-end-gradient'
      }), /*#__PURE__*/jsx_runtime_.jsx(Header, {
        className: "App-Bar",
        children: /*#__PURE__*/jsx_runtime_.jsx(AppBar, {})
      }), /*#__PURE__*/jsx_runtime_.jsx(external_antd_.Layout, {
        id: 'width-layout',
        children: /*#__PURE__*/jsx_runtime_.jsx(Content, {
          style: {
            overflow: 'scroll',
            padding: '30px 48px '
          },
          children: props.children
        })
      })]
    })
  });
});
;// CONCATENATED MODULE: ./src/components/Loader/index.tsx





const LoaderProvider = ({
  children
}) => {
  const {
    isLoading
  } = (0,lib.useMeta)();
  return /*#__PURE__*/(0,jsx_runtime_.jsxs)(jsx_runtime_.Fragment, {
    children: [/*#__PURE__*/jsx_runtime_.jsx("div", {
      className: `loader-container ${isLoading ? 'active' : ''}`,
      children: /*#__PURE__*/(0,jsx_runtime_.jsxs)("div", {
        className: "loader-block",
        children: [/*#__PURE__*/jsx_runtime_.jsx("div", {
          className: "loader-title",
          children: "loading"
        }), /*#__PURE__*/jsx_runtime_.jsx(Spinner, {})]
      })
    }), children]
  });
};
const Spinner = () => {
  return /*#__PURE__*/(0,jsx_runtime_.jsxs)("div", {
    className: "spinner",
    children: [/*#__PURE__*/jsx_runtime_.jsx("span", {
      className: "line line-1"
    }), /*#__PURE__*/jsx_runtime_.jsx("span", {
      className: "line line-2"
    }), /*#__PURE__*/jsx_runtime_.jsx("span", {
      className: "line line-3"
    }), /*#__PURE__*/jsx_runtime_.jsx("span", {
      className: "line line-4"
    }), /*#__PURE__*/jsx_runtime_.jsx("span", {
      className: "line line-5"
    }), /*#__PURE__*/jsx_runtime_.jsx("span", {
      className: "line line-6"
    }), /*#__PURE__*/jsx_runtime_.jsx("span", {
      className: "line line-7"
    }), /*#__PURE__*/jsx_runtime_.jsx("span", {
      className: "line line-8"
    }), /*#__PURE__*/jsx_runtime_.jsx("span", {
      className: "line line-9"
    })]
  });
};
;// CONCATENATED MODULE: ./src/providers.tsx








const Providers = ({
  children
}) => {
  return /*#__PURE__*/jsx_runtime_.jsx(lib.ConnectionProvider, {
    children: /*#__PURE__*/jsx_runtime_.jsx(lib.WalletProvider, {
      children: /*#__PURE__*/jsx_runtime_.jsx(lib.AccountsProvider, {
        children: /*#__PURE__*/jsx_runtime_.jsx(SPLTokenListProvider, {
          children: /*#__PURE__*/jsx_runtime_.jsx(CoingeckoProvider, {
            children: /*#__PURE__*/jsx_runtime_.jsx(lib.StoreProvider, {
              ownerAddress: "7i9UEXJJEvy6gSE7DF7pEvbeA2MfrknkZiFtEmpNm14G",
              storeAddress: process.env.NEXT_PUBLIC_STORE_ADDRESS,
              children: /*#__PURE__*/jsx_runtime_.jsx(lib.MetaProvider, {
                children: /*#__PURE__*/jsx_runtime_.jsx(LoaderProvider, {
                  children: /*#__PURE__*/jsx_runtime_.jsx(ConfettiProvider, {
                    children: /*#__PURE__*/jsx_runtime_.jsx(AppLayout, {
                      children: children
                    })
                  })
                })
              })
            })
          })
        })
      })
    })
  });
};
// EXTERNAL MODULE: external "react-content-loader"
var external_react_content_loader_ = __webpack_require__(9081);
var external_react_content_loader_default = /*#__PURE__*/__webpack_require__.n(external_react_content_loader_);
;// CONCATENATED MODULE: ./src/components/MyLoader/index.tsx
function MyLoader_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

function MyLoader_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { MyLoader_ownKeys(Object(source), true).forEach(function (key) { MyLoader_defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { MyLoader_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function MyLoader_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }





const CardLoader = () => /*#__PURE__*/(0,jsx_runtime_.jsxs)((external_react_content_loader_default()), {
  speed: 2,
  width: 223,
  height: 400,
  viewBox: "0 0 250 400",
  backgroundColor: "#0c0c0c",
  foregroundColor: "#595959",
  children: [/*#__PURE__*/jsx_runtime_.jsx("rect", {
    x: "9",
    y: "0",
    rx: "14",
    ry: "14",
    width: "232",
    height: "240"
  }), /*#__PURE__*/jsx_runtime_.jsx("circle", {
    cx: "39",
    cy: "296",
    r: "15"
  }), /*#__PURE__*/jsx_runtime_.jsx("rect", {
    x: "24",
    y: "251",
    rx: "0",
    ry: "6",
    width: "123",
    height: "21"
  }), /*#__PURE__*/jsx_runtime_.jsx("rect", {
    x: "24",
    y: "322",
    rx: "6",
    ry: "6",
    width: "44",
    height: "25"
  })]
});
const ThreeDots = ({
  style
}) => /*#__PURE__*/(0,jsx_runtime_.jsxs)((external_react_content_loader_default()), {
  viewBox: "0 0 212 200",
  height: 200,
  width: 212,
  backgroundColor: "transparent",
  style: MyLoader_objectSpread({
    width: '100%',
    margin: 'auto'
  }, style),
  children: [/*#__PURE__*/jsx_runtime_.jsx("circle", {
    cx: "86",
    cy: "100",
    r: "8"
  }), /*#__PURE__*/jsx_runtime_.jsx("circle", {
    cx: "106",
    cy: "100",
    r: "8"
  }), /*#__PURE__*/jsx_runtime_.jsx("circle", {
    cx: "126",
    cy: "100",
    r: "8"
  })]
});
;// CONCATENATED MODULE: ./src/views/home/components/SalesList/hooks/useAuctionsList/utils.ts

 // Check if the auction is primary sale or not

const checkPrimarySale = auction => auction.thumbnail.metadata.info.primarySaleHappened; // Removed resales from live auctions


const liveAuctionsFilter = auction => auction.state === AuctionViewState.Live && !checkPrimarySale(auction);

const participatedAuctionsFilter = (auction, bidderPublicKey) => auction.state !== AuctionViewState.Defective && auction.auction.info.bidState.bids.some(b => b.key == (bidderPublicKey === null || bidderPublicKey === void 0 ? void 0 : bidderPublicKey.toBase58()));

const resaleAuctionsFilter = auction => auction.state === AuctionViewState.Live && checkPrimarySale(auction);

const endedAuctionsFilter = ({
  state
}) => [AuctionViewState.Ended, AuctionViewState.BuyNow].includes(state);

const ownAuctionsFilter = (auction, bidderPublicKey) => {
  return auction.state === AuctionViewState.Live && auction.auctionManager.authority === (bidderPublicKey === null || bidderPublicKey === void 0 ? void 0 : bidderPublicKey.toBase58());
};

const getFilterFunction = activeKey => {
  switch (activeKey) {
    case LiveAuctionViewState.All:
      return liveAuctionsFilter;

    case LiveAuctionViewState.Participated:
      return participatedAuctionsFilter;

    case LiveAuctionViewState.Resale:
      return resaleAuctionsFilter;
      break;

    case LiveAuctionViewState.Ended:
      return endedAuctionsFilter;

    case LiveAuctionViewState.Own:
      return ownAuctionsFilter;
  }
};
;// CONCATENATED MODULE: ./src/views/home/components/SalesList/hooks/useAuctionsList/index.ts




const useAuctionsList = activeKey => {
  const {
    publicKey
  } = (0,wallet_adapter_react_.useWallet)();
  const auctions = useAuctions();
  const filteredAuctions = (0,external_react_.useMemo)(() => {
    const filterFn = getFilterFunction(activeKey);
    return auctions.filter(auction => filterFn(auction, publicKey));
  }, [activeKey, auctions, publicKey]);
  const hasResaleAuctions = (0,external_react_.useMemo)(() => {
    return auctions.some(auction => resaleAuctionsFilter(auction));
  }, [auctions]);
  return {
    auctions: filteredAuctions,
    hasResaleAuctions
  };
};
// EXTERNAL MODULE: external "@google/model-viewer/dist/model-viewer"
var model_viewer_ = __webpack_require__(8671);
;// CONCATENATED MODULE: ./src/components/MeshViewer/index.tsx
function MeshViewer_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

function MeshViewer_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { MeshViewer_ownKeys(Object(source), true).forEach(function (key) { MeshViewer_defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { MeshViewer_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function MeshViewer_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }




function MeshViewer(props) {
  return (
    /*#__PURE__*/
    // @ts-ignore
    jsx_runtime_.jsx("model-viewer", {
      style: MeshViewer_objectSpread({
        width: `100%`,
        height: `100%`,
        minHeight: 400,
        minWidth: 400,
        maxHeight: 400
      }, props.style),
      src: props.url,
      "auto-rotate": true,
      "rotation-per-second": "40deg",
      className: props.className,
      "camera-controls": true
    })
  );
}
// EXTERNAL MODULE: external "@cloudflare/stream-react"
var stream_react_ = __webpack_require__(5599);
;// CONCATENATED MODULE: ./src/utils/utils.ts
const cleanName = name => {
  if (!name) {
    return undefined;
  }

  return name.replace(/\s+/g, '-');
};
const getLast = arr => {
  if (arr.length <= 0) {
    return undefined;
  }

  return arr[arr.length - 1];
};
// EXTERNAL MODULE: external "styled-components"
var external_styled_components_ = __webpack_require__(9914);
var external_styled_components_default = /*#__PURE__*/__webpack_require__.n(external_styled_components_);
;// CONCATENATED MODULE: ./src/components/ArtContent/index.tsx
function ArtContent_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

function ArtContent_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ArtContent_ownKeys(Object(source), true).forEach(function (key) { ArtContent_defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ArtContent_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function ArtContent_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }













const MeshArtContent = ({
  uri,
  animationUrl,
  className,
  style,
  files
}) => {
  const renderURL = files && files.length > 0 && typeof files[0] === 'string' ? files[0] : animationUrl;
  const {
    isLoading
  } = useCachedImage(renderURL || '', true);

  if (isLoading) {
    return /*#__PURE__*/jsx_runtime_.jsx(CachedImageContent, {
      uri: uri,
      className: className,
      preview: false,
      style: ArtContent_objectSpread({
        width: '100%'
      }, style)
    });
  }

  return /*#__PURE__*/jsx_runtime_.jsx(MeshViewer, {
    url: renderURL,
    className: className,
    style: style
  });
};

const CachedImageContent = ({
  uri,
  className,
  preview,
  style
}) => {
  const {
    cachedBlob
  } = useCachedImage(uri || '');
  return /*#__PURE__*/jsx_runtime_.jsx(external_antd_.Image, {
    fallback: "image-placeholder.svg",
    src: cachedBlob,
    preview: preview,
    wrapperClassName: className,
    loading: "lazy",
    wrapperStyle: ArtContent_objectSpread({}, style),
    placeholder: /*#__PURE__*/jsx_runtime_.jsx(ThreeDots, {})
  });
};

const VideoArtContent = ({
  className,
  style,
  files,
  uri,
  animationURL,
  active
}) => {
  var _filter;

  const {
    0: playerApi,
    1: setPlayerApi
  } = (0,external_react_.useState)();
  const playerRef = (0,external_react_.useCallback)(ref => {
    setPlayerApi(ref);
  }, [setPlayerApi]);
  (0,external_react_.useEffect)(() => {
    if (playerApi) {
      playerApi.currentTime = 0;
    }
  }, [active, playerApi]);
  const likelyVideo = (_filter = (files || []).filter((f, index, arr) => {
    if (typeof f !== 'string') {
      return false;
    } // TODO: filter by fileType


    // TODO: filter by fileType
    return arr.length >= 2 ? index === 1 : index === 0;
  })) === null || _filter === void 0 ? void 0 : _filter[0];
  const content = likelyVideo && likelyVideo.startsWith('https://watch.videodelivery.net/') ? /*#__PURE__*/jsx_runtime_.jsx("div", {
    className: `${className} square`,
    children: /*#__PURE__*/jsx_runtime_.jsx(stream_react_.Stream // @ts-ignore
    , {
      streamRef: e => playerRef(e),
      src: likelyVideo.replace('https://watch.videodelivery.net/', ''),
      loop: true // @ts-ignore
      ,
      height: 600 // @ts-ignore
      ,
      width: 600,
      controls: false,
      videoDimensions: {
        videoHeight: 700,
        videoWidth: 400
      },
      autoplay: true,
      muted: true
    })
  }) : /*#__PURE__*/jsx_runtime_.jsx("div", {
    className: `${className} square`,
    children: /*#__PURE__*/(0,jsx_runtime_.jsxs)("video", {
      playsInline: true,
      autoPlay: true,
      muted: true,
      controls: true,
      controlsList: "nodownload",
      style: style,
      loop: true,
      poster: uri,
      children: [likelyVideo && /*#__PURE__*/jsx_runtime_.jsx("source", {
        src: likelyVideo,
        type: "video/mp4",
        style: style
      }), animationURL && /*#__PURE__*/jsx_runtime_.jsx("source", {
        src: animationURL,
        type: "video/mp4",
        style: style
      }), files === null || files === void 0 ? void 0 : files.filter(f => typeof f !== 'string').map((f, index) => /*#__PURE__*/jsx_runtime_.jsx("source", {
        src: f.uri,
        type: f.type,
        style: style
      }, index))]
    })
  });
  return content;
};

const HTMLWrapper = (external_styled_components_default()).div`
  padding-top: 100%;
  position: relative;
  width: 100%;
`;

const HTMLContent = ({
  uri,
  animationUrl,
  className,
  preview,
  style,
  files,
  artView
}) => {
  const {
    0: loaded,
    1: setLoaded
  } = (0,external_react_.useState)(false);

  if (!artView) {
    return /*#__PURE__*/jsx_runtime_.jsx(CachedImageContent, {
      uri: uri,
      className: className,
      preview: preview,
      style: style
    });
  }

  const htmlURL = files && files.length > 0 && typeof files[0] === 'string' ? files[0] : animationUrl;
  return /*#__PURE__*/(0,jsx_runtime_.jsxs)(HTMLWrapper, {
    children: [!loaded && /*#__PURE__*/jsx_runtime_.jsx(ThreeDots, {
      style: {
        width: '100%',
        height: '100%',
        top: 0,
        left: 0,
        position: 'absolute'
      }
    }), /*#__PURE__*/jsx_runtime_.jsx("iframe", {
      allow: "accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture",
      sandbox: "allow-scripts",
      frameBorder: "0",
      src: htmlURL,
      className: `html-iframe ${className}`,
      onLoad: () => {
        setLoaded(true);
      },
      style: ArtContent_objectSpread(ArtContent_objectSpread({}, style), {}, {
        height: !loaded ? 0 : '100%'
      })
    })]
  });
};

const ArtContentWrapper = (external_styled_components_default()).div`
  display: flex;
  alignItems: center;
  justifyContent: center;
  height: 100%;
`;
const ArtContent = ({
  category,
  className,
  preview,
  style,
  active,
  allowMeshRender,
  pubkey,
  uri,
  animationURL,
  files,
  artView
}) => {
  const {
    0: uriState,
    1: setUriState
  } = (0,external_react_.useState)();
  const {
    0: animationURLState,
    1: setAnimationURLState
  } = (0,external_react_.useState)();
  const {
    0: filesState,
    1: setFilesState
  } = (0,external_react_.useState)();
  const {
    0: categoryState,
    1: setCategoryState
  } = (0,external_react_.useState)();
  const id = (0,lib.pubkeyToString)(pubkey);
  const {
    ref,
    data
  } = useExtendedArt(id);
  (0,external_react_.useEffect)(() => {
    setUriState(uri);
  }, [uri]);
  (0,external_react_.useEffect)(() => {
    setAnimationURLState(animationURL);
  }, [animationURL]);
  (0,external_react_.useEffect)(() => {
    setFilesState(files);
  }, [files]);
  (0,external_react_.useEffect)(() => {
    setCategoryState(category);
  }, [category]);
  (0,external_react_.useEffect)(() => {
    if (pubkey && data) {
      setUriState(data.image);
      setAnimationURLState(data.animation_url);
    }

    if (pubkey && data !== null && data !== void 0 && data.properties) {
      setFilesState(data.properties.files);
      setCategoryState(data.properties.category);
    }
  }, [pubkey, data]);
  const animationUrlExt = new URLSearchParams(getLast((animationURLState || '').split('?'))).get('ext');

  if (allowMeshRender && (categoryState === 'vr' || animationUrlExt === 'glb' || animationUrlExt === 'gltf')) {
    return /*#__PURE__*/jsx_runtime_.jsx(MeshArtContent, {
      uri: uriState,
      animationUrl: animationURLState,
      className: className,
      style: style,
      files: filesState
    });
  }

  if (categoryState === 'html' || animationUrlExt === 'html') {
    return /*#__PURE__*/jsx_runtime_.jsx(HTMLContent, {
      uri: uriState,
      animationUrl: animationURLState,
      className: className,
      preview: preview,
      style: style,
      files: filesState,
      artView: artView
    });
  }

  const content = categoryState === 'video' ? /*#__PURE__*/jsx_runtime_.jsx(VideoArtContent, {
    className: className,
    style: style,
    files: filesState,
    uri: uriState,
    animationURL: animationURLState,
    active: active
  }) : /*#__PURE__*/jsx_runtime_.jsx(CachedImageContent, {
    uri: uriState,
    className: className,
    preview: preview,
    style: style
  });
  return /*#__PURE__*/jsx_runtime_.jsx(ArtContentWrapper, {
    ref: ref,
    children: content
  });
};
;// CONCATENATED MODULE: ./src/components/AmountLabel/index.tsx
function AmountLabel_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

function AmountLabel_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { AmountLabel_ownKeys(Object(source), true).forEach(function (key) { AmountLabel_defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { AmountLabel_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function AmountLabel_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }








const AmountLabel = props => {
  var _useAllSplPrices$filt;

  const {
    amount: _amount,
    displayUSD = true,
    displaySymbol = '',
    title = '',
    style = {},
    containerStyle = {},
    iconSize = 38,
    customPrefix,
    ended,
    tokenInfo
  } = props; // Add formattedAmount to be able to parse USD value and retain abbreviation of value

  const amount = typeof _amount === 'string' ? parseFloat(_amount) : _amount;
  let formattedAmount = `${amount}`;

  if (amount >= 1) {
    formattedAmount = (0,lib.formatAmount)(amount);
  }

  const solPrice = useSolPrice();
  const altSplPrice = (_useAllSplPrices$filt = useAllSplPrices().filter(a => a.tokenMint == (tokenInfo === null || tokenInfo === void 0 ? void 0 : tokenInfo.address))[0]) === null || _useAllSplPrices$filt === void 0 ? void 0 : _useAllSplPrices$filt.tokenPrice;
  const tokenPrice = (tokenInfo === null || tokenInfo === void 0 ? void 0 : tokenInfo.address) == lib.WRAPPED_SOL_MINT.toBase58() ? solPrice : altSplPrice;
  const {
    0: priceUSD,
    1: setPriceUSD
  } = (0,external_react_.useState)(undefined);
  (0,external_react_.useEffect)(() => {
    setPriceUSD(tokenPrice * amount);
  }, [amount, tokenPrice, altSplPrice]);
  const PriceNaN = isNaN(amount);
  return /*#__PURE__*/(0,jsx_runtime_.jsxs)("div", {
    style: AmountLabel_objectSpread({
      display: 'flex'
    }, containerStyle),
    children: [PriceNaN === false && /*#__PURE__*/jsx_runtime_.jsx(external_antd_.Statistic, {
      style: style,
      className: "create-statistic",
      title: title || '',
      value: `${formattedAmount} ${displaySymbol || ''}`,
      prefix: customPrefix || /*#__PURE__*/jsx_runtime_.jsx(TokenCircle, {
        iconSize: iconSize,
        iconFile: (tokenInfo === null || tokenInfo === void 0 ? void 0 : tokenInfo.logoURI) == "" ? undefined : tokenInfo === null || tokenInfo === void 0 ? void 0 : tokenInfo.logoURI
      })
    }), displayUSD && /*#__PURE__*/jsx_runtime_.jsx("div", {
      className: "usd",
      children: PriceNaN === false ? priceUSD ? lib.formatUSD.format(priceUSD) : "$N/A" : /*#__PURE__*/jsx_runtime_.jsx("div", {
        className: "placebid",
        children: ended ? 'N/A' : 'Place Bid'
      })
    })]
  });
};
;// CONCATENATED MODULE: ./src/components/MetaAvatar/index.tsx






const MetaAvatarItem = props => {
  const {
    creator,
    size,
    alt
  } = props;
  const {
    0: noImage,
    1: setNoImage
  } = (0,external_react_.useState)(false);
  const image = creator.image || '';
  return /*#__PURE__*/jsx_runtime_.jsx(external_antd_.Avatar, {
    alt: alt,
    size: size,
    src: noImage ? /*#__PURE__*/jsx_runtime_.jsx(lib.Identicon, {
      alt: alt,
      address: creator.address,
      style: {
        width: size
      }
    }) : image,
    onError: () => {
      setNoImage(true);
      return false;
    }
  });
};

const MetaAvatar = props => {
  const {
    creators,
    showMultiple
  } = props;
  const size = props.size || 32;

  if (!creators || creators.length === 0) {
    return /*#__PURE__*/jsx_runtime_.jsx(external_antd_.Avatar, {
      size: size,
      src: false
    });
  }

  const controls = (creators || []).map((creator, ii) => /*#__PURE__*/jsx_runtime_.jsx(MetaAvatarItem, {
    creator: creator,
    alt: creator.name,
    size: size
  }, ii));

  if (!showMultiple) {
    return controls[0];
  }

  return /*#__PURE__*/jsx_runtime_.jsx(external_antd_.Avatar.Group, {
    children: controls || null
  });
};
const MetaAvatarDetailed = props => {
  const {
    creators
  } = props;
  const size = props.size || 32;

  if (!creators || creators.length === 0) {
    return /*#__PURE__*/jsx_runtime_.jsx(external_antd_.Avatar, {
      size: size,
      src: false
    });
  }

  return /*#__PURE__*/jsx_runtime_.jsx("div", {
    children: (creators || []).map((creator, _idx) => /*#__PURE__*/(0,jsx_runtime_.jsxs)("div", {
      style: {
        display: 'flex'
      },
      children: [/*#__PURE__*/jsx_runtime_.jsx(MetaAvatarItem, {
        creator: creator,
        alt: creator.name,
        size: size
      }), /*#__PURE__*/jsx_runtime_.jsx("p", {
        style: {
          marginLeft: 10
        },
        children: creator.name ? creator.name : 'No name provided.'
      })]
    }, _idx))
  });
};
;// CONCATENATED MODULE: ./src/hooks/useAuctionCountdown.ts

const useAuctionCountdown = auctionView => {
  const {
    0: state,
    1: setState
  } = (0,external_react_.useState)();
  const auction = auctionView.auction.info;
  (0,external_react_.useEffect)(() => {
    const calc = () => {
      const newState = auction.timeToEnd();
      setState(newState);
    };

    const interval = setInterval(() => {
      calc();
    }, 1000);
    calc();
    return () => clearInterval(interval);
  }, [auction]);
  return state;
};
;// CONCATENATED MODULE: ./src/components/AuctionNumbers/index.tsx










const AuctionCountdown = props => {
  const {
    auctionView
  } = props;
  const state = useAuctionCountdown(auctionView);
  const ended = isEnded(state);

  if (!props.labels) {
    return /*#__PURE__*/jsx_runtime_.jsx(Countdown, {
      state: state
    });
  }

  return /*#__PURE__*/jsx_runtime_.jsx(external_antd_.Col, {
    span: ended ? 24 : 10,
    children: /*#__PURE__*/jsx_runtime_.jsx(LabeledCountdown, {
      state: state
    })
  });
};
const AuctionNumbers = props => {
  var _auctionView$auctionM, _auctionView$auction$;

  const {
    auctionView
  } = props;
  const state = useAuctionCountdown(auctionView);
  const bids = useBidsForAuction(auctionView.auction.pubkey);
  const mintInfo = (0,lib.useMint)(auctionView.auction.info.tokenMint);
  const participationFixedPrice = ((_auctionView$auctionM = auctionView.auctionManager.participationConfig) === null || _auctionView$auctionM === void 0 ? void 0 : _auctionView$auctionM.fixedPrice) || 0;
  const participationOnly = auctionView.auctionManager.numWinners.toNumber() === 0;
  const priceFloor = auctionView.auction.info.priceFloor.type === lib.PriceFloorType.Minimum ? ((_auctionView$auction$ = auctionView.auction.info.priceFloor.minPrice) === null || _auctionView$auction$ === void 0 ? void 0 : _auctionView$auction$.toNumber()) || 0 : 0;
  const isUpcoming = auctionView.state === AuctionViewState.Upcoming;
  const isStarted = auctionView.state === AuctionViewState.Live;
  const tokenInfo = useTokenList().subscribedTokens.filter(m => m.address == auctionView.auction.info.tokenMint)[0];
  const ended = isEnded(state);
  return /*#__PURE__*/(0,jsx_runtime_.jsxs)("div", {
    style: {
      maxWidth: 350
    },
    children: [(!ended || auctionView.isInstantSale) && /*#__PURE__*/(0,jsx_runtime_.jsxs)(jsx_runtime_.Fragment, {
      children: [(isUpcoming || bids.length === 0 || auctionView.isInstantSale) && /*#__PURE__*/jsx_runtime_.jsx(AmountLabel, {
        displaySymbol: (tokenInfo === null || tokenInfo === void 0 ? void 0 : tokenInfo.symbol) || "CUSTOM",
        style: {
          marginBottom: props.showAsRow ? 0 : 10
        },
        title: auctionView.isInstantSale ? 'Price' : 'Starting bid',
        tokenInfo: tokenInfo,
        amount: (0,lib.fromLamports)(participationOnly ? participationFixedPrice : priceFloor, mintInfo)
      }), !auctionView.isInstantSale && isStarted && bids.length > 0 && /*#__PURE__*/jsx_runtime_.jsx(AmountLabel, {
        displaySymbol: (tokenInfo === null || tokenInfo === void 0 ? void 0 : tokenInfo.symbol) || "CUSTOM",
        style: {
          marginBottom: props.showAsRow ? 0 : 10
        },
        containerStyle: {
          flexDirection: props.showAsRow ? ' row' : 'column'
        },
        title: "Highest bid",
        tokenInfo: tokenInfo,
        amount: (0,lib.formatTokenAmount)(bids[0].info.lastBid, mintInfo)
      })]
    }), !ended && !props.hideCountdown ? /*#__PURE__*/jsx_runtime_.jsx(AuctionCountdown, {
      auctionView: auctionView,
      labels: true
    }) : null]
  });
};

const isEnded = state => (state === null || state === void 0 ? void 0 : state.days) === 0 && (state === null || state === void 0 ? void 0 : state.hours) === 0 && (state === null || state === void 0 ? void 0 : state.minutes) === 0 && (state === null || state === void 0 ? void 0 : state.seconds) === 0;

const Countdown = ({
  state
}) => {
  let localState = state;

  if (!localState) {
    localState = {
      days: 0,
      hours: 0,
      minutes: 0,
      seconds: 0
    };
  }

  return /*#__PURE__*/(0,jsx_runtime_.jsxs)(external_antd_.Row, {
    style: {
      width: '100%',
      flexWrap: 'nowrap'
    },
    className: 'no-label-cd',
    children: [localState.days > 0 && /*#__PURE__*/jsx_runtime_.jsx(external_antd_.Col, {
      children: /*#__PURE__*/(0,jsx_runtime_.jsxs)("div", {
        className: "cd-number",
        children: [localState.days, /*#__PURE__*/jsx_runtime_.jsx("span", {
          style: {
            opacity: 0.5
          },
          children: "days"
        })]
      })
    }), /*#__PURE__*/jsx_runtime_.jsx(external_antd_.Col, {
      children: /*#__PURE__*/(0,jsx_runtime_.jsxs)("div", {
        className: "cd-number",
        children: [localState.hours, /*#__PURE__*/jsx_runtime_.jsx("span", {
          style: {
            opacity: 0.5
          },
          children: "hours"
        })]
      })
    }), /*#__PURE__*/jsx_runtime_.jsx(external_antd_.Col, {
      children: /*#__PURE__*/(0,jsx_runtime_.jsxs)("div", {
        className: "cd-number",
        children: [localState.minutes, /*#__PURE__*/jsx_runtime_.jsx("span", {
          style: {
            opacity: 0.5
          },
          children: "min"
        })]
      })
    }), !localState.days && /*#__PURE__*/jsx_runtime_.jsx(external_antd_.Col, {
      children: /*#__PURE__*/(0,jsx_runtime_.jsxs)("div", {
        className: "cd-number",
        children: [localState.seconds, /*#__PURE__*/jsx_runtime_.jsx("span", {
          style: {
            opacity: 0.5
          },
          children: "sec"
        })]
      })
    })]
  });
};

const LabeledCountdown = ({
  state
}) => {
  return /*#__PURE__*/jsx_runtime_.jsx(jsx_runtime_.Fragment, {
    children: /*#__PURE__*/jsx_runtime_.jsx("div", {
      style: {
        width: '100%'
      },
      children: /*#__PURE__*/(0,jsx_runtime_.jsxs)(jsx_runtime_.Fragment, {
        children: [/*#__PURE__*/jsx_runtime_.jsx("div", {
          className: "info-header",
          style: {
            margin: '12px 0',
            fontSize: 18
          },
          children: "Time left"
        }), state && (isEnded(state) ? /*#__PURE__*/jsx_runtime_.jsx(external_antd_.Row, {
          style: {
            width: '100%'
          },
          children: /*#__PURE__*/jsx_runtime_.jsx("div", {
            className: "cd-number",
            children: "This auction has ended"
          })
        }) : /*#__PURE__*/(0,jsx_runtime_.jsxs)(external_antd_.Row, {
          style: {
            width: '100%',
            flexWrap: 'nowrap'
          },
          children: [state && state.days > 0 && /*#__PURE__*/(0,jsx_runtime_.jsxs)(external_antd_.Col, {
            children: [/*#__PURE__*/(0,jsx_runtime_.jsxs)("div", {
              className: "cd-number",
              children: [state.days, /*#__PURE__*/jsx_runtime_.jsx("span", {
                style: {
                  opacity: 0.5
                },
                children: ":"
              })]
            }), /*#__PURE__*/jsx_runtime_.jsx("div", {
              className: "cd-label",
              children: "days"
            })]
          }), /*#__PURE__*/(0,jsx_runtime_.jsxs)(external_antd_.Col, {
            children: [/*#__PURE__*/(0,jsx_runtime_.jsxs)("div", {
              className: "cd-number",
              children: [state.hours, /*#__PURE__*/jsx_runtime_.jsx("span", {
                style: {
                  opacity: 0.5
                },
                children: ":"
              })]
            }), /*#__PURE__*/jsx_runtime_.jsx("div", {
              className: "cd-label",
              children: "hour"
            })]
          }), /*#__PURE__*/(0,jsx_runtime_.jsxs)(external_antd_.Col, {
            children: [/*#__PURE__*/(0,jsx_runtime_.jsxs)("div", {
              className: "cd-number",
              children: [state.minutes, state.days === 0 && /*#__PURE__*/jsx_runtime_.jsx("span", {
                style: {
                  opacity: 0.5
                },
                children: ":"
              })]
            }), /*#__PURE__*/jsx_runtime_.jsx("div", {
              className: "cd-label",
              children: "mins"
            })]
          }), !state.days && /*#__PURE__*/(0,jsx_runtime_.jsxs)(external_antd_.Col, {
            children: [/*#__PURE__*/jsx_runtime_.jsx("div", {
              className: "cd-number",
              children: state.seconds
            }), /*#__PURE__*/jsx_runtime_.jsx("div", {
              className: "cd-label",
              children: "secs"
            })]
          })]
        }))]
      })
    })
  });
};
;// CONCATENATED MODULE: ./src/components/AuctionRenderCard/hooks/useAuctionStatus.ts



const useAuctionStatus = auctionView => {
  var _auctionView$auctionM, _auctionView$auction$;

  const bids = useBidsForAuction(auctionView.auction.pubkey);
  const winningBid = useHighestBidForAuction(auctionView.auction.pubkey);
  const mintInfo = (0,lib.useMint)(auctionView.auction.info.tokenMint);
  const participationFixedPrice = ((_auctionView$auctionM = auctionView.auctionManager.participationConfig) === null || _auctionView$auctionM === void 0 ? void 0 : _auctionView$auctionM.fixedPrice) || 0;
  const participationOnly = auctionView.auctionManager.numWinners.eq(new external_bn_js_.BN(0));
  const priceFloor = auctionView.auction.info.priceFloor.type === lib.PriceFloorType.Minimum ? ((_auctionView$auction$ = auctionView.auction.info.priceFloor.minPrice) === null || _auctionView$auction$ === void 0 ? void 0 : _auctionView$auction$.toNumber()) || 0 : 0;
  let status = 'Starting Bid';
  let amount = (0,lib.fromLamports)(participationOnly ? participationFixedPrice : priceFloor, mintInfo);
  const countdown = auctionView.auction.info.timeToEnd();
  const isOpen = auctionView.auction.info.bidState.type === lib.BidStateType.OpenEdition;

  if (isOpen) {
    status = 'Open Sale';
  }

  const ended = (countdown === null || countdown === void 0 ? void 0 : countdown.hours) === 0 && (countdown === null || countdown === void 0 ? void 0 : countdown.minutes) === 0 && (countdown === null || countdown === void 0 ? void 0 : countdown.seconds) === 0 && auctionView.auction.info.state === lib.AuctionState.Ended;

  if (auctionView.isInstantSale) {
    var _auctionView$auctionD, _auctionView$auctionD2;

    const soldOut = bids.length === auctionView.items.length;
    status = auctionView.state === AuctionViewState.Ended ? 'Ended' : 'Price';

    if (soldOut && !isOpen) {
      status = 'Sold Out';
    }

    amount = (0,lib.formatTokenAmount)((_auctionView$auctionD = auctionView.auctionDataExtended) === null || _auctionView$auctionD === void 0 ? void 0 : (_auctionView$auctionD2 = _auctionView$auctionD.info.instantSalePrice) === null || _auctionView$auctionD2 === void 0 ? void 0 : _auctionView$auctionD2.toNumber(), mintInfo);
    return {
      status,
      amount
    };
  }

  if (bids.length > 0 && !isOpen) {
    amount = (0,lib.formatTokenAmount)(winningBid.info.lastBid);
    status = 'Current Bid';
  }

  if (ended) {
    if (bids.length === 0) {
      return {
        status: 'Ended',
        amount
      };
    }

    return {
      status: 'Winning Bid',
      amount
    };
  }

  return {
    status,
    amount
  };
};
;// CONCATENATED MODULE: ./src/components/AuctionRenderCard/index.tsx











const AuctionRenderCard = props => {
  var _creators$, _creators$2, _creators$2$address;

  const {
    auctionView
  } = props;
  const id = auctionView.thumbnail.metadata.pubkey;
  const art = useArt(id);
  const creators = useCreators(auctionView);
  const name = (art === null || art === void 0 ? void 0 : art.title) || ' ';
  const tokenInfo = useTokenList().subscribedTokens.filter(m => m.address == auctionView.auction.info.tokenMint)[0];
  const {
    status,
    amount
  } = useAuctionStatus(auctionView);

  const card = /*#__PURE__*/(0,jsx_runtime_.jsxs)(external_antd_.Card, {
    hoverable: true,
    className: `auction-render-card`,
    bordered: false,
    children: [/*#__PURE__*/jsx_runtime_.jsx("div", {
      className: 'card-art-info',
      children: /*#__PURE__*/(0,jsx_runtime_.jsxs)("div", {
        className: "auction-gray-wrapper",
        children: [/*#__PURE__*/(0,jsx_runtime_.jsxs)("div", {
          className: 'card-artist-info',
          children: [/*#__PURE__*/jsx_runtime_.jsx(MetaAvatar, {
            creators: creators.length ? [creators[0]] : undefined
          }), /*#__PURE__*/(0,jsx_runtime_.jsxs)("span", {
            className: 'artist-name',
            children: [((_creators$ = creators[0]) === null || _creators$ === void 0 ? void 0 : _creators$.name) || ((_creators$2 = creators[0]) === null || _creators$2 === void 0 ? void 0 : (_creators$2$address = _creators$2.address) === null || _creators$2$address === void 0 ? void 0 : _creators$2$address.substr(0, 6)) || 'Go to auction', "..."]
          })]
        }), /*#__PURE__*/jsx_runtime_.jsx("div", {
          className: 'art-content-wrapper',
          children: /*#__PURE__*/jsx_runtime_.jsx(ArtContent, {
            className: "auction-image no-events",
            preview: false,
            pubkey: id,
            allowMeshRender: false
          })
        }), /*#__PURE__*/jsx_runtime_.jsx("div", {
          className: 'art-name',
          children: name
        }), /*#__PURE__*/(0,jsx_runtime_.jsxs)("div", {
          className: "auction-info-container",
          children: [/*#__PURE__*/jsx_runtime_.jsx("div", {
            className: 'info-message',
            children: "ENDING IN"
          }), /*#__PURE__*/jsx_runtime_.jsx(AuctionCountdown, {
            auctionView: auctionView,
            labels: false
          })]
        })]
      })
    }), /*#__PURE__*/(0,jsx_runtime_.jsxs)("div", {
      className: "card-bid-info",
      children: [/*#__PURE__*/jsx_runtime_.jsx("span", {
        className: 'text-uppercase info-message',
        children: status
      }), /*#__PURE__*/jsx_runtime_.jsx(AmountLabel, {
        containerStyle: {
          flexDirection: 'row'
        },
        title: status,
        amount: amount,
        iconSize: 24,
        tokenInfo: tokenInfo
      })]
    })]
  });

  return card;
};
;// CONCATENATED MODULE: ./src/views/home/components/SalesList/index.tsx











const {
  TabPane
} = external_antd_.Tabs;
const {
  Content: SalesList_Content
} = external_antd_.Layout;
let LiveAuctionViewState;

(function (LiveAuctionViewState) {
  LiveAuctionViewState["All"] = "0";
  LiveAuctionViewState["Participated"] = "1";
  LiveAuctionViewState["Ended"] = "2";
  LiveAuctionViewState["Resale"] = "3";
  LiveAuctionViewState["Own"] = "4";
})(LiveAuctionViewState || (LiveAuctionViewState = {}));

const SalesListView = () => {
  const {
    0: activeKey,
    1: setActiveKey
  } = (0,external_react_.useState)(LiveAuctionViewState.All);
  const {
    isLoading
  } = (0,meta.useMeta)();
  const {
    connected
  } = (0,wallet_adapter_react_.useWallet)();
  const {
    auctions,
    hasResaleAuctions
  } = useAuctionsList(activeKey);
  return /*#__PURE__*/jsx_runtime_.jsx(jsx_runtime_.Fragment, {
    children: /*#__PURE__*/jsx_runtime_.jsx(external_antd_.Layout, {
      children: /*#__PURE__*/jsx_runtime_.jsx(SalesList_Content, {
        style: {
          display: 'flex',
          flexWrap: 'wrap'
        },
        children: /*#__PURE__*/(0,jsx_runtime_.jsxs)(external_antd_.Col, {
          style: {
            width: '100%',
            marginTop: 32
          },
          children: [/*#__PURE__*/jsx_runtime_.jsx(external_antd_.Row, {
            children: /*#__PURE__*/(0,jsx_runtime_.jsxs)(external_antd_.Tabs, {
              activeKey: activeKey,
              onTabClick: key => setActiveKey(key),
              children: [/*#__PURE__*/jsx_runtime_.jsx(TabPane, {
                tab: /*#__PURE__*/(0,jsx_runtime_.jsxs)(jsx_runtime_.Fragment, {
                  children: [/*#__PURE__*/jsx_runtime_.jsx("span", {
                    className: "live"
                  }), " Live"]
                })
              }, LiveAuctionViewState.All), hasResaleAuctions && /*#__PURE__*/jsx_runtime_.jsx(TabPane, {
                tab: "Secondary Marketplace"
              }, LiveAuctionViewState.Resale), /*#__PURE__*/jsx_runtime_.jsx(TabPane, {
                tab: "Ended"
              }, LiveAuctionViewState.Ended), connected && /*#__PURE__*/jsx_runtime_.jsx(TabPane, {
                tab: "Participated"
              }, LiveAuctionViewState.Participated), connected && /*#__PURE__*/jsx_runtime_.jsx(TabPane, {
                tab: "My Live Auctions"
              }, LiveAuctionViewState.Own)]
            })
          }), /*#__PURE__*/jsx_runtime_.jsx(external_antd_.Row, {
            children: /*#__PURE__*/(0,jsx_runtime_.jsxs)("div", {
              className: "artwork-grid",
              children: [isLoading && [...Array(10)].map((_, idx) => /*#__PURE__*/jsx_runtime_.jsx(CardLoader, {}, idx)), !isLoading && auctions.map(auction => /*#__PURE__*/jsx_runtime_.jsx(external_react_router_dom_.Link, {
                to: `/auction/${auction.auction.pubkey}`,
                children: /*#__PURE__*/jsx_runtime_.jsx(AuctionRenderCard, {
                  auctionView: auction
                })
              }, auction.auction.pubkey))]
            })
          })]
        })
      })
    })
  });
};
// EXTERNAL MODULE: ../common/dist/lib/models/metaplex/setStore.js
var setStore = __webpack_require__(712);
// EXTERNAL MODULE: ../common/dist/lib/models/metaplex/setWhitelistedCreator.js
var setWhitelistedCreator = __webpack_require__(8042);
;// CONCATENATED MODULE: ./src/actions/saveAdmin.ts



 // TODO if this becomes very slow move to batching txns like we do with settle.ts
// but given how little this should be used keep it simple

async function saveAdmin(connection, wallet, isPublic, whitelistedCreators) {
  if (!wallet.publicKey) throw new wallet_adapter_base_.WalletNotConnectedError();
  const signers = [];
  const instructions = [];
  const storeSigners = [];
  const storeInstructions = [];
  await (0,setStore/* setStore */.P)(isPublic, wallet.publicKey.toBase58(), wallet.publicKey.toBase58(), storeInstructions);
  signers.push(storeSigners);
  instructions.push(storeInstructions);

  for (let i = 0; i < whitelistedCreators.length; i++) {
    const wc = whitelistedCreators[i];
    const wcSigners = [];
    const wcInstructions = [];
    await (0,setWhitelistedCreator/* setWhitelistedCreator */.K)(wc.address, wc.activated, wallet.publicKey.toBase58(), wallet.publicKey.toBase58(), wcInstructions);
    signers.push(wcSigners);
    instructions.push(wcInstructions);
  }

  instructions.length === 1 ? await (0,lib.sendTransactionWithRetry)(connection, wallet, instructions[0], signers[0], 'single') : await (0,lib.sendTransactions)(connection, wallet, instructions, signers, lib.SequenceType.StopOnFailure, 'single');
}
;// CONCATENATED MODULE: ./src/components/SetupVariables/index.tsx





const SetupVariables = ({
  storeAddress,
  storeOwnerAddress
}) => {
  const ref = (0,external_react_.useRef)(null);
  const copySettings = (0,external_react_.useCallback)(() => {
    var _ref$current;

    const text = (_ref$current = ref.current) === null || _ref$current === void 0 ? void 0 : _ref$current.innerText;

    if (text) {
      navigator.clipboard.writeText(text);
    }
  }, []);

  if (!storeAddress && !storeOwnerAddress) {
    return null;
  }

  return /*#__PURE__*/jsx_runtime_.jsx(external_antd_.Card, {
    title: "Store configuration",
    extra: /*#__PURE__*/jsx_runtime_.jsx(external_antd_.Button, {
      type: "dashed",
      onClick: copySettings,
      icon: /*#__PURE__*/jsx_runtime_.jsx(icons_.CopyOutlined, {})
    }),
    children: /*#__PURE__*/jsx_runtime_.jsx("div", {
      ref: ref,
      children: storeOwnerAddress && /*#__PURE__*/(0,jsx_runtime_.jsxs)("p", {
        children: ["REACT_APP_STORE_OWNER_ADDRESS_ADDRESS=", storeOwnerAddress]
      })
    })
  });
};
;// CONCATENATED MODULE: ./src/views/home/setup.tsx











const SetupView = () => {
  var _wallet$publicKey;

  const {
    0: isInitalizingStore,
    1: setIsInitalizingStore
  } = (0,external_react_.useState)(false);
  const connection = (0,lib.useConnection)();
  const {
    store
  } = (0,meta.useMeta)();
  const {
    setStoreForOwner
  } = (0,lib.useStore)();
  const history = (0,external_react_router_dom_.useHistory)();
  const wallet = (0,wallet_adapter_react_.useWallet)();
  const {
    setVisible
  } = (0,lib.useWalletModal)();
  const connect = (0,external_react_.useCallback)(() => wallet.wallet ? wallet.connect().catch() : setVisible(true), [wallet.wallet, wallet.connect, setVisible]);
  const {
    0: storeAddress,
    1: setStoreAddress
  } = (0,external_react_.useState)();
  (0,external_react_.useEffect)(() => {
    if (false) {}
  }, [wallet.publicKey]);

  const initializeStore = async () => {
    if (!wallet.publicKey) {
      return;
    }

    setIsInitalizingStore(true);
    await saveAdmin(connection, wallet, false, [new lib.WhitelistedCreator({
      address: wallet.publicKey.toBase58(),
      activated: true
    })]); // TODO: process errors

    await setStoreForOwner(undefined);
    await setStoreForOwner(wallet.publicKey.toBase58());
    history.push('/admin');
  };

  return /*#__PURE__*/(0,jsx_runtime_.jsxs)(jsx_runtime_.Fragment, {
    children: [!wallet.connected && /*#__PURE__*/(0,jsx_runtime_.jsxs)("p", {
      children: [/*#__PURE__*/jsx_runtime_.jsx(external_antd_.Button, {
        type: "primary",
        className: "app-btn",
        onClick: connect,
        children: "Connect"
      }), ' ', "to configure store."]
    }), wallet.connected && !store && /*#__PURE__*/(0,jsx_runtime_.jsxs)(jsx_runtime_.Fragment, {
      children: [/*#__PURE__*/jsx_runtime_.jsx("p", {
        children: "Store is not initialized yet"
      }), /*#__PURE__*/jsx_runtime_.jsx("p", {
        children: "There must be some \u25CE SOL in the wallet before initialization."
      }), /*#__PURE__*/jsx_runtime_.jsx("p", {
        children: "After initialization, you will be able to manage the list of creators"
      }), /*#__PURE__*/jsx_runtime_.jsx("p", {
        children: /*#__PURE__*/jsx_runtime_.jsx(external_antd_.Button, {
          className: "app-btn",
          type: "primary",
          loading: isInitalizingStore,
          onClick: initializeStore,
          children: "Init Store"
        })
      })]
    }), wallet.connected && store && /*#__PURE__*/(0,jsx_runtime_.jsxs)(jsx_runtime_.Fragment, {
      children: [/*#__PURE__*/(0,jsx_runtime_.jsxs)("p", {
        children: ["To finish initialization please copy config below into", ' ', /*#__PURE__*/jsx_runtime_.jsx("b", {
          children: "packages/web/.env"
        }), " and restart yarn or redeploy"]
      }), /*#__PURE__*/jsx_runtime_.jsx(SetupVariables, {
        storeAddress: storeAddress,
        storeOwnerAddress: (_wallet$publicKey = wallet.publicKey) === null || _wallet$publicKey === void 0 ? void 0 : _wallet$publicKey.toBase58()
      })]
    })]
  });
};
;// CONCATENATED MODULE: ./src/views/home/index.tsx







const HomeView = () => {
  const {
    isLoading,
    store
  } = (0,meta.useMeta)();
  const {
    isConfigured
  } = (0,lib.useStore)();
  const showAuctions = store && isConfigured || isLoading;
  return /*#__PURE__*/jsx_runtime_.jsx(external_antd_.Layout, {
    style: {
      margin: 0,
      marginTop: 30,
      alignItems: 'center'
    },
    children: showAuctions ? /*#__PURE__*/jsx_runtime_.jsx(SalesListView, {}) : /*#__PURE__*/jsx_runtime_.jsx(SetupView, {})
  });
};
;// CONCATENATED MODULE: ./src/components/ViewOn/index.tsx







const ViewOn = ({
  id
}) => {
  const {
    endpoint
  } = (0,lib.useConnectionConfig)();
  const art = useArt(id);
  return /*#__PURE__*/jsx_runtime_.jsx(jsx_runtime_.Fragment, {
    children: /*#__PURE__*/(0,jsx_runtime_.jsxs)(external_antd_.Col, {
      children: [/*#__PURE__*/jsx_runtime_.jsx("h6", {
        children: "View on"
      }), /*#__PURE__*/(0,jsx_runtime_.jsxs)("div", {
        style: {
          display: 'flex'
        },
        children: [/*#__PURE__*/jsx_runtime_.jsx(external_antd_.Button, {
          className: "tag",
          onClick: () => window.open(art.uri || '', '_blank'),
          children: "Arweave"
        }), /*#__PURE__*/jsx_runtime_.jsx(external_antd_.Button, {
          className: "tag",
          onClick: () => {
            const cluster = endpoint.name;
            const explorerURL = new URL(`account/${(art === null || art === void 0 ? void 0 : art.mint) || ''}`, 'https://explorer.solana.com');

            if (!cluster.includes('mainnet')) {
              explorerURL.searchParams.set('cluster', cluster);
            }

            window.open(explorerURL.href, '_blank');
          },
          children: "Solana"
        })]
      })]
    })
  });
};
// EXTERNAL MODULE: external "lodash/debounce"
var debounce_ = __webpack_require__(223);
var debounce_default = /*#__PURE__*/__webpack_require__.n(debounce_);
;// CONCATENATED MODULE: ./src/actions/setupMintEditionIntoWalletInstructions.ts



async function setupMintEditionIntoWalletInstructions(art, wallet, connection, mintTokenAccount, edition, instructions, signers, mintDestination) {
  if (!art.mint) throw new Error('Art mint is not provided');

  if (typeof art.supply === 'undefined') {
    throw new Error('Art supply is not provided');
  }

  if (!wallet.publicKey) throw new Error('Wallet pubKey is not provided');

  if (!mintTokenAccount) {
    throw new Error('Art mint token account is not provided');
  }

  const walletPubKey = wallet.publicKey.toString();
  const {
    mint: tokenMint
  } = art;
  const {
    pubkey: mintTokenAccountPubKey
  } = mintTokenAccount;
  const mintTokenAccountOwner = mintTokenAccount.info.owner.toString();
  const mintRentExempt = await connection.getMinimumBalanceForRentExemption(spl_token_.MintLayout.span);
  const {
    mint: newMint
  } = await createMintAndAccountWithOne(wallet, mintDestination, mintRentExempt, instructions, signers);
  await (0,lib.mintNewEditionFromMasterEditionViaToken)(newMint, tokenMint, walletPubKey, walletPubKey, mintTokenAccountOwner, mintTokenAccountPubKey, instructions, walletPubKey, edition);
}
;// CONCATENATED MODULE: ./src/actions/mintEditionsIntoWallet.ts



// TODO: Refactor. Extract batching logic,
//  as the similar one is used in settle.ts and convertMasterEditions.ts
const MINT_TRANSACTION_SIZE = 5;
const mintEditionsIntoWallet_BATCH_SIZE = 10;
async function mintEditionsToWallet(art, wallet, connection, mintTokenAccount, editions = 1, mintDestination, editionNumber) {
  const signers = [];
  const instructions = [];
  let currSignerBatch = [];
  let currInstrBatch = [];
  let mintEditionIntoWalletSigners = [];
  let mintEditionIntoWalletInstructions = []; // TODO replace all this with payer account so user doesnt need to click approve several times.
  // Overall we have 10 parallel txns.
  // That's what this loop is building.

  for (let i = 0; i < editions; i++) {
    console.log('Minting', i);
    await setupMintEditionIntoWalletInstructions(art, wallet, connection, mintTokenAccount, editionNumber ? new (external_bn_js_default())(editionNumber) : new (external_bn_js_default())(art.supply + 1 + i), mintEditionIntoWalletInstructions, mintEditionIntoWalletSigners, mintDestination);

    if (mintEditionIntoWalletInstructions.length === MINT_TRANSACTION_SIZE) {
      currSignerBatch.push(mintEditionIntoWalletSigners);
      currInstrBatch.push(mintEditionIntoWalletInstructions);
      mintEditionIntoWalletSigners = [];
      mintEditionIntoWalletInstructions = [];
    }

    if (currInstrBatch.length === mintEditionsIntoWallet_BATCH_SIZE) {
      signers.push(currSignerBatch);
      instructions.push(currInstrBatch);
      currSignerBatch = [];
      currInstrBatch = [];
    }
  }

  if (mintEditionIntoWalletInstructions.length < MINT_TRANSACTION_SIZE && mintEditionIntoWalletInstructions.length > 0) {
    currSignerBatch.push(mintEditionIntoWalletSigners);
    currInstrBatch.push(mintEditionIntoWalletInstructions);
  }

  if (currInstrBatch.length <= mintEditionsIntoWallet_BATCH_SIZE && currInstrBatch.length > 0) {
    // add the last one on
    signers.push(currSignerBatch);
    instructions.push(currInstrBatch);
  }

  console.log('Instructions', instructions);

  for (let i = 0; i < instructions.length; i++) {
    const instructionBatch = instructions[i];
    const signerBatch = signers[i];
    console.log('Running batch', i);
    if (instructionBatch.length >= 2) // Pump em through!
      await (0,lib.sendTransactions)(connection, wallet, instructionBatch, signerBatch, lib.SequenceType.StopOnFailure, 'single');else await (0,lib.sendTransactionWithRetry)(connection, wallet, instructionBatch[0], signerBatch[0], 'single');
    console.log('Done');
  }
}
;// CONCATENATED MODULE: ./src/components/ArtMinting/index.tsx















const ArtMinting = ({
  id,
  onMint
}) => {
  var _wallet$publicKey;

  const wallet = (0,wallet_adapter_react_.useWallet)();
  const connection = (0,lib.useConnection)();
  const {
    accountByMint
  } = (0,lib.useUserAccounts)();
  const {
    0: showMintModal,
    1: setShowMintModal
  } = (0,external_react_.useState)(false);
  const {
    0: showCongrats,
    1: setShowCongrats
  } = (0,external_react_.useState)(false);
  const {
    0: mintingDestination,
    1: setMintingDestination
  } = (0,external_react_.useState)('');
  const {
    0: editions,
    1: setEditions
  } = (0,external_react_.useState)(1);
  const {
    0: editionNumber,
    1: setEditionNumber
  } = (0,external_react_.useState)(undefined);
  const {
    0: totalCost,
    1: setTotalCost
  } = (0,external_react_.useState)(0);
  const {
    0: isLoading,
    1: setIsLoading
  } = (0,external_react_.useState)(false);
  const art = useArt(id);
  const walletPubKey = (wallet === null || wallet === void 0 ? void 0 : (_wallet$publicKey = wallet.publicKey) === null || _wallet$publicKey === void 0 ? void 0 : _wallet$publicKey.toString()) || '';
  const maxEditionsToMint = art.maxSupply - art.supply;
  const isArtMasterEdition = art.type === ArtType.Master;
  const artMintTokenAccount = accountByMint.get(art.mint);
  const isArtOwnedByUser = (accountByMint.has(art.mint) && (artMintTokenAccount === null || artMintTokenAccount === void 0 ? void 0 : artMintTokenAccount.info.amount.toNumber()) || 0) > 0;
  const isMasterEditionV1 = artMintTokenAccount ? (0,lib.decodeMasterEdition)(artMintTokenAccount.account.data).key === lib.MetadataKey.MasterEditionV1 : false;
  const renderMintEdition = isArtMasterEdition && isArtOwnedByUser && !isMasterEditionV1;
  const mintingDestinationErr = (0,external_react_.useMemo)(() => {
    if (!mintingDestination) return 'Required';

    try {
      new web3_js_.PublicKey(mintingDestination);
      return '';
    } catch (e) {
      return 'Invalid address format';
    }
  }, [mintingDestination]);
  const isMintingDisabled = isLoading || editions < 1 || Boolean(mintingDestinationErr);
  const debouncedEditionsChangeHandler = (0,external_react_.useCallback)(debounce_default()(val => {
    setEditions(val < 1 ? 1 : val);
  }, 300), []);
  (0,external_react_.useEffect)(() => {
    if (editions < 1) return;

    (async () => {
      const mintRentExempt = await connection.getMinimumBalanceForRentExemption(spl_token_.MintLayout.span);
      const accountRentExempt = await connection.getMinimumBalanceForRentExemption(spl_token_.AccountLayout.span);
      const metadataRentExempt = await connection.getMinimumBalanceForRentExemption(lib.MAX_METADATA_LEN);
      const editionRentExempt = await connection.getMinimumBalanceForRentExemption(lib.MAX_EDITION_LEN);
      const cost = (mintRentExempt + accountRentExempt + metadataRentExempt + editionRentExempt) * editions / web3_js_.LAMPORTS_PER_SOL;
      setTotalCost(cost);
    })();
  }, [connection, editions]);
  (0,external_react_.useEffect)(() => {
    if (!walletPubKey) return;
    setMintingDestination(walletPubKey);
  }, [walletPubKey]);
  (0,external_react_.useEffect)(() => {
    return debouncedEditionsChangeHandler.cancel();
  }, []);

  const onSuccessfulMint = () => {
    setShowMintModal(false);
    setMintingDestination(walletPubKey);
    setEditions(1);
    setShowCongrats(true);
  };

  const mint = async () => {
    try {
      setIsLoading(true);
      await mintEditionsToWallet(art, wallet, connection, artMintTokenAccount, editions, mintingDestination, editionNumber);
      onSuccessfulMint();
    } catch (e) {
      console.error(e);
    } finally {
      setIsLoading(false);
    }
  };

  return /*#__PURE__*/jsx_runtime_.jsx(jsx_runtime_.Fragment, {
    children: renderMintEdition && /*#__PURE__*/(0,jsx_runtime_.jsxs)("div", {
      children: [/*#__PURE__*/jsx_runtime_.jsx(external_antd_.Button, {
        type: "primary",
        size: "large",
        className: "action-btn",
        style: {
          marginTop: 20
        },
        onClick: () => setShowMintModal(true),
        children: "Mint"
      }), /*#__PURE__*/(0,jsx_runtime_.jsxs)(external_antd_.Modal, {
        visible: showMintModal,
        centered: true,
        okText: "Mint",
        closable: !isLoading,
        okButtonProps: {
          disabled: isMintingDisabled
        },
        cancelButtonProps: {
          disabled: isLoading
        },
        onOk: mint,
        onCancel: () => setShowMintModal(false),
        className: "art-minting-modal",
        children: [/*#__PURE__*/jsx_runtime_.jsx(external_antd_.Form.Item, {
          style: {
            width: '100%',
            flexDirection: 'column',
            paddingTop: 30,
            marginBottom: 4
          },
          label: /*#__PURE__*/jsx_runtime_.jsx("h3", {
            style: {
              color: 'white'
            },
            children: "Mint to"
          }),
          labelAlign: "left",
          colon: false,
          validateStatus: mintingDestinationErr ? 'error' : 'success',
          help: mintingDestinationErr,
          children: /*#__PURE__*/jsx_runtime_.jsx(external_antd_.Input, {
            placeholder: "Address to mint edition to",
            value: mintingDestination,
            onChange: e => {
              setMintingDestination(e.target.value);
            }
          })
        }), /*#__PURE__*/jsx_runtime_.jsx(external_antd_.Form.Item, {
          style: {
            width: '100%',
            flexDirection: 'column',
            paddingTop: 30
          },
          label: /*#__PURE__*/jsx_runtime_.jsx("h3", {
            style: {
              color: 'white'
            },
            children: "Number of editions to mint"
          }),
          labelAlign: "left",
          colon: false,
          children: /*#__PURE__*/jsx_runtime_.jsx(external_antd_.InputNumber, {
            type: "number",
            placeholder: "1",
            style: {
              width: '100%'
            },
            min: 1,
            max: maxEditionsToMint,
            value: editions,
            precision: 0,
            onChange: debouncedEditionsChangeHandler
          })
        }), /*#__PURE__*/jsx_runtime_.jsx(external_antd_.Form.Item, {
          style: {
            width: '100%',
            flexDirection: 'column',
            paddingTop: 30
          },
          label: /*#__PURE__*/jsx_runtime_.jsx("h3", {
            style: {
              color: 'white'
            },
            children: "Edition Number (Optional)"
          }),
          labelAlign: "left",
          colon: false,
          children: /*#__PURE__*/jsx_runtime_.jsx(external_antd_.InputNumber, {
            type: "number",
            style: {
              width: '100%'
            },
            min: 1,
            max: art.supply,
            value: editionNumber,
            precision: 0,
            onChange: setEditionNumber
          })
        }), /*#__PURE__*/(0,jsx_runtime_.jsxs)("div", {
          children: ["Total cost: ", `◎${totalCost}`]
        })]
      }), /*#__PURE__*/(0,jsx_runtime_.jsxs)(lib.MetaplexOverlay, {
        visible: showCongrats,
        children: [/*#__PURE__*/jsx_runtime_.jsx(Confetti, {}), /*#__PURE__*/jsx_runtime_.jsx("h1", {
          className: "title",
          style: {
            fontSize: '3rem',
            marginBottom: 20
          },
          children: "Congratulations"
        }), /*#__PURE__*/(0,jsx_runtime_.jsxs)("p", {
          style: {
            color: 'white',
            textAlign: 'center',
            fontSize: '2rem'
          },
          children: ["New editions have been minted please view your NFTs in", ' ', /*#__PURE__*/jsx_runtime_.jsx(external_react_router_dom_.Link, {
            to: "/artworks",
            children: "My Items"
          }), "."]
        }), /*#__PURE__*/jsx_runtime_.jsx(external_antd_.Button, {
          onClick: async () => {
            await onMint();
            setShowCongrats(false);
          },
          className: "overlay-btn",
          children: "Got it"
        })]
      })]
    })
  });
};
;// CONCATENATED MODULE: ./src/views/art/index.tsx















const {
  Content: art_Content
} = external_antd_.Layout;
const ArtView = () => {
  var _wallet$publicKey, _art$creators, _art$creators2;

  const {
    id
  } = (0,external_react_router_dom_.useParams)();
  const wallet = (0,wallet_adapter_react_.useWallet)();
  const {
    0: remountArtMinting,
    1: setRemountArtMinting
  } = (0,external_react_.useState)(0);
  const connection = (0,lib.useConnection)();
  const art = useArt(id);
  let badge = '';
  let maxSupply = '';

  if (art.type === ArtType.NFT) {
    badge = 'Unique';
  } else if (art.type === ArtType.Master) {
    badge = 'NFT 0';

    if (art.maxSupply !== undefined) {
      maxSupply = art.maxSupply.toString();
    } else {
      maxSupply = 'Unlimited';
    }
  } else if (art.type === ArtType.Print) {
    badge = `${art.edition} of ${art.supply}`;
  }

  const {
    ref,
    data
  } = useExtendedArt(id); // const { userAccounts } = useUserAccounts();
  // const accountByMint = userAccounts.reduce((prev, acc) => {
  //   prev.set(acc.info.mint.toBase58(), acc);
  //   return prev;
  // }, new Map<string, TokenAccount>());

  const description = data === null || data === void 0 ? void 0 : data.description;
  const attributes = data === null || data === void 0 ? void 0 : data.attributes;
  const pubkey = (wallet === null || wallet === void 0 ? void 0 : (_wallet$publicKey = wallet.publicKey) === null || _wallet$publicKey === void 0 ? void 0 : _wallet$publicKey.toBase58()) || '';

  const tag = /*#__PURE__*/jsx_runtime_.jsx("div", {
    className: "info-header",
    children: /*#__PURE__*/jsx_runtime_.jsx(external_antd_.Tag, {
      color: "blue",
      children: "UNVERIFIED"
    })
  });

  const unverified = /*#__PURE__*/(0,jsx_runtime_.jsxs)(jsx_runtime_.Fragment, {
    children: [tag, /*#__PURE__*/jsx_runtime_.jsx("div", {
      style: {
        fontSize: 12
      },
      children: /*#__PURE__*/(0,jsx_runtime_.jsxs)("i", {
        children: ["This artwork is still missing verification from", ' ', (_art$creators = art.creators) === null || _art$creators === void 0 ? void 0 : _art$creators.filter(c => !c.verified).length, " contributors before it can be considered verified and sellable on the platform."]
      })
    }), /*#__PURE__*/jsx_runtime_.jsx("br", {})]
  });

  return /*#__PURE__*/jsx_runtime_.jsx(art_Content, {
    children: /*#__PURE__*/jsx_runtime_.jsx(external_antd_.Col, {
      children: /*#__PURE__*/(0,jsx_runtime_.jsxs)(external_antd_.Row, {
        ref: ref,
        children: [/*#__PURE__*/jsx_runtime_.jsx(external_antd_.Col, {
          xs: {
            span: 24
          },
          md: {
            span: 12
          },
          style: {
            paddingRight: '30px'
          },
          children: /*#__PURE__*/jsx_runtime_.jsx(ArtContent, {
            style: {
              width: '100%',
              height: 'auto',
              margin: '0 auto'
            },
            height: 300,
            width: 300,
            className: "artwork-image",
            pubkey: id,
            active: true,
            allowMeshRender: true,
            artView: true
          })
        }), /*#__PURE__*/(0,jsx_runtime_.jsxs)(external_antd_.Col, {
          xs: {
            span: 24
          },
          md: {
            span: 12
          },
          style: {
            textAlign: 'left',
            fontSize: '1.4rem'
          },
          children: [/*#__PURE__*/jsx_runtime_.jsx(external_antd_.Row, {
            children: /*#__PURE__*/jsx_runtime_.jsx("div", {
              style: {
                fontWeight: 700,
                fontSize: '4rem'
              },
              children: art.title || /*#__PURE__*/jsx_runtime_.jsx(external_antd_.Skeleton, {
                paragraph: {
                  rows: 0
                }
              })
            })
          }), /*#__PURE__*/(0,jsx_runtime_.jsxs)(external_antd_.Row, {
            children: [/*#__PURE__*/(0,jsx_runtime_.jsxs)(external_antd_.Col, {
              span: 6,
              children: [/*#__PURE__*/jsx_runtime_.jsx("h6", {
                children: "Royalties"
              }), /*#__PURE__*/(0,jsx_runtime_.jsxs)("div", {
                className: "royalties",
                children: [((art.seller_fee_basis_points || 0) / 100).toFixed(2), "%"]
              })]
            }), /*#__PURE__*/jsx_runtime_.jsx(external_antd_.Col, {
              span: 12,
              children: /*#__PURE__*/jsx_runtime_.jsx(ViewOn, {
                id: id
              })
            })]
          }), /*#__PURE__*/jsx_runtime_.jsx(external_antd_.Row, {
            children: /*#__PURE__*/(0,jsx_runtime_.jsxs)(external_antd_.Col, {
              children: [/*#__PURE__*/jsx_runtime_.jsx("h6", {
                style: {
                  marginTop: 5
                },
                children: "Created By"
              }), /*#__PURE__*/jsx_runtime_.jsx("div", {
                className: "creators",
                children: (art.creators || []).map((creator, idx) => {
                  return /*#__PURE__*/(0,jsx_runtime_.jsxs)("div", {
                    style: {
                      display: 'flex',
                      alignItems: 'center',
                      marginBottom: 5
                    },
                    children: [/*#__PURE__*/jsx_runtime_.jsx(MetaAvatar, {
                      creators: [creator],
                      size: 64
                    }), /*#__PURE__*/(0,jsx_runtime_.jsxs)("div", {
                      children: [/*#__PURE__*/jsx_runtime_.jsx("span", {
                        className: "creator-name",
                        children: creator.name || (0,lib.shortenAddress)(creator.address || '')
                      }), /*#__PURE__*/jsx_runtime_.jsx("div", {
                        style: {
                          marginLeft: 10
                        },
                        children: !creator.verified && (creator.address === pubkey ? /*#__PURE__*/jsx_runtime_.jsx(external_antd_.Button, {
                          onClick: async () => {
                            try {
                              await sendSignMetadata(connection, wallet, id);
                            } catch (e) {
                              console.error(e);
                              return false;
                            }

                            return true;
                          },
                          children: "Approve"
                        }) : tag)
                      })]
                    })]
                  }, idx);
                })
              })]
            })
          }), /*#__PURE__*/jsx_runtime_.jsx(external_antd_.Row, {
            children: /*#__PURE__*/(0,jsx_runtime_.jsxs)(external_antd_.Col, {
              children: [/*#__PURE__*/jsx_runtime_.jsx("h6", {
                style: {
                  marginTop: 5
                },
                children: "Edition"
              }), /*#__PURE__*/jsx_runtime_.jsx("div", {
                className: "art-edition",
                children: badge
              })]
            })
          }), art.type === ArtType.Master && /*#__PURE__*/jsx_runtime_.jsx(external_antd_.Row, {
            children: /*#__PURE__*/(0,jsx_runtime_.jsxs)(external_antd_.Col, {
              children: [/*#__PURE__*/jsx_runtime_.jsx("h6", {
                style: {
                  marginTop: 5
                },
                children: "Max Supply"
              }), /*#__PURE__*/jsx_runtime_.jsx("div", {
                className: "art-edition",
                children: maxSupply
              })]
            })
          }), /*#__PURE__*/jsx_runtime_.jsx(ArtMinting, {
            id: id,
            onMint: async () => await setRemountArtMinting(prev => prev + 1)
          }, remountArtMinting)]
        }), /*#__PURE__*/(0,jsx_runtime_.jsxs)(external_antd_.Col, {
          span: "12",
          children: [/*#__PURE__*/jsx_runtime_.jsx(external_antd_.Divider, {}), ((_art$creators2 = art.creators) === null || _art$creators2 === void 0 ? void 0 : _art$creators2.find(c => !c.verified)) && unverified, /*#__PURE__*/jsx_runtime_.jsx("br", {}), /*#__PURE__*/jsx_runtime_.jsx("div", {
            className: "info-header",
            children: "ABOUT THE CREATION"
          }), /*#__PURE__*/jsx_runtime_.jsx("div", {
            className: "info-content",
            children: description
          }), /*#__PURE__*/jsx_runtime_.jsx("br", {})]
        }), /*#__PURE__*/jsx_runtime_.jsx(external_antd_.Col, {
          span: "12",
          children: attributes && /*#__PURE__*/(0,jsx_runtime_.jsxs)(jsx_runtime_.Fragment, {
            children: [/*#__PURE__*/jsx_runtime_.jsx(external_antd_.Divider, {}), /*#__PURE__*/jsx_runtime_.jsx("br", {}), /*#__PURE__*/jsx_runtime_.jsx("div", {
              className: "info-header",
              children: "Attributes"
            }), /*#__PURE__*/jsx_runtime_.jsx(external_antd_.List, {
              size: "large",
              grid: {
                column: 4
              },
              children: attributes.map(attribute => /*#__PURE__*/jsx_runtime_.jsx(external_antd_.List.Item, {
                children: /*#__PURE__*/jsx_runtime_.jsx(external_antd_.Card, {
                  title: attribute.trait_type,
                  children: attribute.value
                })
              }, attribute.trait_type))
            })]
          })
        })]
      })
    })
  });
};
;// CONCATENATED MODULE: ./src/components/ArtCard/index.tsx
const _excluded = ["className", "small", "category", "image", "animationURL", "preview", "onClose", "pubkey", "height", "artView", "width", "count", "name", "creators"];

function ArtCard_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

function ArtCard_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ArtCard_ownKeys(Object(source), true).forEach(function (key) { ArtCard_defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ArtCard_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function ArtCard_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }

function _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }










const {
  Meta
} = external_antd_.Card;
const ArtCard = props => {
  var _art$creators;

  const {
    className,
    small,
    category,
    image,
    animationURL,
    preview,
    onClose,
    pubkey,
    height,
    artView,
    width,
    count,
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    name: _name,
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    creators: _creators
  } = props,
        rest = _objectWithoutProperties(props, _excluded);

  const art = useArt(pubkey);
  let {
    name,
    creators
  } = props;
  creators = (art === null || art === void 0 ? void 0 : art.creators) || creators || [];
  name = (art === null || art === void 0 ? void 0 : art.title) || name || ' ';
  let badge = '';

  if (art.type === ArtType.NFT) {
    badge = 'Unique';
  } else if (art.type === ArtType.Master) {
    badge = 'NFT 0';
  } else if (art.type === ArtType.Print) {
    badge = `${art.edition} of ${art.supply}`;
  }

  const card = /*#__PURE__*/(0,jsx_runtime_.jsxs)(external_antd_.Card, ArtCard_objectSpread(ArtCard_objectSpread({
    hoverable: true,
    className: `art-card ${small ? 'small' : ''} ${className !== null && className !== void 0 ? className : ''}`
  }, rest), {}, {
    children: [onClose && /*#__PURE__*/jsx_runtime_.jsx(external_antd_.Button, {
      className: "card-close-button",
      shape: "circle",
      onClick: e => {
        e.stopPropagation();
        e.preventDefault();
        onClose && onClose();
      },
      children: "X"
    }), /*#__PURE__*/(0,jsx_runtime_.jsxs)("div", {
      className: "art-card__header",
      children: [/*#__PURE__*/jsx_runtime_.jsx(MetaAvatar, {
        creators: creators,
        size: 32
      }), /*#__PURE__*/jsx_runtime_.jsx("div", {
        className: "edition-badge",
        children: badge
      })]
    }), /*#__PURE__*/jsx_runtime_.jsx("div", {
      className: "art-content__wrapper",
      children: /*#__PURE__*/jsx_runtime_.jsx(ArtContent, {
        pubkey: pubkey,
        uri: image,
        animationURL: animationURL,
        category: category,
        preview: preview,
        height: height,
        width: width,
        artView: artView
      })
    }), /*#__PURE__*/jsx_runtime_.jsx(Meta, {
      title: `${name}`,
      description: /*#__PURE__*/jsx_runtime_.jsx(jsx_runtime_.Fragment, {
        children: count && /*#__PURE__*/(0,jsx_runtime_.jsxs)("div", {
          className: "edition-badge",
          children: ["Selected count: ", count]
        })
      })
    })]
  }));

  return (_art$creators = art.creators) !== null && _art$creators !== void 0 && _art$creators.find(c => !c.verified) ? /*#__PURE__*/jsx_runtime_.jsx(external_antd_.Badge.Ribbon, {
    text: "Unverified",
    children: card
  }) : card;
};
;// CONCATENATED MODULE: ./src/components/UserSearch/index.tsx
const UserSearch_excluded = ["fetchOptions", "debounceTimeout"];

function UserSearch_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

function UserSearch_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { UserSearch_ownKeys(Object(source), true).forEach(function (key) { UserSearch_defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { UserSearch_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function UserSearch_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function UserSearch_objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = UserSearch_objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }

function UserSearch_objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }








function DebounceSelect(_ref) {
  let {
    fetchOptions,
    debounceTimeout = 800
  } = _ref,
      props = UserSearch_objectWithoutProperties(_ref, UserSearch_excluded);

  const {
    0: fetching,
    1: setFetching
  } = (0,external_react_.useState)(false);
  const {
    0: options,
    1: setOptions
  } = (0,external_react_.useState)([]);
  const fetchRef = (0,external_react_.useRef)(0);
  const debounceFetcher = (0,external_react_.useMemo)(() => {
    const loadOptions = value => {
      fetchRef.current += 1;
      const fetchId = fetchRef.current;
      setOptions([]);
      setFetching(true);
      fetchOptions(value).then(newOptions => {
        if (fetchId !== fetchRef.current) {
          // for fetch callback order
          return;
        }

        setOptions(newOptions);
        setFetching(false);
      });
    };

    return debounce_default()(loadOptions, debounceTimeout);
  }, [fetchOptions, debounceTimeout]);
  return /*#__PURE__*/jsx_runtime_.jsx(external_antd_.Select, UserSearch_objectSpread(UserSearch_objectSpread({
    labelInValue: true,
    filterOption: false,
    onSearch: debounceFetcher,
    notFoundContent: fetching ? /*#__PURE__*/jsx_runtime_.jsx(external_antd_.Spin, {
      size: "small"
    }) : null
  }, props), {}, {
    options: options
  }));
} // Usage of DebounceSelect


const UserSearch = props => {
  const {
    whitelistedCreatorsByCreator
  } = (0,meta.useMeta)();
  const [value, setValue] = external_react_default().useState([]);
  return /*#__PURE__*/jsx_runtime_.jsx(DebounceSelect, {
    className: "user-selector",
    mode: "multiple",
    size: "large",
    value: value,
    placeholder: "Select creator",
    fetchOptions: async () => {
      const items = Object.values(whitelistedCreatorsByCreator).filter(c => c.info.activated).map(a => ({
        label: a.info.name || (0,lib.shortenAddress)(a.info.address),
        value: a.info.address
      }));
      return items;
    },
    onChange: newValue => {
      props.setCreators(newValue);
      setValue(newValue);
    },
    style: {
      width: '100%'
    }
  });
};
// EXTERNAL MODULE: external "crypto"
var external_crypto_ = __webpack_require__(6417);
var external_crypto_default = /*#__PURE__*/__webpack_require__.n(external_crypto_);
;// CONCATENATED MODULE: ./src/utils/ids.ts
 // TODO: generate key ---

const AR_SOL_HOLDER_ID = new web3_js_.PublicKey('6FKvsq4ydWFci6nGq9ckbjYMtnmaqAoatz5c9XWjiDuS');
;// CONCATENATED MODULE: ./src/actions/nft.tsx
function nft_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

function nft_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { nft_ownKeys(Object(source), true).forEach(function (key) { nft_defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { nft_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function nft_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }









const RESERVED_TXN_MANIFEST = 'manifest.json';
const RESERVED_METADATA = 'metadata.json';

const uploadToArweave = async data => {
  const resp = await fetch(lib.ARWEAVE_UPLOAD_ENDPOINT, {
    method: 'POST',
    // @ts-ignore
    body: data
  });

  if (!resp.ok) {
    return Promise.reject(new Error('Unable to upload the artwork to Arweave. Please wait and then try again.'));
  }

  const result = await resp.json();

  if (result.error) {
    return Promise.reject(new Error(result.error));
  }

  return result;
};

const mintNFT = async (connection, wallet, endpoint, files, metadata, progressCallback, maxSupply) => {
  var _metadata$creators, _result$messages;

  if (!(wallet !== null && wallet !== void 0 && wallet.publicKey)) return;
  const metadataContent = {
    name: metadata.name,
    symbol: metadata.symbol,
    description: metadata.description,
    seller_fee_basis_points: metadata.sellerFeeBasisPoints,
    image: metadata.image,
    animation_url: metadata.animation_url,
    attributes: metadata.attributes,
    external_url: metadata.external_url,
    properties: nft_objectSpread(nft_objectSpread({}, metadata.properties), {}, {
      creators: (_metadata$creators = metadata.creators) === null || _metadata$creators === void 0 ? void 0 : _metadata$creators.map(creator => {
        return {
          address: creator.address,
          share: creator.share
        };
      })
    })
  };
  const realFiles = [...files, new File([JSON.stringify(metadataContent)], RESERVED_METADATA)];
  const {
    instructions: pushInstructions,
    signers: pushSigners
  } = await prepPayForFilesTxn(wallet, realFiles);
  progressCallback(1);
  const TOKEN_PROGRAM_ID = (0,lib.programIds)().token; // Allocate memory for the account

  const mintRent = await connection.getMinimumBalanceForRentExemption(spl_token_.MintLayout.span); // const accountRent = await connection.getMinimumBalanceForRentExemption(
  //   AccountLayout.span,
  // );
  // This owner is a temporary signer and owner of metadata we use to circumvent requesting signing
  // twice post Arweave. We store in an account (payer) and use it post-Arweave to update MD with new link
  // then give control back to the user.
  // const payer = new Account();

  const payerPublicKey = wallet.publicKey.toBase58();
  const instructions = [...pushInstructions];
  const signers = [...pushSigners]; // This is only temporarily owned by wallet...transferred to program by createMasterEdition below

  const mintKey = (0,lib.createMint)(instructions, wallet.publicKey, mintRent, 0, // Some weird bug with phantom where it's public key doesnt mesh with data encode wellff
  (0,lib.toPublicKey)(payerPublicKey), (0,lib.toPublicKey)(payerPublicKey), signers).toBase58();
  const recipientKey = (await (0,lib.findProgramAddress)([wallet.publicKey.toBuffer(), (0,lib.programIds)().token.toBuffer(), (0,lib.toPublicKey)(mintKey).toBuffer()], (0,lib.programIds)().associatedToken))[0];
  (0,lib.createAssociatedTokenAccountInstruction)(instructions, (0,lib.toPublicKey)(recipientKey), wallet.publicKey, wallet.publicKey, (0,lib.toPublicKey)(mintKey));
  const metadataAccount = await (0,lib.createMetadata)(new lib.Data({
    symbol: metadata.symbol,
    name: metadata.name,
    uri: ' '.repeat(64),
    // size of url for arweave
    sellerFeeBasisPoints: metadata.sellerFeeBasisPoints,
    creators: metadata.creators
  }), payerPublicKey, mintKey, payerPublicKey, instructions, wallet.publicKey.toBase58());
  progressCallback(2); // TODO: enable when using payer account to avoid 2nd popup
  // const block = await connection.getRecentBlockhash('singleGossip');
  // instructions.push(
  //   SystemProgram.transfer({
  //     fromPubkey: wallet.publicKey,
  //     toPubkey: payerPublicKey,
  //     lamports: 0.5 * LAMPORTS_PER_SOL // block.feeCalculator.lamportsPerSignature * 3 + mintRent, // TODO
  //   }),
  // );

  const {
    txid
  } = await (0,lib.sendTransactionWithRetry)(connection, wallet, instructions, signers, 'single');
  progressCallback(3);

  try {
    await connection.confirmTransaction(txid, 'max');
    progressCallback(4);
  } catch {// ignore
  } // Force wait for max confirmations
  // await connection.confirmTransaction(txid, 'max');


  await connection.getParsedConfirmedTransaction(txid, 'confirmed');
  progressCallback(5); // this means we're done getting AR txn setup. Ship it off to ARWeave!

  const data = new FormData();
  data.append('transaction', txid);
  data.append('env', endpoint);
  const tags = realFiles.reduce((acc, f) => {
    acc[f.name] = [{
      name: 'mint',
      value: mintKey
    }];
    return acc;
  }, {});
  data.append('tags', JSON.stringify(tags));
  realFiles.map(f => data.append('file[]', f)); // TODO: convert to absolute file name for image

  const result = await uploadToArweave(data);
  progressCallback(6);
  const metadataFile = (_result$messages = result.messages) === null || _result$messages === void 0 ? void 0 : _result$messages.find(m => m.filename === RESERVED_TXN_MANIFEST);

  if (metadataFile !== null && metadataFile !== void 0 && metadataFile.transactionId && wallet.publicKey) {
    const updateInstructions = [];
    const updateSigners = []; // TODO: connect to testnet arweave

    const arweaveLink = `https://arweave.net/${metadataFile.transactionId}`;
    await (0,lib.updateMetadata)(new lib.Data({
      name: metadata.name,
      symbol: metadata.symbol,
      uri: arweaveLink,
      creators: metadata.creators,
      sellerFeeBasisPoints: metadata.sellerFeeBasisPoints
    }), undefined, undefined, mintKey, payerPublicKey, updateInstructions, metadataAccount);
    updateInstructions.push(spl_token_.Token.createMintToInstruction(TOKEN_PROGRAM_ID, (0,lib.toPublicKey)(mintKey), (0,lib.toPublicKey)(recipientKey), (0,lib.toPublicKey)(payerPublicKey), [], 1));
    progressCallback(7); // // In this instruction, mint authority will be removed from the main mint, while
    // // minting authority will be maintained for the Printing mint (which we want.)

    await (0,lib.createMasterEdition)(maxSupply !== undefined ? new (external_bn_js_default())(maxSupply) : undefined, mintKey, payerPublicKey, payerPublicKey, payerPublicKey, updateInstructions); // TODO: enable when using payer account to avoid 2nd popup

    /*  if (maxSupply !== undefined)
      updateInstructions.push(
        setAuthority({
          target: authTokenAccount,
          currentAuthority: payerPublicKey,
          newAuthority: wallet.publicKey,
          authorityType: 'AccountOwner',
        }),
      );
    */
    // TODO: enable when using payer account to avoid 2nd popup
    // Note with refactoring this needs to switch to the updateMetadataAccount command
    // await transferUpdateAuthority(
    //   metadataAccount,
    //   payerPublicKey,
    //   wallet.publicKey,
    //   updateInstructions,
    // );

    progressCallback(8);
    await (0,lib.sendTransactionWithRetry)(connection, wallet, updateInstructions, updateSigners);
    (0,lib.notify)({
      message: 'Art created on Solana',
      description: /*#__PURE__*/jsx_runtime_.jsx("a", {
        href: arweaveLink,
        target: "_blank",
        rel: "noopener noreferrer",
        children: "Arweave Link"
      }),
      type: 'success'
    }); // TODO: refund funds
    // send transfer back to user
  } // TODO:
  // 1. Jordan: --- upload file and metadata to storage API
  // 2. pay for storage by hashing files and attaching memo for each file


  return {
    metadataAccount
  };
};
const prepPayForFilesTxn = async (wallet, files) => {
  const memo = (0,lib.programIds)().memo;
  const instructions = [];
  const signers = [];
  if (wallet.publicKey) instructions.push(web3_js_.SystemProgram.transfer({
    fromPubkey: wallet.publicKey,
    toPubkey: AR_SOL_HOLDER_ID,
    lamports: await (0,lib.getAssetCostToStore)(files)
  }));

  for (let i = 0; i < files.length; i++) {
    const hashSum = external_crypto_default().createHash('sha256');
    hashSum.update(await files[i].text());
    const hex = hashSum.digest('hex');
    instructions.push(new web3_js_.TransactionInstruction({
      keys: [],
      programId: memo,
      data: Buffer.from(hex)
    }));
  }

  return {
    instructions,
    signers
  };
};
;// CONCATENATED MODULE: ./src/actions/createVault.ts





 // This command creates the external pricing oracle a vault
// This gets the vault ready for adding the tokens.

async function createVault(connection, wallet, priceMint, externalPriceAccount) {
  if (!wallet.publicKey) throw new wallet_adapter_base_.WalletNotConnectedError();
  const PROGRAM_IDS = lib.utils.programIds();
  const signers = [];
  const instructions = [];
  const accountRentExempt = await connection.getMinimumBalanceForRentExemption(spl_token_.AccountLayout.span);
  const mintRentExempt = await connection.getMinimumBalanceForRentExemption(spl_token_.MintLayout.span);
  const vaultRentExempt = await connection.getMinimumBalanceForRentExemption(actions_vault.MAX_VAULT_SIZE);
  const vault = web3_js_.Keypair.generate();
  const vaultAuthority = (await (0,lib.findProgramAddress)([Buffer.from(actions_vault.VAULT_PREFIX), (0,lib.toPublicKey)(PROGRAM_IDS.vault).toBuffer(), vault.publicKey.toBuffer()], (0,lib.toPublicKey)(PROGRAM_IDS.vault)))[0];
  const fractionalMint = (0,lib.createMint)(instructions, wallet.publicKey, mintRentExempt, 0, (0,lib.toPublicKey)(vaultAuthority), (0,lib.toPublicKey)(vaultAuthority), signers).toBase58();
  const redeemTreasury = (0,account.createTokenAccount)(instructions, wallet.publicKey, accountRentExempt, (0,lib.toPublicKey)(priceMint), (0,lib.toPublicKey)(vaultAuthority), signers).toBase58();
  const fractionTreasury = (0,account.createTokenAccount)(instructions, wallet.publicKey, accountRentExempt, (0,lib.toPublicKey)(fractionalMint), (0,lib.toPublicKey)(vaultAuthority), signers).toBase58();
  const uninitializedVault = web3_js_.SystemProgram.createAccount({
    fromPubkey: wallet.publicKey,
    newAccountPubkey: vault.publicKey,
    lamports: vaultRentExempt,
    space: actions_vault.MAX_VAULT_SIZE,
    programId: (0,lib.toPublicKey)(PROGRAM_IDS.vault)
  });
  instructions.push(uninitializedVault);
  signers.push(vault);
  await (0,actions_vault.initVault)(true, fractionalMint, redeemTreasury, fractionTreasury, vault.publicKey.toBase58(), wallet.publicKey.toBase58(), externalPriceAccount, instructions);
  return {
    vault: vault.publicKey.toBase58(),
    fractionalMint,
    redeemTreasury,
    fractionTreasury,
    signers,
    instructions
  };
}
// EXTERNAL MODULE: ../common/dist/lib/actions/auction.js
var auction = __webpack_require__(4400);
;// CONCATENATED MODULE: ./src/actions/makeAuction.ts
function makeAuction_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

function makeAuction_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { makeAuction_ownKeys(Object(source), true).forEach(function (key) { makeAuction_defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { makeAuction_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function makeAuction_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }



 // This command makes an auction

async function makeAuction(wallet, vault, auctionSettings) {
  if (!wallet.publicKey) throw new wallet_adapter_base_.WalletNotConnectedError();
  const PROGRAM_IDS = lib.utils.programIds();
  const signers = [];
  const instructions = [];
  const auctionKey = (await (0,lib.findProgramAddress)([Buffer.from(auction.AUCTION_PREFIX), (0,lib.toPublicKey)(PROGRAM_IDS.auction).toBuffer(), (0,lib.toPublicKey)(vault).toBuffer()], (0,lib.toPublicKey)(PROGRAM_IDS.auction)))[0];
  const fullSettings = new lib.CreateAuctionArgs(makeAuction_objectSpread(makeAuction_objectSpread({}, auctionSettings), {}, {
    authority: wallet.publicKey.toBase58(),
    resource: vault
  }));
  (0,auction.createAuction)(fullSettings, wallet.publicKey.toBase58(), instructions);
  return {
    instructions,
    signers,
    auction: auctionKey
  };
}
;// CONCATENATED MODULE: ./src/actions/index.ts



;// CONCATENATED MODULE: ./src/views/artCreate/index.tsx
function artCreate_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

function artCreate_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { artCreate_ownKeys(Object(source), true).forEach(function (key) { artCreate_defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { artCreate_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function artCreate_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }



















const {
  Step
} = external_antd_.Steps;
const {
  Dragger
} = external_antd_.Upload;
const {
  Text
} = external_antd_.Typography;
const ArtCreateView = () => {
  const connection = (0,lib.useConnection)();
  const {
    endpoint
  } = (0,lib.useConnectionConfig)();
  const wallet = (0,wallet_adapter_react_.useWallet)();
  const {
    0: alertMessage,
    1: setAlertMessage
  } = (0,external_react_.useState)();
  const {
    step_param
  } = (0,external_react_router_dom_.useParams)();
  const history = (0,external_react_router_dom_.useHistory)();
  const {
    width
  } = useWindowDimensions();
  const {
    0: nftCreateProgress,
    1: setNFTcreateProgress
  } = (0,external_react_.useState)(0);
  const {
    0: step,
    1: setStep
  } = (0,external_react_.useState)(0);
  const {
    0: stepsVisible,
    1: setStepsVisible
  } = (0,external_react_.useState)(true);
  const {
    0: isMinting,
    1: setMinting
  } = (0,external_react_.useState)(false);
  const {
    0: nft,
    1: setNft
  } = (0,external_react_.useState)(undefined);
  const {
    0: files,
    1: setFiles
  } = (0,external_react_.useState)([]);
  const {
    0: attributes,
    1: setAttributes
  } = (0,external_react_.useState)({
    name: '',
    symbol: '',
    description: '',
    external_url: '',
    image: '',
    animation_url: undefined,
    attributes: undefined,
    seller_fee_basis_points: 0,
    creators: [],
    properties: {
      files: [],
      category: lib.MetadataCategory.Image
    }
  });
  const gotoStep = (0,external_react_.useCallback)(_step => {
    history.push(`/art/create/${_step.toString()}`);
    if (_step === 0) setStepsVisible(true);
  }, [history]);
  (0,external_react_.useEffect)(() => {
    if (step_param) setStep(parseInt(step_param));else gotoStep(0);
  }, [step_param, gotoStep]); // store files

  const mint = async () => {
    var _attributes$propertie;

    const metadata = {
      name: attributes.name,
      symbol: attributes.symbol,
      creators: attributes.creators,
      description: attributes.description,
      sellerFeeBasisPoints: attributes.seller_fee_basis_points,
      image: attributes.image,
      animation_url: attributes.animation_url,
      attributes: attributes.attributes,
      external_url: attributes.external_url,
      properties: {
        files: attributes.properties.files,
        category: (_attributes$propertie = attributes.properties) === null || _attributes$propertie === void 0 ? void 0 : _attributes$propertie.category
      }
    };
    setStepsVisible(false);
    setMinting(true);

    try {
      var _attributes$propertie2;

      const _nft = await mintNFT(connection, wallet, endpoint.name, files, metadata, setNFTcreateProgress, (_attributes$propertie2 = attributes.properties) === null || _attributes$propertie2 === void 0 ? void 0 : _attributes$propertie2.maxSupply);

      if (_nft) setNft(_nft);
      setAlertMessage('');
    } catch (e) {
      setAlertMessage(e.message);
    } finally {
      setMinting(false);
    }
  };

  return /*#__PURE__*/(0,jsx_runtime_.jsxs)(jsx_runtime_.Fragment, {
    children: [/*#__PURE__*/(0,jsx_runtime_.jsxs)(external_antd_.Row, {
      className: 'creator-base-page',
      style: {
        paddingTop: 50
      },
      children: [stepsVisible && /*#__PURE__*/jsx_runtime_.jsx(external_antd_.Col, {
        span: 24,
        md: 4,
        children: /*#__PURE__*/(0,jsx_runtime_.jsxs)(external_antd_.Steps, {
          progressDot: true,
          direction: width < 768 ? 'horizontal' : 'vertical',
          current: step,
          style: {
            width: 'fit-content',
            margin: '0 auto 30px auto',
            overflowX: 'auto',
            maxWidth: '100%'
          },
          children: [/*#__PURE__*/jsx_runtime_.jsx(Step, {
            title: "Category"
          }), /*#__PURE__*/jsx_runtime_.jsx(Step, {
            title: "Upload"
          }), /*#__PURE__*/jsx_runtime_.jsx(Step, {
            title: "Info"
          }), /*#__PURE__*/jsx_runtime_.jsx(Step, {
            title: "Royalties"
          }), /*#__PURE__*/jsx_runtime_.jsx(Step, {
            title: "Launch"
          })]
        })
      }), /*#__PURE__*/(0,jsx_runtime_.jsxs)(external_antd_.Col, artCreate_objectSpread(artCreate_objectSpread({
        span: 24
      }, stepsVisible ? {
        md: 20
      } : {
        md: 24
      }), {}, {
        children: [step === 0 && /*#__PURE__*/jsx_runtime_.jsx(CategoryStep, {
          confirm: category => {
            setAttributes(artCreate_objectSpread(artCreate_objectSpread({}, attributes), {}, {
              properties: artCreate_objectSpread(artCreate_objectSpread({}, attributes.properties), {}, {
                category
              })
            }));
            gotoStep(1);
          }
        }), step === 1 && /*#__PURE__*/jsx_runtime_.jsx(UploadStep, {
          attributes: attributes,
          setAttributes: setAttributes,
          files: files,
          setFiles: setFiles,
          confirm: () => gotoStep(2)
        }), step === 2 && /*#__PURE__*/jsx_runtime_.jsx(InfoStep, {
          attributes: attributes,
          files: files,
          setAttributes: setAttributes,
          confirm: () => gotoStep(3)
        }), step === 3 && /*#__PURE__*/jsx_runtime_.jsx(RoyaltiesStep, {
          attributes: attributes,
          confirm: () => gotoStep(4),
          setAttributes: setAttributes
        }), step === 4 && /*#__PURE__*/jsx_runtime_.jsx(LaunchStep, {
          attributes: attributes,
          files: files,
          confirm: () => gotoStep(5),
          connection: connection
        }), step === 5 && /*#__PURE__*/jsx_runtime_.jsx(WaitingStep, {
          mint: mint,
          minting: isMinting,
          step: nftCreateProgress,
          confirm: () => gotoStep(6)
        }), 0 < step && step < 5 && /*#__PURE__*/jsx_runtime_.jsx("div", {
          style: {
            margin: 'auto',
            width: 'fit-content'
          },
          children: /*#__PURE__*/jsx_runtime_.jsx(external_antd_.Button, {
            onClick: () => gotoStep(step - 1),
            children: "Back"
          })
        })]
      }))]
    }), /*#__PURE__*/jsx_runtime_.jsx(lib.MetaplexOverlay, {
      visible: step === 6,
      children: /*#__PURE__*/jsx_runtime_.jsx(Congrats, {
        nft: nft,
        alert: alertMessage
      })
    })]
  });
};

const CategoryStep = props => {
  const {
    width
  } = useWindowDimensions();
  return /*#__PURE__*/(0,jsx_runtime_.jsxs)(jsx_runtime_.Fragment, {
    children: [/*#__PURE__*/(0,jsx_runtime_.jsxs)(external_antd_.Row, {
      className: "call-to-action",
      children: [/*#__PURE__*/jsx_runtime_.jsx("h2", {
        children: "Create a new item"
      }), /*#__PURE__*/(0,jsx_runtime_.jsxs)("p", {
        children: ["First time creating on Metaplex?", ' ', /*#__PURE__*/jsx_runtime_.jsx("a", {
          href: "https://docs.metaplex.com/storefront/create",
          target: "_blank",
          rel: "noreferrer",
          children: "Read our creators\u2019 guide."
        })]
      })]
    }), /*#__PURE__*/jsx_runtime_.jsx(external_antd_.Row, {
      justify: width < 768 ? 'center' : 'start',
      children: /*#__PURE__*/(0,jsx_runtime_.jsxs)(external_antd_.Col, {
        children: [/*#__PURE__*/jsx_runtime_.jsx(external_antd_.Row, {
          children: /*#__PURE__*/jsx_runtime_.jsx(external_antd_.Button, {
            className: "type-btn",
            size: "large",
            onClick: () => props.confirm(lib.MetadataCategory.Image),
            children: /*#__PURE__*/(0,jsx_runtime_.jsxs)("div", {
              children: [/*#__PURE__*/jsx_runtime_.jsx("div", {
                children: "Image"
              }), /*#__PURE__*/jsx_runtime_.jsx("div", {
                className: "type-btn-description",
                children: "JPG, PNG, GIF"
              })]
            })
          })
        }), /*#__PURE__*/jsx_runtime_.jsx(external_antd_.Row, {
          children: /*#__PURE__*/jsx_runtime_.jsx(external_antd_.Button, {
            className: "type-btn",
            size: "large",
            onClick: () => props.confirm(lib.MetadataCategory.Video),
            children: /*#__PURE__*/(0,jsx_runtime_.jsxs)("div", {
              children: [/*#__PURE__*/jsx_runtime_.jsx("div", {
                children: "Video"
              }), /*#__PURE__*/jsx_runtime_.jsx("div", {
                className: "type-btn-description",
                children: "MP4, MOV"
              })]
            })
          })
        }), /*#__PURE__*/jsx_runtime_.jsx(external_antd_.Row, {
          children: /*#__PURE__*/jsx_runtime_.jsx(external_antd_.Button, {
            className: "type-btn",
            size: "large",
            onClick: () => props.confirm(lib.MetadataCategory.Audio),
            children: /*#__PURE__*/(0,jsx_runtime_.jsxs)("div", {
              children: [/*#__PURE__*/jsx_runtime_.jsx("div", {
                children: "Audio"
              }), /*#__PURE__*/jsx_runtime_.jsx("div", {
                className: "type-btn-description",
                children: "MP3, WAV, FLAC"
              })]
            })
          })
        }), /*#__PURE__*/jsx_runtime_.jsx(external_antd_.Row, {
          children: /*#__PURE__*/jsx_runtime_.jsx(external_antd_.Button, {
            className: "type-btn",
            size: "large",
            onClick: () => props.confirm(lib.MetadataCategory.VR),
            children: /*#__PURE__*/(0,jsx_runtime_.jsxs)("div", {
              children: [/*#__PURE__*/jsx_runtime_.jsx("div", {
                children: "AR/3D"
              }), /*#__PURE__*/jsx_runtime_.jsx("div", {
                className: "type-btn-description",
                children: "GLB"
              })]
            })
          })
        }), /*#__PURE__*/jsx_runtime_.jsx(external_antd_.Row, {
          children: /*#__PURE__*/jsx_runtime_.jsx(external_antd_.Button, {
            className: "type-btn",
            size: "large",
            onClick: () => props.confirm(lib.MetadataCategory.HTML),
            children: /*#__PURE__*/(0,jsx_runtime_.jsxs)("div", {
              children: [/*#__PURE__*/jsx_runtime_.jsx("div", {
                children: "HTML Asset"
              }), /*#__PURE__*/jsx_runtime_.jsx("div", {
                className: "type-btn-description",
                children: "HTML"
              })]
            })
          })
        })]
      })
    })]
  });
};

const UploadStep = props => {
  var _props$files, _props$files2, _props$attributes$pro, _props$attributes$pro2, _props$attributes$pro3;

  const {
    0: coverFile,
    1: setCoverFile
  } = (0,external_react_.useState)((_props$files = props.files) === null || _props$files === void 0 ? void 0 : _props$files[0]);
  const {
    0: mainFile,
    1: setMainFile
  } = (0,external_react_.useState)((_props$files2 = props.files) === null || _props$files2 === void 0 ? void 0 : _props$files2[1]);
  const {
    0: coverArtError,
    1: setCoverArtError
  } = (0,external_react_.useState)();
  const {
    0: customURL,
    1: setCustomURL
  } = (0,external_react_.useState)('');
  const {
    0: customURLErr,
    1: setCustomURLErr
  } = (0,external_react_.useState)('');
  const disableContinue = !(coverFile || !customURLErr && !!customURL);
  (0,external_react_.useEffect)(() => {
    props.setAttributes(artCreate_objectSpread(artCreate_objectSpread({}, props.attributes), {}, {
      properties: artCreate_objectSpread(artCreate_objectSpread({}, props.attributes.properties), {}, {
        files: []
      })
    }));
  }, []);

  const uploadMsg = category => {
    switch (category) {
      case lib.MetadataCategory.Audio:
        return 'Upload your audio creation (MP3, FLAC, WAV)';

      case lib.MetadataCategory.Image:
        return 'Upload your image creation (PNG, JPG, GIF)';

      case lib.MetadataCategory.Video:
        return 'Upload your video creation (MP4, MOV, GLB)';

      case lib.MetadataCategory.VR:
        return 'Upload your AR/VR creation (GLB)';

      case lib.MetadataCategory.HTML:
        return 'Upload your HTML File (HTML)';

      default:
        return 'Please go back and choose a category';
    }
  };

  const acceptableFiles = category => {
    switch (category) {
      case lib.MetadataCategory.Audio:
        return '.mp3,.flac,.wav';

      case lib.MetadataCategory.Image:
        return '.png,.jpg,.gif';

      case lib.MetadataCategory.Video:
        return '.mp4,.mov,.webm';

      case lib.MetadataCategory.VR:
        return '.glb';

      case lib.MetadataCategory.HTML:
        return '.html';

      default:
        return '';
    }
  };

  const {
    category
  } = props.attributes.properties;
  const urlPlaceholder = `http://example.com/path/to/${category === lib.MetadataCategory.Image ? 'image' : 'file'}`;
  return /*#__PURE__*/(0,jsx_runtime_.jsxs)(jsx_runtime_.Fragment, {
    children: [/*#__PURE__*/(0,jsx_runtime_.jsxs)(external_antd_.Row, {
      className: "call-to-action",
      children: [/*#__PURE__*/jsx_runtime_.jsx("h2", {
        children: "Now, let's upload your creation"
      }), /*#__PURE__*/jsx_runtime_.jsx("p", {
        style: {
          fontSize: '1.2rem'
        },
        children: "Your file will be uploaded to the decentralized web via Arweave. Depending on file type, can take up to 1 minute. Arweave is a new type of storage that backs data with sustainable and perpetual endowments, allowing users and developers to truly store data forever \u2013 for the very first time."
      })]
    }), /*#__PURE__*/(0,jsx_runtime_.jsxs)(external_antd_.Row, {
      className: "content-action",
      children: [/*#__PURE__*/jsx_runtime_.jsx("h3", {
        children: "Upload a cover image (PNG, JPG, GIF, SVG)"
      }), /*#__PURE__*/(0,jsx_runtime_.jsxs)(Dragger, {
        accept: ".png,.jpg,.gif,.mp4,.svg",
        style: {
          padding: 20,
          background: 'rgba(255, 255, 255, 0.08)'
        },
        multiple: false,
        onRemove: () => {
          setMainFile(undefined);
          setCoverFile(undefined);
        },
        customRequest: info => {
          var _info$onSuccess;

          // dont upload files here, handled outside of the control
          info === null || info === void 0 ? void 0 : (_info$onSuccess = info.onSuccess) === null || _info$onSuccess === void 0 ? void 0 : _info$onSuccess.call(info, {}, null);
        },
        fileList: coverFile ? [coverFile] : [],
        onChange: async info => {
          const file = info.file.originFileObj;

          if (!file) {
            return;
          }

          const sizeKB = file.size / 1024;

          if (sizeKB < 25) {
            setCoverArtError(`The file ${file.name} is too small. It is ${Math.round(10 * sizeKB) / 10}KB but should be at least 25KB.`);
            return;
          }

          setCoverFile(file);
          setCoverArtError(undefined);
        },
        children: [/*#__PURE__*/jsx_runtime_.jsx("div", {
          className: "ant-upload-drag-icon",
          children: /*#__PURE__*/jsx_runtime_.jsx("h3", {
            style: {
              fontWeight: 700
            },
            children: "Upload your cover image (PNG, JPG, GIF, SVG)"
          })
        }), coverArtError ? /*#__PURE__*/jsx_runtime_.jsx(Text, {
          type: "danger",
          children: coverArtError
        }) : /*#__PURE__*/jsx_runtime_.jsx("p", {
          className: "ant-upload-text",
          style: {
            color: '#6d6d6d'
          },
          children: "Drag and drop, or click to browse"
        })]
      })]
    }), ((_props$attributes$pro = props.attributes.properties) === null || _props$attributes$pro === void 0 ? void 0 : _props$attributes$pro.category) !== lib.MetadataCategory.Image && /*#__PURE__*/(0,jsx_runtime_.jsxs)(external_antd_.Row, {
      className: "content-action",
      style: {
        marginBottom: 5,
        marginTop: 30
      },
      children: [/*#__PURE__*/jsx_runtime_.jsx("h3", {
        children: uploadMsg((_props$attributes$pro2 = props.attributes.properties) === null || _props$attributes$pro2 === void 0 ? void 0 : _props$attributes$pro2.category)
      }), /*#__PURE__*/(0,jsx_runtime_.jsxs)(Dragger, {
        accept: acceptableFiles((_props$attributes$pro3 = props.attributes.properties) === null || _props$attributes$pro3 === void 0 ? void 0 : _props$attributes$pro3.category),
        style: {
          padding: 20,
          background: 'rgba(255, 255, 255, 0.08)'
        },
        multiple: false,
        customRequest: info => {
          var _info$onSuccess2;

          // dont upload files here, handled outside of the control
          info === null || info === void 0 ? void 0 : (_info$onSuccess2 = info.onSuccess) === null || _info$onSuccess2 === void 0 ? void 0 : _info$onSuccess2.call(info, {}, null);
        },
        fileList: mainFile ? [mainFile] : [],
        onChange: async info => {
          const file = info.file.originFileObj; // Reset image URL

          setCustomURL('');
          setCustomURLErr('');
          if (file) setMainFile(file);
        },
        onRemove: () => {
          setMainFile(undefined);
        },
        children: [/*#__PURE__*/jsx_runtime_.jsx("div", {
          className: "ant-upload-drag-icon",
          children: /*#__PURE__*/jsx_runtime_.jsx("h3", {
            style: {
              fontWeight: 700
            },
            children: "Upload your creation"
          })
        }), /*#__PURE__*/jsx_runtime_.jsx("p", {
          className: "ant-upload-text",
          style: {
            color: '#6d6d6d'
          },
          children: "Drag and drop, or click to browse"
        })]
      })]
    }), /*#__PURE__*/jsx_runtime_.jsx(external_antd_.Form.Item, {
      className: 'url-form-action',
      style: {
        width: '100%',
        flexDirection: 'column',
        paddingTop: 30,
        marginBottom: 4
      },
      label: /*#__PURE__*/jsx_runtime_.jsx("h3", {
        children: "OR use absolute URL to content"
      }),
      labelAlign: "left",
      colon: false,
      validateStatus: customURLErr ? 'error' : 'success',
      help: customURLErr,
      children: /*#__PURE__*/jsx_runtime_.jsx(external_antd_.Input, {
        disabled: !!mainFile,
        placeholder: urlPlaceholder,
        value: customURL,
        onChange: ev => setCustomURL(ev.target.value),
        onFocus: () => setCustomURLErr(''),
        onBlur: () => {
          if (!customURL) {
            setCustomURLErr('');
            return;
          }

          try {
            // Validate URL and save
            new URL(customURL);
            setCustomURL(customURL);
            setCustomURLErr('');
          } catch (e) {
            console.error(e);
            setCustomURLErr('Please enter a valid absolute URL');
          }
        }
      })
    }), /*#__PURE__*/jsx_runtime_.jsx(external_antd_.Row, {
      children: /*#__PURE__*/jsx_runtime_.jsx(external_antd_.Button, {
        type: "primary",
        size: "large",
        disabled: disableContinue,
        onClick: async () => {
          var _props$attributes$pro4;

          props.setAttributes(artCreate_objectSpread(artCreate_objectSpread({}, props.attributes), {}, {
            properties: artCreate_objectSpread(artCreate_objectSpread({}, props.attributes.properties), {}, {
              files: [coverFile, mainFile, customURL].filter(f => f).map(f => {
                const uri = typeof f === 'string' ? f : (f === null || f === void 0 ? void 0 : f.name) || '';
                const type = typeof f === 'string' || !f ? 'unknown' : f.type || getLast(f.name.split('.')) || 'unknown';
                return {
                  uri,
                  type
                };
              })
            }),
            image: (coverFile === null || coverFile === void 0 ? void 0 : coverFile.name) || customURL || '',
            animation_url: ((_props$attributes$pro4 = props.attributes.properties) === null || _props$attributes$pro4 === void 0 ? void 0 : _props$attributes$pro4.category) !== lib.MetadataCategory.Image && customURL ? customURL : mainFile && mainFile.name
          }));
          const url = await fetch(customURL).then(res => res.blob());
          const files = [coverFile, mainFile, customURL ? new File([url], customURL) : ''].filter(f => f);
          props.setFiles(files);
          props.confirm();
        },
        style: {
          marginTop: 24
        },
        className: "action-btn",
        children: "Continue to Mint"
      })
    })]
  });
};

const useArtworkFiles = (files, attributes) => {
  const {
    0: data,
    1: setData
  } = (0,external_react_.useState)({
    image: '',
    animation_url: ''
  });
  (0,external_react_.useEffect)(() => {
    if (attributes.image) {
      const file = files.find(f => f.name === attributes.image);

      if (file) {
        const reader = new FileReader();

        reader.onload = function (event) {
          setData(data => {
            var _event$target;

            return artCreate_objectSpread(artCreate_objectSpread({}, data || {}), {}, {
              image: ((_event$target = event.target) === null || _event$target === void 0 ? void 0 : _event$target.result) || ''
            });
          });
        };

        if (file) reader.readAsDataURL(file);
      }
    }

    if (attributes.animation_url) {
      const file = files.find(f => f.name === attributes.animation_url);

      if (file) {
        const reader = new FileReader();

        reader.onload = function (event) {
          setData(data => {
            var _event$target2;

            return artCreate_objectSpread(artCreate_objectSpread({}, data || {}), {}, {
              animation_url: ((_event$target2 = event.target) === null || _event$target2 === void 0 ? void 0 : _event$target2.result) || ''
            });
          });
        };

        if (file) reader.readAsDataURL(file);
      }
    }
  }, [files, attributes]);
  return data;
};

const InfoStep = props => {
  var _props$attributes$pro5;

  const {
    image
  } = useArtworkFiles(props.files, props.attributes);
  const [form] = external_antd_.Form.useForm();
  return /*#__PURE__*/(0,jsx_runtime_.jsxs)(jsx_runtime_.Fragment, {
    children: [/*#__PURE__*/(0,jsx_runtime_.jsxs)(external_antd_.Row, {
      className: "call-to-action",
      children: [/*#__PURE__*/jsx_runtime_.jsx("h2", {
        children: "Describe your item"
      }), /*#__PURE__*/jsx_runtime_.jsx("p", {
        children: "Provide detailed description of your creative process to engage with your audience."
      })]
    }), /*#__PURE__*/(0,jsx_runtime_.jsxs)(external_antd_.Row, {
      className: "content-action",
      justify: "space-around",
      children: [/*#__PURE__*/jsx_runtime_.jsx(external_antd_.Col, {
        children: props.attributes.image && /*#__PURE__*/jsx_runtime_.jsx(ArtCard, {
          image: image,
          animationURL: props.attributes.animation_url,
          category: (_props$attributes$pro5 = props.attributes.properties) === null || _props$attributes$pro5 === void 0 ? void 0 : _props$attributes$pro5.category,
          name: props.attributes.name,
          symbol: props.attributes.symbol,
          small: true,
          artView: !(props.files.length > 1),
          className: "art-create-card"
        })
      }), /*#__PURE__*/(0,jsx_runtime_.jsxs)(external_antd_.Col, {
        className: "section",
        style: {
          minWidth: 300
        },
        children: [/*#__PURE__*/(0,jsx_runtime_.jsxs)("label", {
          className: "action-field",
          children: [/*#__PURE__*/jsx_runtime_.jsx("span", {
            className: "field-title",
            children: "Title"
          }), /*#__PURE__*/jsx_runtime_.jsx(external_antd_.Input, {
            autoFocus: true,
            className: "input",
            placeholder: "Max 50 characters",
            maxLength: 50,
            allowClear: true,
            value: props.attributes.name,
            onChange: info => props.setAttributes(artCreate_objectSpread(artCreate_objectSpread({}, props.attributes), {}, {
              name: info.target.value
            }))
          })]
        }), /*#__PURE__*/(0,jsx_runtime_.jsxs)("label", {
          className: "action-field",
          children: [/*#__PURE__*/jsx_runtime_.jsx("span", {
            className: "field-title",
            children: "Symbol"
          }), /*#__PURE__*/jsx_runtime_.jsx(external_antd_.Input, {
            className: "input",
            placeholder: "Max 10 characters",
            maxLength: 10,
            allowClear: true,
            value: props.attributes.symbol,
            onChange: info => props.setAttributes(artCreate_objectSpread(artCreate_objectSpread({}, props.attributes), {}, {
              symbol: info.target.value
            }))
          })]
        }), /*#__PURE__*/(0,jsx_runtime_.jsxs)("label", {
          className: "action-field",
          children: [/*#__PURE__*/jsx_runtime_.jsx("span", {
            className: "field-title",
            children: "Description"
          }), /*#__PURE__*/jsx_runtime_.jsx(external_antd_.Input.TextArea, {
            className: "input textarea",
            placeholder: "Max 500 characters",
            maxLength: 500,
            value: props.attributes.description,
            onChange: info => props.setAttributes(artCreate_objectSpread(artCreate_objectSpread({}, props.attributes), {}, {
              description: info.target.value
            })),
            allowClear: true
          })]
        }), /*#__PURE__*/(0,jsx_runtime_.jsxs)("label", {
          className: "action-field",
          children: [/*#__PURE__*/jsx_runtime_.jsx("span", {
            className: "field-title",
            children: "Maximum Supply"
          }), /*#__PURE__*/jsx_runtime_.jsx(external_antd_.InputNumber, {
            placeholder: "Quantity",
            onChange: val => {
              props.setAttributes(artCreate_objectSpread(artCreate_objectSpread({}, props.attributes), {}, {
                properties: artCreate_objectSpread(artCreate_objectSpread({}, props.attributes.properties), {}, {
                  maxSupply: val
                })
              }));
            },
            className: "royalties-input"
          })]
        }), /*#__PURE__*/jsx_runtime_.jsx("label", {
          className: "action-field",
          children: /*#__PURE__*/jsx_runtime_.jsx("span", {
            className: "field-title",
            children: "Attributes"
          })
        }), /*#__PURE__*/jsx_runtime_.jsx(external_antd_.Form, {
          name: "dynamic_attributes",
          form: form,
          autoComplete: "off",
          children: /*#__PURE__*/jsx_runtime_.jsx(external_antd_.Form.List, {
            name: "attributes",
            children: (fields, {
              add,
              remove
            }) => /*#__PURE__*/(0,jsx_runtime_.jsxs)(jsx_runtime_.Fragment, {
              children: [fields.map(({
                key,
                name
              }) => /*#__PURE__*/(0,jsx_runtime_.jsxs)(external_antd_.Space, {
                align: "baseline",
                children: [/*#__PURE__*/jsx_runtime_.jsx(external_antd_.Form.Item, {
                  name: [name, 'trait_type'],
                  hasFeedback: true,
                  children: /*#__PURE__*/jsx_runtime_.jsx(external_antd_.Input, {
                    placeholder: "trait_type (Optional)"
                  })
                }), /*#__PURE__*/jsx_runtime_.jsx(external_antd_.Form.Item, {
                  name: [name, 'value'],
                  rules: [{
                    required: true,
                    message: 'Missing value'
                  }],
                  hasFeedback: true,
                  children: /*#__PURE__*/jsx_runtime_.jsx(external_antd_.Input, {
                    placeholder: "value"
                  })
                }), /*#__PURE__*/jsx_runtime_.jsx(external_antd_.Form.Item, {
                  name: [name, 'display_type'],
                  hasFeedback: true,
                  children: /*#__PURE__*/jsx_runtime_.jsx(external_antd_.Input, {
                    placeholder: "display_type (Optional)"
                  })
                }), /*#__PURE__*/jsx_runtime_.jsx(icons_.MinusCircleOutlined, {
                  onClick: () => remove(name)
                })]
              }, key)), /*#__PURE__*/jsx_runtime_.jsx(external_antd_.Form.Item, {
                children: /*#__PURE__*/jsx_runtime_.jsx(external_antd_.Button, {
                  type: "dashed",
                  onClick: () => add(),
                  block: true,
                  icon: /*#__PURE__*/jsx_runtime_.jsx(icons_.PlusOutlined, {}),
                  children: "Add attribute"
                })
              })]
            })
          })
        })]
      })]
    }), /*#__PURE__*/jsx_runtime_.jsx(external_antd_.Row, {
      children: /*#__PURE__*/jsx_runtime_.jsx(external_antd_.Button, {
        type: "primary",
        size: "large",
        onClick: () => {
          form.validateFields().then(values => {
            const nftAttributes = values.attributes; // value is number if possible

            for (const nftAttribute of nftAttributes || []) {
              const newValue = Number(nftAttribute.value);

              if (!isNaN(newValue)) {
                nftAttribute.value = newValue;
              }
            }

            console.log('Adding NFT attributes:', nftAttributes);
            props.setAttributes(artCreate_objectSpread(artCreate_objectSpread({}, props.attributes), {}, {
              attributes: nftAttributes
            }));
            props.confirm();
          });
        },
        className: "action-btn",
        children: "Continue to royalties"
      })
    })]
  });
};

const RoyaltiesSplitter = props => {
  return /*#__PURE__*/jsx_runtime_.jsx(external_antd_.Col, {
    children: /*#__PURE__*/jsx_runtime_.jsx(external_antd_.Row, {
      gutter: [0, 24],
      children: props.creators.map((creator, idx) => {
        const royalty = props.royalties.find(royalty => royalty.creatorKey === creator.key);
        if (!royalty) return null;
        const amt = royalty.amount;

        const handleChangeShare = newAmt => {
          props.setRoyalties(props.royalties.map(_royalty => {
            return artCreate_objectSpread(artCreate_objectSpread({}, _royalty), {}, {
              amount: _royalty.creatorKey === royalty.creatorKey ? newAmt : _royalty.amount
            });
          }));
        };

        return /*#__PURE__*/jsx_runtime_.jsx(external_antd_.Col, {
          span: 24,
          children: /*#__PURE__*/(0,jsx_runtime_.jsxs)(external_antd_.Row, {
            align: "middle",
            gutter: [0, 16],
            style: {
              margin: '5px auto'
            },
            children: [/*#__PURE__*/jsx_runtime_.jsx(external_antd_.Col, {
              span: 4,
              style: {
                padding: 10
              },
              children: creator.label
            }), /*#__PURE__*/jsx_runtime_.jsx(external_antd_.Col, {
              span: 3,
              children: /*#__PURE__*/jsx_runtime_.jsx(external_antd_.InputNumber, {
                min: 0,
                max: 100,
                formatter: value => `${value}%`,
                value: amt,
                parser: value => {
                  var _value$replace;

                  return parseInt((_value$replace = value === null || value === void 0 ? void 0 : value.replace('%', '')) !== null && _value$replace !== void 0 ? _value$replace : '0');
                },
                onChange: handleChangeShare,
                className: "royalties-input"
              })
            }), /*#__PURE__*/jsx_runtime_.jsx(external_antd_.Col, {
              span: 4,
              style: {
                paddingLeft: 12
              },
              children: /*#__PURE__*/jsx_runtime_.jsx(external_antd_.Slider, {
                value: amt,
                onChange: handleChangeShare
              })
            }), props.isShowErrors && amt === 0 && /*#__PURE__*/jsx_runtime_.jsx(external_antd_.Col, {
              style: {
                paddingLeft: 12
              },
              children: /*#__PURE__*/jsx_runtime_.jsx(Text, {
                type: "danger",
                children: "The split percentage for this creator cannot be 0%."
              })
            })]
          })
        }, idx);
      })
    })
  });
};

const RoyaltiesStep = props => {
  // const file = props.attributes.image;
  const {
    publicKey,
    connected
  } = (0,wallet_adapter_react_.useWallet)();
  const {
    0: creators,
    1: setCreators
  } = (0,external_react_.useState)([]);
  const {
    0: fixedCreators,
    1: setFixedCreators
  } = (0,external_react_.useState)([]);
  const {
    0: royalties,
    1: setRoyalties
  } = (0,external_react_.useState)([]);
  const {
    0: totalRoyaltyShares,
    1: setTotalRoyaltiesShare
  } = (0,external_react_.useState)(0);
  const {
    0: showCreatorsModal,
    1: setShowCreatorsModal
  } = (0,external_react_.useState)(false);
  const {
    0: isShowErrors,
    1: setIsShowErrors
  } = (0,external_react_.useState)(false);
  (0,external_react_.useEffect)(() => {
    if (publicKey) {
      const key = publicKey.toBase58();
      setFixedCreators([{
        key,
        label: (0,lib.shortenAddress)(key),
        value: key
      }]);
    }
  }, [connected, setCreators]);
  (0,external_react_.useEffect)(() => {
    setRoyalties([...fixedCreators, ...creators].map(creator => ({
      creatorKey: creator.key,
      amount: Math.trunc(100 / [...fixedCreators, ...creators].length)
    })));
  }, [creators, fixedCreators]);
  (0,external_react_.useEffect)(() => {
    // When royalties changes, sum up all the amounts.
    const total = royalties.reduce((totalShares, royalty) => {
      return totalShares + royalty.amount;
    }, 0);
    setTotalRoyaltiesShare(total);
  }, [royalties]);
  return /*#__PURE__*/(0,jsx_runtime_.jsxs)(jsx_runtime_.Fragment, {
    children: [/*#__PURE__*/(0,jsx_runtime_.jsxs)(external_antd_.Row, {
      className: "call-to-action",
      style: {
        marginBottom: 20
      },
      children: [/*#__PURE__*/jsx_runtime_.jsx("h2", {
        children: "Set royalties and creator splits"
      }), /*#__PURE__*/jsx_runtime_.jsx("p", {
        children: "Royalties ensure that you continue to get compensated for your work after its initial sale."
      })]
    }), /*#__PURE__*/jsx_runtime_.jsx(external_antd_.Row, {
      className: "content-action",
      style: {
        marginBottom: 20
      },
      children: /*#__PURE__*/(0,jsx_runtime_.jsxs)("label", {
        className: "action-field",
        children: [/*#__PURE__*/jsx_runtime_.jsx("span", {
          className: "field-title",
          children: "Royalty Percentage"
        }), /*#__PURE__*/jsx_runtime_.jsx("p", {
          children: "This is how much of each secondary sale will be paid out to the creators."
        }), /*#__PURE__*/jsx_runtime_.jsx(external_antd_.InputNumber, {
          autoFocus: true,
          min: 0,
          max: 100,
          placeholder: "Between 0 and 100",
          onChange: val => {
            props.setAttributes(artCreate_objectSpread(artCreate_objectSpread({}, props.attributes), {}, {
              seller_fee_basis_points: val * 100
            }));
          },
          className: "royalties-input"
        })]
      })
    }), [...fixedCreators, ...creators].length > 0 && /*#__PURE__*/jsx_runtime_.jsx(external_antd_.Row, {
      children: /*#__PURE__*/(0,jsx_runtime_.jsxs)("label", {
        className: "action-field",
        style: {
          width: '100%'
        },
        children: [/*#__PURE__*/jsx_runtime_.jsx("span", {
          className: "field-title",
          children: "Creators Split"
        }), /*#__PURE__*/jsx_runtime_.jsx("p", {
          children: "This is how much of the proceeds from the initial sale and any royalties will be split out amongst the creators."
        }), /*#__PURE__*/jsx_runtime_.jsx(RoyaltiesSplitter, {
          creators: [...fixedCreators, ...creators],
          royalties: royalties,
          setRoyalties: setRoyalties,
          isShowErrors: isShowErrors
        })]
      })
    }), /*#__PURE__*/(0,jsx_runtime_.jsxs)(external_antd_.Row, {
      children: [/*#__PURE__*/(0,jsx_runtime_.jsxs)("span", {
        onClick: () => setShowCreatorsModal(true),
        style: {
          padding: 10,
          marginBottom: 10
        },
        children: [/*#__PURE__*/jsx_runtime_.jsx("span", {
          style: {
            color: 'white',
            fontSize: 25,
            padding: '0px 8px 3px 8px',
            background: 'rgb(57, 57, 57)',
            borderRadius: '50%',
            marginRight: 5,
            verticalAlign: 'middle'
          },
          children: "+"
        }), /*#__PURE__*/jsx_runtime_.jsx("span", {
          style: {
            color: 'rgba(255, 255, 255, 0.7)',
            verticalAlign: 'middle',
            lineHeight: 1
          },
          children: "Add another creator"
        })]
      }), /*#__PURE__*/jsx_runtime_.jsx(lib.MetaplexModal, {
        visible: showCreatorsModal,
        onCancel: () => setShowCreatorsModal(false),
        children: /*#__PURE__*/(0,jsx_runtime_.jsxs)("label", {
          className: "action-field",
          style: {
            width: '100%'
          },
          children: [/*#__PURE__*/jsx_runtime_.jsx("span", {
            className: "field-title",
            children: "Creators"
          }), /*#__PURE__*/jsx_runtime_.jsx(UserSearch, {
            setCreators: setCreators
          })]
        })
      })]
    }), isShowErrors && totalRoyaltyShares !== 100 && /*#__PURE__*/jsx_runtime_.jsx(external_antd_.Row, {
      children: /*#__PURE__*/(0,jsx_runtime_.jsxs)(Text, {
        type: "danger",
        style: {
          paddingBottom: 14
        },
        children: ["The split percentages for each creator must add up to 100%. Current total split percentage is ", totalRoyaltyShares, "%."]
      })
    }), /*#__PURE__*/jsx_runtime_.jsx(external_antd_.Row, {
      children: /*#__PURE__*/jsx_runtime_.jsx(external_antd_.Button, {
        type: "primary",
        size: "large",
        onClick: () => {
          // Find all royalties that are invalid (0)
          const zeroedRoyalties = royalties.filter(royalty => royalty.amount === 0);

          if (zeroedRoyalties.length !== 0 || totalRoyaltyShares !== 100) {
            // Contains a share that is 0 or total shares does not equal 100, show errors.
            setIsShowErrors(true);
            return;
          }

          const creatorStructs = [...fixedCreators, ...creators].map(c => {
            var _royalties$find;

            return new lib.Creator({
              address: c.value,
              verified: c.value === (publicKey === null || publicKey === void 0 ? void 0 : publicKey.toBase58()),
              share: ((_royalties$find = royalties.find(r => r.creatorKey === c.value)) === null || _royalties$find === void 0 ? void 0 : _royalties$find.amount) || Math.round(100 / royalties.length)
            });
          });
          const share = creatorStructs.reduce((acc, el) => acc += el.share, 0);

          if (share > 100 && creatorStructs.length) {
            creatorStructs[0].share -= share - 100;
          }

          props.setAttributes(artCreate_objectSpread(artCreate_objectSpread({}, props.attributes), {}, {
            creators: creatorStructs
          }));
          props.confirm();
        },
        className: "action-btn",
        children: "Continue to review"
      })
    })]
  });
};

const LaunchStep = props => {
  var _props$attributes$pro6, _props$files$;

  const {
    0: cost,
    1: setCost
  } = (0,external_react_.useState)(0);
  const {
    image
  } = useArtworkFiles(props.files, props.attributes);
  const files = props.files;
  const metadata = props.attributes;
  (0,external_react_.useEffect)(() => {
    const rentCall = Promise.all([props.connection.getMinimumBalanceForRentExemption(spl_token_.MintLayout.span), props.connection.getMinimumBalanceForRentExemption(lib.MAX_METADATA_LEN)]);
    if (files.length) (0,lib.getAssetCostToStore)([...files, new File([JSON.stringify(metadata)], 'metadata.json')]).then(async lamports => {
      const sol = lamports / lib.LAMPORT_MULTIPLIER; // TODO: cache this and batch in one call

      const [mintRent, metadataRent] = await rentCall; // const uriStr = 'x';
      // let uriBuilder = '';
      // for (let i = 0; i < MAX_URI_LENGTH; i++) {
      //   uriBuilder += uriStr;
      // }

      const additionalSol = (metadataRent + mintRent) / lib.LAMPORT_MULTIPLIER; // TODO: add fees based on number of transactions and signers

      setCost(sol + additionalSol);
    });
  }, [files, metadata, setCost]);
  return /*#__PURE__*/(0,jsx_runtime_.jsxs)(jsx_runtime_.Fragment, {
    children: [/*#__PURE__*/(0,jsx_runtime_.jsxs)(external_antd_.Row, {
      className: "call-to-action",
      children: [/*#__PURE__*/jsx_runtime_.jsx("h2", {
        children: "Launch your creation"
      }), /*#__PURE__*/jsx_runtime_.jsx("p", {
        children: "Provide detailed description of your creative process to engage with your audience."
      })]
    }), /*#__PURE__*/(0,jsx_runtime_.jsxs)(external_antd_.Row, {
      className: "content-action",
      justify: "space-around",
      children: [/*#__PURE__*/jsx_runtime_.jsx(external_antd_.Col, {
        children: props.attributes.image && /*#__PURE__*/jsx_runtime_.jsx(ArtCard, {
          image: image,
          animationURL: props.attributes.animation_url,
          category: (_props$attributes$pro6 = props.attributes.properties) === null || _props$attributes$pro6 === void 0 ? void 0 : _props$attributes$pro6.category,
          name: props.attributes.name,
          symbol: props.attributes.symbol,
          small: true,
          artView: ((_props$files$ = props.files[1]) === null || _props$files$ === void 0 ? void 0 : _props$files$.type) === 'unknown',
          className: "art-create-card"
        })
      }), /*#__PURE__*/(0,jsx_runtime_.jsxs)(external_antd_.Col, {
        className: "section",
        style: {
          minWidth: 300
        },
        children: [/*#__PURE__*/jsx_runtime_.jsx(external_antd_.Statistic, {
          className: "create-statistic",
          title: "Royalty Percentage",
          value: props.attributes.seller_fee_basis_points / 100,
          precision: 2,
          suffix: "%"
        }), cost ? /*#__PURE__*/jsx_runtime_.jsx(AmountLabel, {
          title: "Cost to Create",
          amount: cost.toFixed(5),
          tokenInfo: useTokenList().tokenMap.get(lib.WRAPPED_SOL_MINT.toString())
        }) : /*#__PURE__*/jsx_runtime_.jsx(external_antd_.Spin, {})]
      })]
    }), /*#__PURE__*/(0,jsx_runtime_.jsxs)(external_antd_.Row, {
      children: [/*#__PURE__*/jsx_runtime_.jsx(external_antd_.Button, {
        type: "primary",
        size: "large",
        onClick: props.confirm,
        className: "action-btn",
        children: "Pay with SOL"
      }), /*#__PURE__*/jsx_runtime_.jsx(external_antd_.Button, {
        disabled: true,
        size: "large",
        onClick: props.confirm,
        className: "action-btn",
        children: "Pay with Credit Card"
      })]
    })]
  });
};

const WaitingStep = props => {
  (0,external_react_.useEffect)(() => {
    const func = async () => {
      await props.mint();
      props.confirm();
    };

    func();
  }, []);

  const setIconForStep = (currentStep, componentStep) => {
    if (currentStep === componentStep) {
      return /*#__PURE__*/jsx_runtime_.jsx(icons_.LoadingOutlined, {});
    }

    return null;
  };

  return /*#__PURE__*/(0,jsx_runtime_.jsxs)("div", {
    style: {
      marginTop: 70,
      display: 'flex',
      flexDirection: 'column',
      alignItems: 'center'
    },
    children: [/*#__PURE__*/jsx_runtime_.jsx(external_antd_.Spin, {
      size: "large"
    }), /*#__PURE__*/jsx_runtime_.jsx(external_antd_.Card, {
      children: /*#__PURE__*/(0,jsx_runtime_.jsxs)(external_antd_.Steps, {
        direction: "vertical",
        current: props.step,
        children: [/*#__PURE__*/jsx_runtime_.jsx(Step, {
          className: 'white-description',
          title: "Minting",
          description: "Starting Mint Process",
          icon: setIconForStep(props.step, 0)
        }), /*#__PURE__*/jsx_runtime_.jsx(Step, {
          className: 'white-description',
          title: "Preparing Assets",
          icon: setIconForStep(props.step, 1)
        }), /*#__PURE__*/jsx_runtime_.jsx(Step, {
          className: 'white-description',
          title: "Signing Metadata Transaction",
          description: "Approve the transaction from your wallet",
          icon: setIconForStep(props.step, 2)
        }), /*#__PURE__*/jsx_runtime_.jsx(Step, {
          className: 'white-description',
          title: "Sending Transaction to Solana",
          description: "This will take a few seconds.",
          icon: setIconForStep(props.step, 3)
        }), /*#__PURE__*/jsx_runtime_.jsx(Step, {
          className: 'white-description',
          title: "Waiting for Initial Confirmation",
          icon: setIconForStep(props.step, 4)
        }), /*#__PURE__*/jsx_runtime_.jsx(Step, {
          className: 'white-description',
          title: "Waiting for Final Confirmation",
          icon: setIconForStep(props.step, 5)
        }), /*#__PURE__*/jsx_runtime_.jsx(Step, {
          className: 'white-description',
          title: "Uploading to Arweave",
          icon: setIconForStep(props.step, 6)
        }), /*#__PURE__*/jsx_runtime_.jsx(Step, {
          className: 'white-description',
          title: "Updating Metadata",
          icon: setIconForStep(props.step, 7)
        }), /*#__PURE__*/jsx_runtime_.jsx(Step, {
          className: 'white-description',
          title: "Signing Token Transaction",
          description: "Approve the final transaction from your wallet",
          icon: setIconForStep(props.step, 8)
        })]
      })
    })]
  });
};

const Congrats = props => {
  const history = (0,external_react_router_dom_.useHistory)();

  const newTweetURL = () => {
    var _props$nft;

    const params = {
      text: "I've created a new NFT artwork on Metaplex, check it out!",
      url: `${window.location.origin}/#/art/${(_props$nft = props.nft) === null || _props$nft === void 0 ? void 0 : _props$nft.metadataAccount.toString()}`,
      hashtags: 'NFT,Crypto,Metaplex',
      // via: "Metaplex",
      related: 'Metaplex,Solana'
    };
    const queryParams = new URLSearchParams(params).toString();
    return `https://twitter.com/intent/tweet?${queryParams}`;
  };

  if (props.alert) {
    // TODO  - properly reset this components state on error
    return /*#__PURE__*/(0,jsx_runtime_.jsxs)(jsx_runtime_.Fragment, {
      children: [/*#__PURE__*/jsx_runtime_.jsx("div", {
        className: "waiting-title",
        children: "Sorry, there was an error!"
      }), /*#__PURE__*/jsx_runtime_.jsx("p", {
        children: props.alert
      }), /*#__PURE__*/jsx_runtime_.jsx(external_antd_.Button, {
        onClick: () => history.push('/art/create'),
        children: "Back to Create NFT"
      })]
    });
  }

  return /*#__PURE__*/(0,jsx_runtime_.jsxs)(jsx_runtime_.Fragment, {
    children: [/*#__PURE__*/jsx_runtime_.jsx("div", {
      className: "waiting-title",
      children: "Congratulations, you created an NFT!"
    }), /*#__PURE__*/(0,jsx_runtime_.jsxs)("div", {
      className: "congrats-button-container",
      children: [/*#__PURE__*/(0,jsx_runtime_.jsxs)(external_antd_.Button, {
        className: "metaplex-button",
        onClick: () => window.open(newTweetURL(), '_blank'),
        children: [/*#__PURE__*/jsx_runtime_.jsx("span", {
          children: "Share it on Twitter"
        }), /*#__PURE__*/jsx_runtime_.jsx("span", {
          children: ">"
        })]
      }), /*#__PURE__*/(0,jsx_runtime_.jsxs)(external_antd_.Button, {
        className: "metaplex-button",
        onClick: () => {
          var _props$nft2;

          return history.push(`/art/${(_props$nft2 = props.nft) === null || _props$nft2 === void 0 ? void 0 : _props$nft2.metadataAccount.toString()}`);
        },
        children: [/*#__PURE__*/jsx_runtime_.jsx("span", {
          children: "See it in your collection"
        }), /*#__PURE__*/jsx_runtime_.jsx("span", {
          children: ">"
        })]
      }), /*#__PURE__*/(0,jsx_runtime_.jsxs)(external_antd_.Button, {
        className: "metaplex-button",
        onClick: () => history.push('/auction/create'),
        children: [/*#__PURE__*/jsx_runtime_.jsx("span", {
          children: "Sell it via auction"
        }), /*#__PURE__*/jsx_runtime_.jsx("span", {
          children: ">"
        })]
      })]
    }), /*#__PURE__*/jsx_runtime_.jsx(Confetti, {})]
  });
};
;// CONCATENATED MODULE: ./src/views/artist/index.tsx









const ArtistView = () => {
  const {
    id
  } = (0,external_react_router_dom_.useParams)();
  const creator = useCreator(id);
  const artwork = useCreatorArts(id);

  const artworkGrid = /*#__PURE__*/jsx_runtime_.jsx("div", {
    className: "artwork-grid",
    children: artwork.length > 0 ? artwork.map((m, idx) => {
      const id = m.pubkey;
      return /*#__PURE__*/jsx_runtime_.jsx(external_react_router_dom_.Link, {
        to: `/art/${id}`,
        children: /*#__PURE__*/jsx_runtime_.jsx(ArtCard, {
          pubkey: m.pubkey,
          preview: false,
          artView: true
        }, id)
      }, idx);
    }) : [...Array(6)].map((_, idx) => /*#__PURE__*/jsx_runtime_.jsx(CardLoader, {}, idx))
  });

  return /*#__PURE__*/jsx_runtime_.jsx(jsx_runtime_.Fragment, {
    children: /*#__PURE__*/(0,jsx_runtime_.jsxs)(external_antd_.Col, {
      children: [/*#__PURE__*/jsx_runtime_.jsx(external_antd_.Divider, {}), /*#__PURE__*/jsx_runtime_.jsx(external_antd_.Row, {
        style: {
          margin: '0 30px',
          textAlign: 'left',
          fontSize: '1.4rem'
        },
        children: /*#__PURE__*/(0,jsx_runtime_.jsxs)(external_antd_.Col, {
          span: 24,
          children: [/*#__PURE__*/jsx_runtime_.jsx("h2", {
            children: (creator === null || creator === void 0 ? void 0 : creator.info.name) || (creator === null || creator === void 0 ? void 0 : creator.info.address)
          }), /*#__PURE__*/jsx_runtime_.jsx("br", {}), /*#__PURE__*/jsx_runtime_.jsx("div", {
            className: "info-header",
            children: "ABOUT THE CREATOR"
          }), /*#__PURE__*/jsx_runtime_.jsx("div", {
            className: "info-content",
            children: creator === null || creator === void 0 ? void 0 : creator.info.description
          }), /*#__PURE__*/jsx_runtime_.jsx("br", {}), /*#__PURE__*/jsx_runtime_.jsx("div", {
            className: "info-header",
            children: "Art Created"
          }), artworkGrid]
        })
      })]
    })
  });
};
// EXTERNAL MODULE: external "react-masonry-css"
var external_react_masonry_css_ = __webpack_require__(1968);
var external_react_masonry_css_default = /*#__PURE__*/__webpack_require__.n(external_react_masonry_css_);
;// CONCATENATED MODULE: ./src/components/ArtistCard/index.tsx







const ArtistCard = ({
  artist
}) => {
  return /*#__PURE__*/jsx_runtime_.jsx(external_antd_.Card, {
    hoverable: true,
    className: `artist-card`,
    cover: /*#__PURE__*/jsx_runtime_.jsx("div", {
      className: "header-container",
      children: artist.background ? /*#__PURE__*/jsx_runtime_.jsx("img", {
        src: artist.background
      }) : null
    }),
    bordered: false,
    children: /*#__PURE__*/(0,jsx_runtime_.jsxs)(jsx_runtime_.Fragment, {
      children: [/*#__PURE__*/jsx_runtime_.jsx(MetaAvatar, {
        creators: [artist],
        size: 64
      }), /*#__PURE__*/jsx_runtime_.jsx("div", {
        className: "artist-card-name",
        children: artist.name || (0,lib.shortenAddress)(artist.address || '')
      }), /*#__PURE__*/jsx_runtime_.jsx("div", {
        className: "artist-card-description",
        children: artist.about
      })]
    })
  });
};
;// CONCATENATED MODULE: ./src/views/artists/index.tsx







const {
  Content: artists_Content
} = external_antd_.Layout;
const ArtistsView = () => {
  const {
    whitelistedCreatorsByCreator
  } = (0,meta.useMeta)();
  const breakpointColumnsObj = {
    default: 4,
    1100: 3,
    700: 2,
    500: 1
  };
  const items = Object.values(whitelistedCreatorsByCreator);

  const artistGrid = /*#__PURE__*/jsx_runtime_.jsx((external_react_masonry_css_default()), {
    breakpointCols: breakpointColumnsObj,
    className: "my-masonry-grid artists-masonry",
    columnClassName: "my-masonry-grid_column",
    children: items.map((m, idx) => {
      const id = m.info.address;
      return /*#__PURE__*/jsx_runtime_.jsx(external_react_router_dom_.Link, {
        to: `/artists/${id}`,
        children: /*#__PURE__*/jsx_runtime_.jsx(ArtistCard, {
          artist: {
            address: m.info.address,
            name: m.info.name || '',
            image: m.info.image || '',
            link: m.info.twitter || '',
            background: m.info.background || ''
          }
        }, id)
      }, idx);
    })
  });

  return /*#__PURE__*/jsx_runtime_.jsx(external_antd_.Layout, {
    style: {
      margin: 0,
      marginTop: 30
    },
    children: /*#__PURE__*/jsx_runtime_.jsx(artists_Content, {
      style: {
        display: 'flex',
        flexWrap: 'wrap'
      },
      children: /*#__PURE__*/jsx_runtime_.jsx(external_antd_.Col, {
        style: {
          width: '100%',
          marginTop: 10
        },
        children: artistGrid
      })
    })
  });
};
// EXTERNAL MODULE: external "moment"
var external_moment_ = __webpack_require__(2470);
var external_moment_default = /*#__PURE__*/__webpack_require__.n(external_moment_);
;// CONCATENATED MODULE: ./src/components/InstructionsModal/index.tsx






const ContentCard = props => {
  const {
    title = '',
    description = '',
    endElement = /*#__PURE__*/jsx_runtime_.jsx("div", {
      className: 'line'
    }),
    imgSrc = ''
  } = props;
  return /*#__PURE__*/(0,jsx_runtime_.jsxs)(external_antd_.Card, {
    cover: /*#__PURE__*/jsx_runtime_.jsx("div", {
      className: 'card-cover',
      children: imgSrc ? /*#__PURE__*/jsx_runtime_.jsx("img", {
        src: imgSrc
      }) : /*#__PURE__*/jsx_runtime_.jsx(icons_.CreditCardOutlined, {
        style: {
          color: 'rgba(179, 136, 245, 1)',
          fontSize: 18
        }
      })
    }),
    children: [/*#__PURE__*/jsx_runtime_.jsx("div", {
      className: 'body-title',
      children: title
    }), /*#__PURE__*/jsx_runtime_.jsx("div", {
      className: 'body-content',
      children: description
    }), endElement]
  });
};
const ModalContent = ({
  children
}) => {
  return /*#__PURE__*/jsx_runtime_.jsx("div", {
    className: "site-card-wrapper",
    children: /*#__PURE__*/(0,jsx_runtime_.jsxs)(external_antd_.Row, {
      gutter: 16,
      children: [/*#__PURE__*/(0,jsx_runtime_.jsxs)(external_antd_.Col, {
        span: 24,
        xl: 8,
        children: [children[0], ' ']
      }), /*#__PURE__*/jsx_runtime_.jsx(external_antd_.Col, {
        span: 24,
        xl: 8,
        children: children[1]
      }), /*#__PURE__*/jsx_runtime_.jsx(external_antd_.Col, {
        span: 24,
        xl: 8,
        children: children[2]
      })]
    })
  });
};
const InstructionsModal = ({
  buttonClassName,
  buttonText,
  modalTitle,
  cardProps,
  onClick
}) => {
  const {
    0: isModalVisible,
    1: setIsModalVisible
  } = (0,external_react_.useState)(false);

  const showModal = () => {
    onClick ? onClick() : null;
    setIsModalVisible(true);
  };

  const handleOk = () => {
    setIsModalVisible(false);
  };

  const handleCancel = () => {
    setIsModalVisible(false);
  };

  return /*#__PURE__*/(0,jsx_runtime_.jsxs)(jsx_runtime_.Fragment, {
    children: [/*#__PURE__*/jsx_runtime_.jsx(external_antd_.Button, {
      className: buttonClassName,
      onClick: showModal,
      children: buttonText
    }), /*#__PURE__*/jsx_runtime_.jsx(external_antd_.Modal, {
      title: modalTitle,
      visible: isModalVisible,
      onOk: handleOk,
      onCancel: handleCancel,
      footer: null,
      className: 'modal-box instructions-modal',
      closeIcon: /*#__PURE__*/jsx_runtime_.jsx("img", {
        src: '/modals/close.svg'
      }),
      children: /*#__PURE__*/(0,jsx_runtime_.jsxs)(ModalContent, {
        children: [/*#__PURE__*/jsx_runtime_.jsx(ContentCard, {
          title: cardProps[0].title,
          description: cardProps[0].description,
          imgSrc: cardProps[0].imgSrc,
          endElement: cardProps[0].endElement
        }), /*#__PURE__*/jsx_runtime_.jsx(ContentCard, {
          title: cardProps[1].title,
          description: cardProps[1].description,
          imgSrc: cardProps[1].imgSrc,
          endElement: cardProps[1].endElement
        }), /*#__PURE__*/jsx_runtime_.jsx(ContentCard, {
          title: cardProps[2].title,
          description: cardProps[2].description,
          imgSrc: cardProps[2].imgSrc,
          endElement: cardProps[2].endElement
        })]
      })
    })]
  });
};
;// CONCATENATED MODULE: ./src/components/HowAuctionsWorkModal/index.tsx




const HowAuctionsWorkModal = ({
  buttonClassName
}) => {
  return /*#__PURE__*/jsx_runtime_.jsx(InstructionsModal, {
    buttonClassName: buttonClassName,
    buttonText: "How Auctions Work",
    modalTitle: "How Auctions Work",
    cardProps: [{
      title: 'Placing a Bid',
      description: `Once you find an NFT you’d like to own, place a bid on the auction page. Keep in mind the amount of SOL you bid will be locked in your wallet for the remainder of the auction.`,
      imgSrc: '/modals/how-auctions-work-1.jpg'
    }, {
      title: 'Winning an Auction',
      description: `Keep an eye on the auctions page (and your notifications) to know when you’ve been outbid, and how the sale is progressing.`,
      imgSrc: '/modals/how-auctions-work-2.jpg'
    }, {
      title: 'Redeeming your NFT',
      description: `If you’re lucky enough to win your NFT auction, you’ll have to redeem it to add it to your wallet. This can be done from the auction, winning notification, or your profile on ${LABELS.STORE_NAME}.`,
      imgSrc: '/modals/how-auctions-work-3.jpg'
    }]
  });
};
;// CONCATENATED MODULE: ./src/components/AuctionCard/hooks/useInstantSaleState.ts


const useInstantSaleState = auctionView => {
  var _wallet$publicKey;

  const wallet = (0,wallet_adapter_react_.useWallet)();
  const {
    isInstantSale,
    auctionManager,
    auction,
    myBidRedemption,
    myBidderPot,
    myBidderMetadata
  } = auctionView;
  const items = auctionView.items;
  let isAlreadyBought = false;
  const isBidCanceled = !!(myBidderMetadata !== null && myBidderMetadata !== void 0 && myBidderMetadata.info.cancelled);
  let canClaimPurchasedItem = false;

  if (auctionView.auction.info.bidState.type == lib.BidStateType.EnglishAuction) {
    for (const item of items) {
      for (const subItem of item) {
        const bidRedeemed = myBidRedemption === null || myBidRedemption === void 0 ? void 0 : myBidRedemption.info.getBidRedeemed(subItem.safetyDeposit.info.order);
        isAlreadyBought = bidRedeemed ? bidRedeemed : false;
        if (isAlreadyBought) break;
      }
    }

    canClaimPurchasedItem = !!(myBidderPot && !isBidCanceled) && !isAlreadyBought;
  } else {
    isAlreadyBought = !!(myBidderPot && isBidCanceled);
    canClaimPurchasedItem = !!(myBidderPot && !isBidCanceled);
  }

  const isOwner = auctionManager.authority === (wallet === null || wallet === void 0 ? void 0 : (_wallet$publicKey = wallet.publicKey) === null || _wallet$publicKey === void 0 ? void 0 : _wallet$publicKey.toBase58());
  const isAuctionEnded = auction.info.endedAt;
  const canClaimItem = !!(isOwner && isAuctionEnded);
  const canEndInstantSale = isOwner && !isAuctionEnded;
  return {
    isInstantSale,
    isAlreadyBought,
    canClaimItem,
    canClaimPurchasedItem,
    canEndInstantSale
  };
};
;// CONCATENATED MODULE: ./src/components/AuctionCard/hooks/useActionButtonContent.ts

const useActionButtonContent = auctionView => {
  const {
    isInstantSale,
    canClaimItem,
    canClaimPurchasedItem,
    canEndInstantSale
  } = useInstantSaleState(auctionView);

  if (!isInstantSale) {
    return 'Place Bid';
  }

  if (canClaimPurchasedItem) {
    return 'Claim Purchase';
  }

  if (canClaimItem) {
    return 'Claim item';
  }

  if (canEndInstantSale) {
    return 'End sale & claim item';
  }

  return 'Buy now';
};
// EXTERNAL MODULE: external "borsh"
var external_borsh_ = __webpack_require__(7384);
;// CONCATENATED MODULE: ./src/models/metaplex/endAuction.ts



async function endAuction(vault, auctionManagerAuthority, instructions) {
  const PROGRAM_IDS = (0,lib.programIds)();
  const store = PROGRAM_IDS.store;

  if (!store) {
    throw new Error('Store not initialized');
  }

  const {
    auctionKey,
    auctionManagerKey
  } = await (0,lib.getAuctionKeys)(vault.toString());
  const auctionExtended = await (0,lib.getAuctionExtended)({
    auctionProgramId: PROGRAM_IDS.auction,
    resource: vault.toString()
  });
  const value = new lib.EndAuctionArgs({
    reveal: null
  });
  const data = Buffer.from((0,external_borsh_.serialize)(lib.SCHEMA, value));
  const keys = [{
    pubkey: (0,lib.toPublicKey)(auctionManagerKey),
    isSigner: false,
    isWritable: true
  }, {
    pubkey: (0,lib.toPublicKey)(auctionKey),
    isSigner: false,
    isWritable: true
  }, {
    pubkey: (0,lib.toPublicKey)(auctionExtended),
    isSigner: false,
    isWritable: false
  }, {
    pubkey: (0,lib.toPublicKey)(auctionManagerAuthority),
    isSigner: true,
    isWritable: false
  }, {
    pubkey: (0,lib.toPublicKey)(store),
    isSigner: false,
    isWritable: false
  }, {
    pubkey: (0,lib.toPublicKey)(PROGRAM_IDS.auction),
    isSigner: false,
    isWritable: false
  }, {
    pubkey: (0,lib.toPublicKey)(web3_js_.SYSVAR_CLOCK_PUBKEY),
    isSigner: false,
    isWritable: false
  }];
  instructions.push(new web3_js_.TransactionInstruction({
    keys,
    programId: (0,lib.toPublicKey)(PROGRAM_IDS.metaplex),
    data
  }));
}
;// CONCATENATED MODULE: ./src/components/AuctionCard/utils/endSale.ts




async function endSale({
  auctionView,
  connection,
  accountByMint,
  bids,
  bidRedemptions,
  prizeTrackingTickets,
  wallet
}) {
  const {
    vault,
    auctionManager
  } = auctionView;
  const endAuctionInstructions = [];
  await endAuction(new web3_js_.PublicKey(vault.pubkey), new web3_js_.PublicKey(auctionManager.authority), endAuctionInstructions);
  const claimInstructions = [];
  const claimSigners = [];
  await claimUnusedPrizes(connection, wallet, auctionView, accountByMint, bids, bidRedemptions, prizeTrackingTickets, claimSigners, claimInstructions);
  const instructions = [endAuctionInstructions, ...claimInstructions];
  const signers = [[], ...claimSigners];
  return (0,lib.sendTransactions)(connection, wallet, instructions, signers);
}
;// CONCATENATED MODULE: ./src/components/Modals/index.tsx



const ModalLayout = ({
  onClose,
  isModalVisible,
  children
}) => {
  return /*#__PURE__*/jsx_runtime_.jsx(external_antd_.Modal, {
    onCancel: onClose,
    footer: null,
    visible: isModalVisible,
    closeIcon: /*#__PURE__*/jsx_runtime_.jsx("img", {
      src: '/modals/close.svg'
    }),
    children: children
  });
};
;// CONCATENATED MODULE: ./src/components/Modals/CongratulationsModal/index.tsx
function CongratulationsModal_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

function CongratulationsModal_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { CongratulationsModal_ownKeys(Object(source), true).forEach(function (key) { CongratulationsModal_defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { CongratulationsModal_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function CongratulationsModal_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }







const CongratulationsContent = ({
  title,
  content,
  buttonText,
  onClickOk,
  onClose,
  extraButtonText,
  onClickExtraButton
}) => {
  const handleClickOk = () => {
    if (onClickOk) onClickOk();
    onClose();
  };

  return /*#__PURE__*/(0,jsx_runtime_.jsxs)("div", {
    className: "congratulations-root",
    children: [/*#__PURE__*/jsx_runtime_.jsx("div", {
      className: "emoji-frame",
      children: /*#__PURE__*/jsx_runtime_.jsx("img", {
        src: "/modals/confetti-emoji.svg"
      })
    }), /*#__PURE__*/jsx_runtime_.jsx("span", {
      className: "title",
      children: title || 'Congratulations'
    }), /*#__PURE__*/jsx_runtime_.jsx("span", {
      className: "content",
      children: content
    }), /*#__PURE__*/jsx_runtime_.jsx(external_antd_.Button, {
      className: "ok-button",
      onClick: handleClickOk,
      children: buttonText || 'Ok'
    }), !!extraButtonText && /*#__PURE__*/jsx_runtime_.jsx(external_antd_.Button, {
      className: "extra-button",
      onClick: onClickExtraButton,
      children: extraButtonText
    })]
  });
};

const CongratulationsModal = _ref => {
  let props = Object.assign({}, _ref);
  return /*#__PURE__*/jsx_runtime_.jsx(ModalLayout, CongratulationsModal_objectSpread(CongratulationsModal_objectSpread({}, props), {}, {
    children: /*#__PURE__*/jsx_runtime_.jsx(CongratulationsContent, CongratulationsModal_objectSpread({}, props))
  }));
};

/* harmony default export */ const Modals_CongratulationsModal = (CongratulationsModal);
;// CONCATENATED MODULE: ./src/components/AuctionCard/index.tsx































async function calculateTotalCostOfRedeemingOtherPeoplesBids(connection, auctionView, bids, bidRedemptions) {
  const accountRentExempt = await connection.getMinimumBalanceForRentExemption(spl_token_.AccountLayout.span);
  const mintRentExempt = await connection.getMinimumBalanceForRentExemption(spl_token_.MintLayout.span);
  const metadataRentExempt = await connection.getMinimumBalanceForRentExemption(lib.MAX_METADATA_LEN);
  const editionRentExempt = await connection.getMinimumBalanceForRentExemption(lib.MAX_EDITION_LEN);
  const prizeTrackingTicketExempt = await connection.getMinimumBalanceForRentExemption(metaplex.MAX_PRIZE_TRACKING_TICKET_SIZE);
  const eligibleParticipations = await findEligibleParticipationBidsForRedemption(auctionView, bids, bidRedemptions);
  const max = auctionView.auction.info.bidState.max.toNumber();
  let totalWinnerItems = 0;

  for (let i = 0; i < max; i++) {
    const winner = auctionView.auction.info.bidState.getWinnerAt(i);

    if (!winner) {
      break;
    } else {
      const bid = bids.find(b => b.info.bidderPubkey === winner);

      if (bid) {
        for (let j = 0; j < auctionView.auctionManager.safetyDepositBoxesExpected.toNumber(); j++) {
          totalWinnerItems += auctionView.auctionManager.getAmountForWinner(i, j).toNumber();
        }
      }
    }
  }

  return (mintRentExempt + accountRentExempt + metadataRentExempt + editionRentExempt + prizeTrackingTicketExempt) * (eligibleParticipations.length + totalWinnerItems);
}

function useGapTickCheck(value, gapTick, gapTime, auctionView, LAMPORTS_PER_MINT) {
  return !!(0,external_react_.useMemo)(() => {
    if (gapTick && value && gapTime && !auctionView.auction.info.ended()) {
      // so we have a gap tick percentage, and a gap tick time, and a value, and we're not ended - are we within gap time?
      const now = external_moment_default()().unix();
      const endedAt = auctionView.auction.info.endedAt;

      if (endedAt) {
        const ended = endedAt.toNumber();

        if (now > ended) {
          const toLamportVal = value * LAMPORTS_PER_MINT; // Ok, we are in gap time, since now is greater than ended and we're not actually an ended auction yt.
          // Check that the bid is at least gapTick % bigger than the next biggest one in the stack.

          for (let i = auctionView.auction.info.bidState.bids.length - 1; i > -1; i--) {
            const bid = auctionView.auction.info.bidState.bids[i];
            const expected = bid.amount.toNumber();

            if (expected < toLamportVal) {
              const higherExpectedAmount = expected * ((100 + gapTick) / 100);
              return higherExpectedAmount > toLamportVal;
            } else if (expected === toLamportVal) {
              // If gap tick is set, no way you can bid in this case - you must bid higher.
              return true;
            }
          }

          return false;
        } else {
          return false;
        }
      }

      return false;
    }
  }, [value, gapTick, gapTime, auctionView]);
}

function useAuctionExtended(auctionView) {
  const {
    0: auctionExtended,
    1: setAuctionExtended
  } = (0,external_react_.useState)();
  const {
    auctionDataExtended
  } = (0,meta.useMeta)();
  (0,external_react_.useMemo)(() => {
    const fn = async () => {
      if (!auctionExtended) {
        const PROGRAM_IDS = (0,lib.programIds)();
        const extendedKey = await (0,lib.getAuctionExtended)({
          auctionProgramId: PROGRAM_IDS.auction,
          resource: auctionView.vault.pubkey
        });
        const extendedValue = auctionDataExtended[extendedKey];
        if (extendedValue) setAuctionExtended(extendedValue);
      }
    };

    fn();
  }, [auctionDataExtended, auctionExtended, setAuctionExtended]);
  return auctionExtended;
}

const AuctionCard = ({
  auctionView,
  style,
  hideDefaultAction,
  action
}) => {
  var _auctionView$myBidder, _auctionView$myBidder2, _auctionView$auction$, _auctionView$auction$2, _auctionExtended$info, _wallet$publicKey, _auctionView$auctionM, _auctionView$myBidder3, _wallet$publicKey3;

  const history = (0,external_react_router_dom_.useHistory)();
  const connection = (0,lib.useConnection)();
  const {
    update
  } = (0,meta.useMeta)();
  const wallet = (0,wallet_adapter_react_.useWallet)();
  const {
    setVisible
  } = (0,lib.useWalletModal)();
  const connect = (0,external_react_.useCallback)(() => wallet.wallet ? wallet.connect().catch() : setVisible(true), [wallet.wallet, wallet.connect, setVisible]);
  const mintInfo = (0,lib.useMint)(auctionView.auction.info.tokenMint);
  const {
    prizeTrackingTickets,
    bidRedemptions
  } = (0,meta.useMeta)();
  const bids = useBidsForAuction(auctionView.auction.pubkey);
  const creators = useCreators(auctionView);
  const {
    0: value,
    1: setValue
  } = (0,external_react_.useState)();
  const {
    0: loading,
    1: setLoading
  } = (0,external_react_.useState)(false);
  const {
    0: showRedeemedBidModal,
    1: setShowRedeemedBidModal
  } = (0,external_react_.useState)(false);
  const {
    0: showEndingBidModal,
    1: setShowEndingBidModal
  } = (0,external_react_.useState)(false);
  const {
    0: showRedemptionIssue,
    1: setShowRedemptionIssue
  } = (0,external_react_.useState)(false);
  const {
    0: showBidPlaced,
    1: setShowBidPlaced
  } = (0,external_react_.useState)(false);
  const {
    0: showPlaceBid,
    1: setShowPlaceBid
  } = (0,external_react_.useState)(false);
  const {
    0: lastBid,
    1: setLastBid
  } = (0,external_react_.useState)(undefined);
  const {
    0: isOpenPurchase,
    1: setIsOpenPurchase
  } = (0,external_react_.useState)(false);
  const {
    0: isOpenClaim,
    1: setIsOpenClaim
  } = (0,external_react_.useState)(false);
  const {
    0: showWarningModal,
    1: setShowWarningModal
  } = (0,external_react_.useState)(false);
  const {
    0: printingCost,
    1: setPrintingCost
  } = (0,external_react_.useState)();
  const {
    accountByMint
  } = (0,lib.useUserAccounts)();
  const mintKey = auctionView.auction.info.tokenMint;
  const balance = useUserBalance(mintKey);
  const tokenInfo = useTokenList().subscribedTokens.filter(m => m.address == mintKey)[0];
  const symbol = tokenInfo ? tokenInfo.symbol : mintKey == lib.WRAPPED_SOL_MINT.toBase58() ? 'SOL' : 'CUSTOM';
  const LAMPORTS_PER_MINT = tokenInfo ? Math.ceil(10 ** tokenInfo.decimals) : web3_js_.LAMPORTS_PER_SOL; //console.log("[--P]AuctionCard", tokenInfo, mintKey)

  const myPayingAccount = balance.accounts[0];
  const instantSalePrice = (0,external_react_.useMemo)(() => {
    var _auctionView$auctionD;

    return (_auctionView$auctionD = auctionView.auctionDataExtended) === null || _auctionView$auctionD === void 0 ? void 0 : _auctionView$auctionD.info.instantSalePrice;
  }, [auctionView.auctionDataExtended]);
  let winnerIndex = null;
  if ((_auctionView$myBidder = auctionView.myBidderPot) !== null && _auctionView$myBidder !== void 0 && _auctionView$myBidder.pubkey) winnerIndex = auctionView.auction.info.bidState.getWinnerIndex((_auctionView$myBidder2 = auctionView.myBidderPot) === null || _auctionView$myBidder2 === void 0 ? void 0 : _auctionView$myBidder2.info.bidderAct);
  const priceFloor = auctionView.auction.info.priceFloor.type === lib.PriceFloorType.Minimum ? ((_auctionView$auction$ = auctionView.auction.info.priceFloor.minPrice) === null || _auctionView$auction$ === void 0 ? void 0 : _auctionView$auction$.toNumber()) || 0 : 0;
  const eligibleForOpenEdition = eligibleForParticipationPrizeGivenWinningIndex(winnerIndex, auctionView, auctionView.myBidderMetadata, auctionView.myBidRedemption);
  const auctionExtended = useAuctionExtended(auctionView);
  const eligibleForAnything = winnerIndex !== null || eligibleForOpenEdition;
  const gapTime = (((_auctionView$auction$2 = auctionView.auction.info.auctionGap) === null || _auctionView$auction$2 === void 0 ? void 0 : _auctionView$auction$2.toNumber()) || 0) / 60;
  const gapTick = auctionExtended ? auctionExtended.info.gapTickSizePercentage : 0;
  const tickSize = auctionExtended !== null && auctionExtended !== void 0 && (_auctionExtended$info = auctionExtended.info) !== null && _auctionExtended$info !== void 0 && _auctionExtended$info.tickSize ? auctionExtended.info.tickSize : 0;
  const tickSizeInvalid = !!(tickSize && value && value * LAMPORTS_PER_MINT % tickSize.toNumber() != 0);
  const gapBidInvalid = useGapTickCheck(value, gapTick, gapTime, auctionView, LAMPORTS_PER_MINT);
  const isAuctionManagerAuthorityNotWalletOwner = auctionView.auctionManager.authority !== (wallet === null || wallet === void 0 ? void 0 : (_wallet$publicKey = wallet.publicKey) === null || _wallet$publicKey === void 0 ? void 0 : _wallet$publicKey.toBase58());
  const isAuctionNotStarted = auctionView.auction.info.state === lib.AuctionState.Created;
  const isUpcoming = auctionView.state === AuctionViewState.Upcoming;
  const isStarted = auctionView.state === AuctionViewState.Live;
  const participationFixedPrice = ((_auctionView$auctionM = auctionView.auctionManager.participationConfig) === null || _auctionView$auctionM === void 0 ? void 0 : _auctionView$auctionM.fixedPrice) || 0;
  const participationOnly = auctionView.auctionManager.numWinners.toNumber() === 0;
  const minBid = tickSize && (isUpcoming || bids.length === 0 ? (0,lib.fromLamports)(participationOnly ? participationFixedPrice : priceFloor, mintInfo) : isStarted && bids.length > 0 ? parseFloat((0,lib.formatTokenAmount)(bids[0].info.lastBid, mintInfo)) : 9999999) + tickSize.toNumber() / LAMPORTS_PER_MINT;
  const invalidBid = tickSizeInvalid || gapBidInvalid || !myPayingAccount || value === undefined || value * LAMPORTS_PER_MINT < priceFloor || minBid && value < minBid || loading || !accountByMint.get(QUOTE_MINT.toBase58());
  (0,external_react_.useEffect)(() => {
    if (wallet.connected) {
      if (wallet.publicKey && !showPlaceBid) setShowPlaceBid(true);
    } else {
      if (showPlaceBid) setShowPlaceBid(false);
    }
  }, [wallet.connected]);

  const endInstantSale = async () => {
    setLoading(true);

    try {
      await endSale({
        auctionView,
        connection,
        accountByMint,
        bids,
        bidRedemptions,
        prizeTrackingTickets,
        wallet
      });
    } catch (e) {
      console.error('endAuction', e);
      setLoading(false);
      return;
    }

    setShowEndingBidModal(true);
    setLoading(false);
  };

  const {
    canEndInstantSale,
    isAlreadyBought,
    canClaimPurchasedItem,
    canClaimItem
  } = useInstantSaleState(auctionView);

  const instantSaleAction = () => {
    const isNotEnoughLamports = balance.balanceLamports < ((instantSalePrice === null || instantSalePrice === void 0 ? void 0 : instantSalePrice.toNumber()) || 0);

    if (isNotEnoughLamports && !(canClaimPurchasedItem || canClaimItem || canEndInstantSale)) {
      return;
    }

    if (canEndInstantSale) {
      return endInstantSale();
    }

    return instantSale();
  };

  const instantSale = async () => {
    var _auctionView$particip;

    setLoading(true);
    const winningConfigType = ((_auctionView$particip = auctionView.participationItem) === null || _auctionView$particip === void 0 ? void 0 : _auctionView$particip.winningConfigType) || auctionView.items[0][0].winningConfigType;
    const isAuctionItemMaster = [metaplex.WinningConfigType.FullRightsTransfer, metaplex.WinningConfigType.TokenOnlyTransfer].includes(winningConfigType);
    const allowBidToPublic = myPayingAccount && !auctionView.myBidderPot && isAuctionManagerAuthorityNotWalletOwner;
    const allowBidToAuctionOwner = myPayingAccount && !isAuctionManagerAuthorityNotWalletOwner && isAuctionItemMaster; // Placing a "bid" of the full amount results in a purchase to redeem.

    if (instantSalePrice && (allowBidToPublic || allowBidToAuctionOwner)) {
      try {
        console.log('sendPlaceBid');
        const bid = await sendPlaceBid(connection, wallet, myPayingAccount.pubkey, auctionView, accountByMint, instantSalePrice, // make sure all accounts are created
        'finalized');
        setLastBid(bid);
      } catch (e) {
        console.error('sendPlaceBid', e);
        setLoading(false);
        return;
      }
    }

    const newAuctionState = await update(auctionView.auction.pubkey, wallet.publicKey);
    auctionView.auction = newAuctionState[0];
    auctionView.myBidderPot = newAuctionState[1];
    auctionView.myBidderMetadata = newAuctionState[2];

    if (wallet.publicKey && auctionView.auction.info.bidState.type == lib.BidStateType.EnglishAuction) {
      const winnerIndex = auctionView.auction.info.bidState.getWinnerIndex(wallet.publicKey.toBase58());
      if (winnerIndex === null) auctionView.auction.info.bidState.bids.unshift(new lib.Bid({
        key: wallet.publicKey.toBase58(),
        amount: instantSalePrice || new (external_bn_js_default())(0)
      })); // It isnt here yet

      if (!auctionView.myBidderPot) auctionView.myBidderPot = {
        pubkey: 'none',
        //@ts-ignore
        account: {},
        info: new lib.BidderPot({
          bidderPot: 'dummy',
          bidderAct: wallet.publicKey.toBase58(),
          auctionAct: auctionView.auction.pubkey,
          emptied: false
        })
      };
    } // Claim the purchase


    try {
      await sendRedeemBid(connection, wallet, myPayingAccount.pubkey, auctionView, accountByMint, prizeTrackingTickets, bidRedemptions, bids);
      await update();
      if (canClaimPurchasedItem) setIsOpenClaim(true);else setIsOpenPurchase(true);
    } catch (e) {
      console.error(e);
      setShowRedemptionIssue(true);
    }

    setLoading(false);
  };

  const isOpenEditionSale = auctionView.auction.info.bidState.type === lib.BidStateType.OpenEdition;
  const isBidderPotEmpty = Boolean((_auctionView$myBidder3 = auctionView.myBidderPot) === null || _auctionView$myBidder3 === void 0 ? void 0 : _auctionView$myBidder3.info.emptied);
  const doesInstantSaleHasNoItems = isBidderPotEmpty && auctionView.auction.info.bidState.max.toNumber() === bids.length;
  const shouldHideInstantSale = !isOpenEditionSale && auctionView.isInstantSale && isAuctionManagerAuthorityNotWalletOwner && doesInstantSaleHasNoItems;
  const shouldHide = shouldHideInstantSale || auctionView.vault.info.state === lib.VaultState.Deactivated && isBidderPotEmpty;
  const actionButtonContent = useActionButtonContent(auctionView);

  if (shouldHide) {
    return /*#__PURE__*/jsx_runtime_.jsx(jsx_runtime_.Fragment, {});
  }

  return /*#__PURE__*/(0,jsx_runtime_.jsxs)("div", {
    className: "auction-container",
    style: style,
    children: [/*#__PURE__*/jsx_runtime_.jsx("div", {
      className: 'time-info',
      children: !auctionView.isInstantSale && /*#__PURE__*/(0,jsx_runtime_.jsxs)(jsx_runtime_.Fragment, {
        children: [/*#__PURE__*/jsx_runtime_.jsx("span", {
          children: "Auction ends in"
        }), /*#__PURE__*/jsx_runtime_.jsx("div", {
          children: /*#__PURE__*/jsx_runtime_.jsx(AuctionCountdown, {
            auctionView: auctionView,
            labels: false
          })
        })]
      })
    }), /*#__PURE__*/(0,jsx_runtime_.jsxs)("div", {
      className: 'bid-info',
      children: [/*#__PURE__*/(0,jsx_runtime_.jsxs)("div", {
        className: "bid-info-container",
        children: [/*#__PURE__*/jsx_runtime_.jsx(AuctionNumbers, {
          auctionView: auctionView,
          showAsRow: true,
          hideCountdown: true,
          displaySymbol: true
        }), showPlaceBid && !hideDefaultAction && wallet.connected && auctionView.auction.info.ended() && /*#__PURE__*/jsx_runtime_.jsx(external_antd_.Button, {
          className: "secondary-btn",
          disabled: !myPayingAccount || !auctionView.myBidderMetadata && isAuctionManagerAuthorityNotWalletOwner || loading || !!auctionView.items.find(i => i.find(it => !it.metadata)),
          onClick: async () => {
            var _wallet$publicKey2;

            setLoading(true);
            setShowRedemptionIssue(false);

            if ((wallet === null || wallet === void 0 ? void 0 : (_wallet$publicKey2 = wallet.publicKey) === null || _wallet$publicKey2 === void 0 ? void 0 : _wallet$publicKey2.toBase58()) === auctionView.auctionManager.authority) {
              const totalCost = await calculateTotalCostOfRedeemingOtherPeoplesBids(connection, auctionView, bids, bidRedemptions);
              setPrintingCost(totalCost);
              setShowWarningModal(true);
            }

            try {
              if (eligibleForAnything) {
                await sendRedeemBid(connection, wallet, myPayingAccount.pubkey, auctionView, accountByMint, prizeTrackingTickets, bidRedemptions, bids).then(() => setShowRedeemedBidModal(true));
              } else {
                await sendCancelBid(connection, wallet, myPayingAccount.pubkey, auctionView, accountByMint, bids, bidRedemptions, prizeTrackingTickets);
              }
            } catch (e) {
              console.error(e);
              setShowRedemptionIssue(true);
            }

            setLoading(false);
          },
          children: loading || auctionView.items.find(i => i.find(it => !it.metadata)) || !myPayingAccount ? /*#__PURE__*/jsx_runtime_.jsx(external_antd_.Spin, {}) : eligibleForAnything ? `Redeem bid` : `${wallet !== null && wallet !== void 0 && wallet.publicKey && auctionView.auctionManager.authority === wallet.publicKey.toBase58() ? 'Reclaim Items' : 'Refund bid'}`
        }), showPlaceBid ? /*#__PURE__*/jsx_runtime_.jsx("div", {
          className: "show-place-bid",
          children: /*#__PURE__*/jsx_runtime_.jsx(AmountLabel, {
            title: "in your wallet",
            displaySymbol: (tokenInfo === null || tokenInfo === void 0 ? void 0 : tokenInfo.symbol) || 'CUSTOM',
            style: {
              marginBottom: 0
            },
            amount: balance.balance,
            tokenInfo: tokenInfo,
            customPrefix: /*#__PURE__*/jsx_runtime_.jsx(lib.Identicon, {
              address: wallet === null || wallet === void 0 ? void 0 : (_wallet$publicKey3 = wallet.publicKey) === null || _wallet$publicKey3 === void 0 ? void 0 : _wallet$publicKey3.toBase58(),
              style: {
                width: 36
              }
            })
          })
        }) : /*#__PURE__*/(0,jsx_runtime_.jsxs)("div", {
          className: "actions-place-bid",
          children: [/*#__PURE__*/jsx_runtime_.jsx(HowAuctionsWorkModal, {
            buttonClassName: "black-btn"
          }), !hideDefaultAction && !auctionView.auction.info.ended() && (wallet.connected && isAuctionNotStarted && !isAuctionManagerAuthorityNotWalletOwner ? /*#__PURE__*/jsx_runtime_.jsx(external_antd_.Button, {
            className: "secondary-btn",
            disabled: loading,
            onClick: async () => {
              setLoading(true);

              try {
                await startAuctionManually(connection, wallet, auctionView);
              } catch (e) {
                console.error(e);
              }

              setLoading(false);
            },
            style: {
              marginTop: 20
            },
            children: loading ? /*#__PURE__*/jsx_runtime_.jsx(external_antd_.Spin, {}) : 'Start auction'
          }) : !showPlaceBid && /*#__PURE__*/jsx_runtime_.jsx(external_antd_.Button, {
            className: "secondary-btn",
            onClick: () => {
              if (wallet.connected) setShowPlaceBid(true);else connect();
            },
            children: "Place Bid"
          }))]
        })]
      }), showPlaceBid && !auctionView.isInstantSale && !hideDefaultAction && wallet.connected && !auctionView.auction.info.ended() && /*#__PURE__*/(0,jsx_runtime_.jsxs)("div", {
        style: {
          display: 'flex',
          flexDirection: 'column',
          marginTop: '15px',
          marginBottom: '10px',
          borderTop: '1px solid rgba(255, 255, 255, 0.1)',
          paddingTop: '15px'
        },
        children: [/*#__PURE__*/jsx_runtime_.jsx("div", {
          style: {
            margin: '0 0 12px 0',
            letterSpacing: '0.02em',
            fontStyle: 'normal',
            fontWeight: 400,
            fontSize: '14px',
            lineHeight: '14px',
            textTransform: 'uppercase',
            color: 'rgba(255, 255, 255, 0.7)'
          },
          children: "your bid"
        }), /*#__PURE__*/(0,jsx_runtime_.jsxs)("div", {
          className: 'bid-container',
          children: [/*#__PURE__*/jsx_runtime_.jsx("div", {
            style: {
              width: '100%',
              background: '#242424',
              borderRadius: 14,
              color: 'rgba(0, 0, 0, 0.5)'
            },
            children: /*#__PURE__*/jsx_runtime_.jsx(external_antd_.InputNumber, {
              autoFocus: true,
              className: "input sol-input-bid",
              value: value,
              onChange: setValue,
              precision: 4,
              style: {
                fontSize: 16,
                lineHeight: '16px'
              },
              formatter: value => value ? `◎ ${value}`.replace(/\B(?=(\d{3})+(?!\d))/g, ',') : '',
              placeholder: minBid === 0 ? `Place a Bid` : `Bid ${minBid} ${symbol} or more`
            })
          }), /*#__PURE__*/(0,jsx_runtime_.jsxs)("div", {
            className: 'bid-buttons',
            children: [/*#__PURE__*/jsx_runtime_.jsx(external_antd_.Button, {
              className: "metaplex-button-default",
              style: {
                background: 'transparent',
                color: 'white',
                width: 'unset',
                fontWeight: 600,
                letterSpacing: '-0.02em',
                border: 'none'
              },
              disabled: loading,
              onClick: () => setShowPlaceBid(false),
              children: "Cancel"
            }), /*#__PURE__*/jsx_runtime_.jsx(external_antd_.Button, {
              className: "secondary-btn",
              disabled: invalidBid,
              onClick: async () => {
                setLoading(true);

                if (myPayingAccount && value) {
                  const bid = await sendPlaceBid(connection, wallet, myPayingAccount.pubkey, auctionView, accountByMint, value);
                  setLastBid(bid); // setShowBidModal(false);

                  setShowBidPlaced(true);
                  setLoading(false);
                }
              },
              children: loading || !accountByMint.get(QUOTE_MINT.toBase58()) ? /*#__PURE__*/jsx_runtime_.jsx(external_antd_.Spin, {}) : 'Bid now'
            })]
          })]
        })]
      }), !hideDefaultAction && wallet.connected && !auctionView.auction.info.ended() && (isAuctionNotStarted && !isAuctionManagerAuthorityNotWalletOwner ? /*#__PURE__*/jsx_runtime_.jsx(external_antd_.Button, {
        type: "primary",
        size: "large",
        className: "action-btn",
        disabled: loading,
        onClick: async () => {
          setLoading(true);

          try {
            await startAuctionManually(connection, wallet, auctionView);
          } catch (e) {
            console.error(e);
          }

          setLoading(false);
        },
        style: {
          marginTop: 20
        },
        children: loading ? /*#__PURE__*/jsx_runtime_.jsx(external_antd_.Spin, {}) : 'Start auction'
      }) : loading ? /*#__PURE__*/jsx_runtime_.jsx(external_antd_.Spin, {}) : auctionView.isInstantSale && !isAlreadyBought && /*#__PURE__*/jsx_runtime_.jsx(external_antd_.Button, {
        type: "primary",
        size: "large",
        className: "ant-btn secondary-btn",
        disabled: loading,
        onClick: instantSaleAction,
        style: {
          marginTop: 20,
          width: '100%'
        },
        children: actionButtonContent
      })), !hideDefaultAction && !wallet.connected && /*#__PURE__*/(0,jsx_runtime_.jsxs)(external_antd_.Button, {
        type: "primary",
        size: "large",
        className: "action-btn",
        onClick: connect,
        style: {
          marginTop: 20
        },
        children: ["Connect wallet to", ' ', auctionView.isInstantSale ? 'purchase' : 'place bid']
      }), action, showRedemptionIssue && /*#__PURE__*/jsx_runtime_.jsx("span", {
        style: {
          color: 'red'
        },
        children: "There was an issue redeeming or refunding your bid. Please try again."
      }), tickSizeInvalid && tickSize && /*#__PURE__*/(0,jsx_runtime_.jsxs)("span", {
        style: {
          color: 'red'
        },
        children: ["Tick size is \u25CE", tickSize.toNumber() / LAMPORTS_PER_MINT, "."]
      }), gapBidInvalid && /*#__PURE__*/(0,jsx_runtime_.jsxs)("span", {
        style: {
          color: 'red'
        },
        children: ["Your bid needs to be at least ", gapTick, "% larger than an existing bid during gap periods to be eligible."]
      }), !loading && value !== undefined && showPlaceBid && invalidBid && /*#__PURE__*/jsx_runtime_.jsx("span", {
        style: {
          color: 'red'
        },
        children: "Invalid amount"
      })]
    }), /*#__PURE__*/(0,jsx_runtime_.jsxs)(lib.MetaplexOverlay, {
      visible: showBidPlaced,
      children: [/*#__PURE__*/jsx_runtime_.jsx(Confetti, {}), /*#__PURE__*/jsx_runtime_.jsx("h1", {
        className: "title",
        style: {
          fontSize: '3rem',
          marginBottom: 20
        },
        children: "Nice bid!"
      }), /*#__PURE__*/(0,jsx_runtime_.jsxs)("p", {
        style: {
          color: 'white',
          textAlign: 'center',
          fontSize: '2rem'
        },
        children: ["Your bid of \u25CE ", (0,lib.formatTokenAmount)(lastBid === null || lastBid === void 0 ? void 0 : lastBid.amount, mintInfo), " was successful"]
      }), /*#__PURE__*/jsx_runtime_.jsx(external_antd_.Button, {
        onClick: () => setShowBidPlaced(false),
        className: "overlay-btn",
        children: "Got it"
      })]
    }), /*#__PURE__*/(0,jsx_runtime_.jsxs)(lib.MetaplexOverlay, {
      visible: showEndingBidModal,
      children: [/*#__PURE__*/jsx_runtime_.jsx(Confetti, {}), /*#__PURE__*/jsx_runtime_.jsx("h1", {
        className: "title",
        style: {
          fontSize: '3rem',
          marginBottom: 20
        },
        children: "Congratulations"
      }), /*#__PURE__*/(0,jsx_runtime_.jsxs)("p", {
        style: {
          color: 'white',
          textAlign: 'center',
          fontSize: '2rem'
        },
        children: ["Your sale has been ended please view your NFTs in", ' ', /*#__PURE__*/jsx_runtime_.jsx(external_react_router_dom_.Link, {
          to: "/artworks",
          children: "My Items"
        }), "."]
      }), /*#__PURE__*/jsx_runtime_.jsx(external_antd_.Button, {
        onClick: () => setShowEndingBidModal(false),
        className: "overlay-btn",
        children: "Got it"
      })]
    }), /*#__PURE__*/(0,jsx_runtime_.jsxs)(lib.MetaplexOverlay, {
      visible: showRedeemedBidModal,
      children: [/*#__PURE__*/jsx_runtime_.jsx(Confetti, {}), /*#__PURE__*/jsx_runtime_.jsx("h1", {
        className: "title",
        style: {
          fontSize: '3rem',
          marginBottom: 20
        },
        children: "Congratulations"
      }), /*#__PURE__*/(0,jsx_runtime_.jsxs)("p", {
        style: {
          color: 'white',
          textAlign: 'center',
          fontSize: '2rem'
        },
        children: ["Your ", auctionView.isInstantSale ? 'purchase' : 'bid', " has been redeemed please view your NFTs in ", /*#__PURE__*/jsx_runtime_.jsx(external_react_router_dom_.Link, {
          to: "/artworks",
          children: "My Items"
        }), "."]
      }), /*#__PURE__*/jsx_runtime_.jsx(external_antd_.Button, {
        onClick: () => setShowRedeemedBidModal(false),
        className: "overlay-btn",
        children: "Got it"
      })]
    }), /*#__PURE__*/jsx_runtime_.jsx(lib.MetaplexModal, {
      visible: showWarningModal,
      onCancel: () => setShowWarningModal(false),
      bodyStyle: {
        alignItems: 'start'
      },
      children: /*#__PURE__*/(0,jsx_runtime_.jsxs)("h3", {
        style: {
          color: 'white'
        },
        children: ["Warning: There may be some items in this auction that still are required by the auction for printing bidders' limited or open edition NFTs. If you wish to withdraw them, you are agreeing to foot the cost of up to an estimated \u25CE", /*#__PURE__*/jsx_runtime_.jsx("b", {
          children: (printingCost || 0) / LAMPORTS_PER_MINT
        }), " plus transaction fees to redeem their bids for them right now."]
      })
    }), /*#__PURE__*/jsx_runtime_.jsx(Modals_CongratulationsModal, {
      isModalVisible: isOpenPurchase,
      onClose: () => setIsOpenPurchase(false),
      onClickOk: () => window.location.reload(),
      buttonText: "Reload",
      content: "Reload the page and click claim to receive your NFT. Then check your wallet to confirm it has arrived. It may take a few minutes to process."
    }), /*#__PURE__*/jsx_runtime_.jsx(Modals_CongratulationsModal, {
      isModalVisible: isOpenClaim,
      onClose: () => setIsOpenClaim(false),
      buttonText: "Got it",
      content: `You have claimed your item from ${creators.map(item => ' ' + (item.name || (0,lib.shortenAddress)(item.address || '')))}!`,
      extraButtonText: "View My Items",
      onClickExtraButton: () => history.push('/artworks')
    })]
  });
};
// EXTERNAL MODULE: external "timeago.js"
var external_timeago_js_ = __webpack_require__(1514);
// EXTERNAL MODULE: external "@solana/spl-name-service"
var spl_name_service_ = __webpack_require__(5199);
;// CONCATENATED MODULE: ./src/components/ClickToCopy/index.tsx




const CopyIcon = () => /*#__PURE__*/(0,jsx_runtime_.jsxs)("svg", {
  xmlns: "http://www.w3.org/2000/svg",
  width: "24",
  height: "24",
  viewBox: "0 0 24 24",
  fill: "none",
  stroke: "currentColor",
  strokeWidth: "2",
  strokeLinecap: "round",
  strokeLinejoin: "round",
  className: "feather feather-copy",
  children: [/*#__PURE__*/jsx_runtime_.jsx("rect", {
    stroke: "currentColor",
    x: "9",
    y: "9",
    width: "13",
    height: "13",
    rx: "2",
    ry: "2"
  }), /*#__PURE__*/jsx_runtime_.jsx("path", {
    stroke: "currentColor",
    d: "M5 15H4a2 2 0 0 1-2-2V4a2 2 0 0 1 2-2h9a2 2 0 0 1 2 2v1"
  })]
});

const Checkmark = () => /*#__PURE__*/jsx_runtime_.jsx("svg", {
  xmlns: "http://www.w3.org/2000/svg",
  width: "24",
  height: "24",
  viewBox: "0 0 24 24",
  fill: "none",
  stroke: "currentColor",
  strokeWidth: "2",
  strokeLinecap: "round",
  strokeLinejoin: "round",
  className: "feather feather-check",
  children: /*#__PURE__*/jsx_runtime_.jsx("polyline", {
    points: "20 6 9 17 4 12"
  })
});

const ClickToCopy = ({
  copyText,
  className
}) => {
  const {
    0: clicked,
    1: setClicked
  } = (0,external_react_.useState)(false);
  (0,external_react_.useEffect)(() => {
    const timer = setTimeout(() => {
      setClicked(false);
    }, 3000);
    return () => clearTimeout(timer);
  }, [clicked]);

  const onClick = () => {
    navigator.clipboard.writeText(copyText);
    setClicked(true);
  };

  return /*#__PURE__*/jsx_runtime_.jsx("div", {
    className: className,
    onClick: onClick,
    title: "Click to copy pubkey",
    children: clicked ? /*#__PURE__*/jsx_runtime_.jsx(Checkmark, {}) : /*#__PURE__*/jsx_runtime_.jsx(CopyIcon, {})
  });
};
;// CONCATENATED MODULE: ./src/views/auction/index.tsx




















const AuctionItem = ({
  item,
  index,
  size,
  active
}) => {
  const id = item.metadata.pubkey;
  const style = {
    transform: index === 0 ? '' : `translate(${index * 15}px, ${-40 * index}px) scale(${Math.max(1 - 0.2 * index, 0)})`,
    transformOrigin: 'right bottom',
    position: index !== 0 ? 'absolute' : 'static',
    zIndex: -1 * index,
    marginLeft: size > 1 && index === 0 ? '0px' : 'auto',
    background: 'black',
    boxShadow: 'rgb(0 0 0 / 10%) 12px 2px 20px 14px',
    aspectRatio: '1/1'
  };
  return /*#__PURE__*/jsx_runtime_.jsx(ArtContent, {
    pubkey: id,
    className: "artwork-image stack-item",
    style: style,
    active: active,
    allowMeshRender: true
  });
};
const AuctionView = () => {
  var _useTokenList;

  const {
    width
  } = useWindowDimensions();
  const {
    id
  } = (0,external_react_router_dom_.useParams)();
  const {
    endpoint
  } = (0,lib.useConnectionConfig)();
  const auction = useAuction(id);
  const {
    0: currentIndex,
    1: setCurrentIndex
  } = (0,external_react_.useState)(0);
  const art = useArt(auction === null || auction === void 0 ? void 0 : auction.thumbnail.metadata.pubkey);
  const {
    ref,
    data
  } = useExtendedArt(auction === null || auction === void 0 ? void 0 : auction.thumbnail.metadata.pubkey);
  const creators = useCreators(auction);
  const {
    pullAuctionPage
  } = (0,lib.useMeta)();
  (0,external_react_.useEffect)(() => {
    pullAuctionPage(id);
  }, []);
  let edition = '';

  if (art.type === ArtType.NFT) {
    edition = 'Unique';
  } else if (art.type === ArtType.Master) {
    edition = 'NFT 0';
  } else if (art.type === ArtType.Print) {
    edition = `${art.edition} of ${art.supply}`;
  }

  const nftCount = auction === null || auction === void 0 ? void 0 : auction.items.flat().length;
  const winnerCount = auction === null || auction === void 0 ? void 0 : auction.items.length;
  const isOpen = (auction === null || auction === void 0 ? void 0 : auction.auction.info.bidState.type) === lib.BidStateType.OpenEdition;
  const hasDescription = data === undefined || data.description === undefined;
  const description = data === null || data === void 0 ? void 0 : data.description;
  const attributes = data === null || data === void 0 ? void 0 : data.attributes;
  const tokenInfo = (_useTokenList = useTokenList()) === null || _useTokenList === void 0 ? void 0 : _useTokenList.subscribedTokens.filter(m => m.address == (auction === null || auction === void 0 ? void 0 : auction.auction.info.tokenMint))[0];
  const items = [...((auction === null || auction === void 0 ? void 0 : auction.items.flat().reduce((agg, item) => {
    agg.set(item.metadata.pubkey, item);
    return agg;
  }, new Map()).values()) || []), auction === null || auction === void 0 ? void 0 : auction.participationItem].map((item, index, arr) => {
    var _item$metadata;

    if (!item || !(item !== null && item !== void 0 && item.metadata) || !((_item$metadata = item.metadata) !== null && _item$metadata !== void 0 && _item$metadata.pubkey)) {
      return null;
    }

    return /*#__PURE__*/jsx_runtime_.jsx(AuctionItem, {
      item: item,
      index: index,
      size: arr.length,
      active: index === currentIndex
    }, item.metadata.pubkey);
  });

  if (width < 768) {
    return /*#__PURE__*/(0,jsx_runtime_.jsxs)(external_antd_.Row, {
      justify: "center",
      gutter: [48, 0],
      className: "auction-mobile-container",
      children: [/*#__PURE__*/jsx_runtime_.jsx(external_antd_.Col, {
        span: 24,
        className: 'img-cont-500',
        children: /*#__PURE__*/jsx_runtime_.jsx("div", {
          className: "auction-view",
          style: {
            minHeight: 300
          },
          children: /*#__PURE__*/jsx_runtime_.jsx(external_antd_.Carousel, {
            autoplay: false,
            afterChange: index => setCurrentIndex(index),
            children: items
          })
        })
      }), /*#__PURE__*/(0,jsx_runtime_.jsxs)(external_antd_.Col, {
        className: "auction-mobile-section",
        children: [/*#__PURE__*/jsx_runtime_.jsx("h2", {
          className: "art-title",
          children: art.title || /*#__PURE__*/jsx_runtime_.jsx(external_antd_.Skeleton, {
            paragraph: {
              rows: 0
            }
          })
        }), /*#__PURE__*/(0,jsx_runtime_.jsxs)("div", {
          className: "info-container",
          children: [/*#__PURE__*/(0,jsx_runtime_.jsxs)("div", {
            className: 'info-component',
            children: [/*#__PURE__*/jsx_runtime_.jsx("h6", {
              className: 'info-title',
              children: "Edition"
            }), /*#__PURE__*/jsx_runtime_.jsx("span", {
              children: ((auction === null || auction === void 0 ? void 0 : auction.items.length) || 0) > 1 ? 'Multiple' : edition
            })]
          }), /*#__PURE__*/(0,jsx_runtime_.jsxs)("div", {
            className: 'info-component',
            children: [/*#__PURE__*/jsx_runtime_.jsx("h6", {
              className: 'info-title',
              children: "Winners"
            }), /*#__PURE__*/jsx_runtime_.jsx("span", {
              children: winnerCount === undefined ? /*#__PURE__*/jsx_runtime_.jsx(external_antd_.Skeleton, {
                paragraph: {
                  rows: 0
                }
              }) : isOpen ? 'Unlimited' : winnerCount
            })]
          }), /*#__PURE__*/(0,jsx_runtime_.jsxs)("div", {
            className: 'info-component',
            children: [/*#__PURE__*/jsx_runtime_.jsx("h6", {
              className: 'info-title',
              children: "NFTS"
            }), /*#__PURE__*/jsx_runtime_.jsx("span", {
              children: nftCount === undefined ? /*#__PURE__*/jsx_runtime_.jsx(external_antd_.Skeleton, {
                paragraph: {
                  rows: 0
                }
              }) : isOpen ? 'Open' : nftCount
            })]
          })]
        })]
      }), /*#__PURE__*/(0,jsx_runtime_.jsxs)(external_antd_.Col, {
        className: "auction-mobile-section",
        span: 24,
        children: [!auction && /*#__PURE__*/jsx_runtime_.jsx(external_antd_.Skeleton, {
          paragraph: {
            rows: 6
          }
        }), auction && /*#__PURE__*/jsx_runtime_.jsx(AuctionCard, {
          auctionView: auction,
          hideDefaultAction: false
        })]
      }), /*#__PURE__*/(0,jsx_runtime_.jsxs)(external_antd_.Col, {
        className: "auction-mobile-section",
        span: 24,
        children: [/*#__PURE__*/jsx_runtime_.jsx("h6", {
          className: 'info-title',
          children: "Details"
        }), /*#__PURE__*/jsx_runtime_.jsx("div", {
          className: "description",
          children: /*#__PURE__*/(0,jsx_runtime_.jsxs)("p", {
            className: 'about-nft-collection a-description',
            children: [hasDescription && /*#__PURE__*/jsx_runtime_.jsx(external_antd_.Skeleton, {
              paragraph: {
                rows: 3
              }
            }), description || winnerCount !== undefined && /*#__PURE__*/jsx_runtime_.jsx("div", {
              style: {
                fontStyle: 'italic'
              },
              children: "No description provided."
            })]
          })
        })]
      }), attributes && /*#__PURE__*/(0,jsx_runtime_.jsxs)(external_antd_.Col, {
        className: "auction-mobile-section about-nft-collection a-attributes",
        span: 24,
        children: [/*#__PURE__*/jsx_runtime_.jsx("h6", {
          children: "Attributes"
        }), /*#__PURE__*/jsx_runtime_.jsx(external_antd_.List, {
          grid: {
            column: 4
          },
          children: attributes.map((attribute, index) => /*#__PURE__*/jsx_runtime_.jsx(external_antd_.List.Item, {
            children: /*#__PURE__*/jsx_runtime_.jsx(external_antd_.Card, {
              title: attribute.trait_type,
              children: attribute.value
            })
          }, `${attribute.value}-${index}`))
        })]
      }), /*#__PURE__*/jsx_runtime_.jsx(external_antd_.Col, {
        className: "auction-mobile-section",
        span: 24,
        children: /*#__PURE__*/(0,jsx_runtime_.jsxs)("div", {
          className: 'info-view',
          children: [/*#__PURE__*/jsx_runtime_.jsx("h6", {
            className: 'info-title',
            children: "Artists"
          }), /*#__PURE__*/jsx_runtime_.jsx("div", {
            style: {
              display: 'flex'
            },
            children: /*#__PURE__*/jsx_runtime_.jsx(MetaAvatarDetailed, {
              creators: creators
            })
          })]
        })
      }), /*#__PURE__*/jsx_runtime_.jsx(external_antd_.Col, {
        className: "auction-mobile-section",
        span: 24,
        children: /*#__PURE__*/(0,jsx_runtime_.jsxs)("div", {
          className: 'info-view',
          children: [/*#__PURE__*/jsx_runtime_.jsx("h6", {
            className: 'info-title',
            children: "View on"
          }), /*#__PURE__*/(0,jsx_runtime_.jsxs)("div", {
            style: {
              display: 'flex'
            },
            children: [/*#__PURE__*/jsx_runtime_.jsx(external_antd_.Button, {
              className: "tag",
              onClick: () => window.open(art.uri || '', '_blank'),
              children: "Arweave"
            }), /*#__PURE__*/jsx_runtime_.jsx(external_antd_.Button, {
              className: "tag",
              onClick: () => {
                const cluster = endpoint.name;
                const explorerURL = new URL(`account/${(art === null || art === void 0 ? void 0 : art.mint) || ''}`, 'https://explorer.solana.com');

                if (!cluster.includes('mainnet')) {
                  explorerURL.searchParams.set('cluster', cluster);
                }

                window.open(explorerURL.href, '_blank');
              },
              children: "Solana"
            })]
          })]
        })
      }), /*#__PURE__*/jsx_runtime_.jsx(external_antd_.Col, {
        className: "auction-mobile-section",
        span: 24,
        children: /*#__PURE__*/jsx_runtime_.jsx(AuctionBids, {
          auctionView: auction
        })
      })]
    });
  } else {
    return /*#__PURE__*/(0,jsx_runtime_.jsxs)(external_antd_.Row, {
      justify: "center",
      ref: ref,
      gutter: [48, 0],
      children: [/*#__PURE__*/(0,jsx_runtime_.jsxs)(external_antd_.Col, {
        span: 24,
        md: 10,
        className: 'img-cont-500',
        children: [/*#__PURE__*/jsx_runtime_.jsx("div", {
          className: "auction-view",
          style: {
            minHeight: 300
          },
          children: /*#__PURE__*/jsx_runtime_.jsx(external_antd_.Carousel, {
            autoplay: false,
            afterChange: index => setCurrentIndex(index),
            children: items
          })
        }), /*#__PURE__*/(0,jsx_runtime_.jsxs)("h6", {
          className: 'about-nft-collection',
          children: ["ABOUT THIS ", nftCount === 1 ? 'NFT' : 'COLLECTION']
        }), /*#__PURE__*/(0,jsx_runtime_.jsxs)("p", {
          className: 'about-nft-collection a-description',
          children: [hasDescription && /*#__PURE__*/jsx_runtime_.jsx(external_antd_.Skeleton, {
            paragraph: {
              rows: 3
            }
          }), description || winnerCount !== undefined && /*#__PURE__*/jsx_runtime_.jsx("div", {
            style: {
              fontStyle: 'italic'
            },
            children: "No description provided."
          })]
        }), attributes && /*#__PURE__*/(0,jsx_runtime_.jsxs)("div", {
          className: 'about-nft-collection a-attributes',
          children: [/*#__PURE__*/jsx_runtime_.jsx("h6", {
            children: "Attributes"
          }), /*#__PURE__*/jsx_runtime_.jsx(external_antd_.List, {
            grid: {
              column: 4
            },
            children: attributes.map((attribute, index) => /*#__PURE__*/jsx_runtime_.jsx(external_antd_.List.Item, {
              children: /*#__PURE__*/jsx_runtime_.jsx(external_antd_.Card, {
                title: attribute.trait_type,
                children: attribute.value
              })
            }, `${attribute.value}-${index}`))
          })]
        })]
      }), /*#__PURE__*/(0,jsx_runtime_.jsxs)(external_antd_.Col, {
        span: 24,
        md: 14,
        children: [/*#__PURE__*/jsx_runtime_.jsx("h2", {
          className: "art-title",
          children: art.title || /*#__PURE__*/jsx_runtime_.jsx(external_antd_.Skeleton, {
            paragraph: {
              rows: 0
            }
          })
        }), /*#__PURE__*/(0,jsx_runtime_.jsxs)(external_antd_.Row, {
          gutter: [44, 0],
          children: [/*#__PURE__*/jsx_runtime_.jsx(external_antd_.Col, {
            span: 12,
            md: 16,
            children: /*#__PURE__*/(0,jsx_runtime_.jsxs)("div", {
              className: 'info-container',
              children: [/*#__PURE__*/(0,jsx_runtime_.jsxs)("div", {
                className: 'info-component',
                children: [/*#__PURE__*/jsx_runtime_.jsx("h6", {
                  className: 'info-title',
                  children: "CREATED BY"
                }), /*#__PURE__*/jsx_runtime_.jsx("span", {
                  children: /*#__PURE__*/jsx_runtime_.jsx(MetaAvatar, {
                    creators: creators
                  })
                })]
              }), /*#__PURE__*/(0,jsx_runtime_.jsxs)("div", {
                className: 'info-component',
                children: [/*#__PURE__*/jsx_runtime_.jsx("h6", {
                  className: 'info-title',
                  children: "Edition"
                }), /*#__PURE__*/jsx_runtime_.jsx("span", {
                  children: ((auction === null || auction === void 0 ? void 0 : auction.items.length) || 0) > 1 ? 'Multiple' : edition
                })]
              }), /*#__PURE__*/(0,jsx_runtime_.jsxs)("div", {
                className: 'info-component',
                children: [/*#__PURE__*/jsx_runtime_.jsx("h6", {
                  className: 'info-title',
                  children: "Winners"
                }), /*#__PURE__*/jsx_runtime_.jsx("span", {
                  children: winnerCount === undefined ? /*#__PURE__*/jsx_runtime_.jsx(external_antd_.Skeleton, {
                    paragraph: {
                      rows: 0
                    }
                  }) : isOpen ? 'Unlimited' : winnerCount
                })]
              }), /*#__PURE__*/(0,jsx_runtime_.jsxs)("div", {
                className: 'info-component',
                children: [/*#__PURE__*/jsx_runtime_.jsx("h6", {
                  className: 'info-title',
                  children: "NFTS"
                }), /*#__PURE__*/jsx_runtime_.jsx("span", {
                  children: nftCount === undefined ? /*#__PURE__*/jsx_runtime_.jsx(external_antd_.Skeleton, {
                    paragraph: {
                      rows: 0
                    }
                  }) : isOpen ? 'Open' : nftCount
                })]
              }), /*#__PURE__*/(0,jsx_runtime_.jsxs)("div", {
                className: 'info-component',
                children: [/*#__PURE__*/jsx_runtime_.jsx("h6", {
                  className: 'info-title',
                  children: "CURRENCY"
                }), /*#__PURE__*/(0,jsx_runtime_.jsxs)("span", {
                  children: [nftCount === undefined ? /*#__PURE__*/jsx_runtime_.jsx(external_antd_.Skeleton, {
                    paragraph: {
                      rows: 0
                    }
                  }) : `${(tokenInfo === null || tokenInfo === void 0 ? void 0 : tokenInfo.name) || 'Custom Token'} ($${(tokenInfo === null || tokenInfo === void 0 ? void 0 : tokenInfo.symbol) || 'CUSTOM'})`, /*#__PURE__*/jsx_runtime_.jsx(ClickToCopy, {
                    className: "copy-pubkey",
                    copyText: tokenInfo ? tokenInfo === null || tokenInfo === void 0 ? void 0 : tokenInfo.address : (auction === null || auction === void 0 ? void 0 : auction.auction.info.tokenMint) || ''
                  })]
                })]
              })]
            })
          }), /*#__PURE__*/jsx_runtime_.jsx(external_antd_.Col, {
            span: 12,
            md: 8,
            className: "view-on-container",
            children: /*#__PURE__*/jsx_runtime_.jsx("div", {
              className: "info-view-container",
              children: /*#__PURE__*/(0,jsx_runtime_.jsxs)("div", {
                className: "info-view",
                children: [/*#__PURE__*/jsx_runtime_.jsx("h6", {
                  className: "info-title",
                  children: "View on"
                }), /*#__PURE__*/(0,jsx_runtime_.jsxs)("div", {
                  style: {
                    display: 'flex'
                  },
                  children: [/*#__PURE__*/jsx_runtime_.jsx(external_antd_.Button, {
                    className: "tag",
                    onClick: () => window.open(art.uri || '', '_blank'),
                    children: "Arweave"
                  }), /*#__PURE__*/jsx_runtime_.jsx(external_antd_.Button, {
                    className: "tag",
                    onClick: () => {
                      const cluster = endpoint.name;
                      const explorerURL = new URL(`account/${(art === null || art === void 0 ? void 0 : art.mint) || ''}`, 'https://explorer.solana.com');

                      if (!cluster.includes('mainnet')) {
                        explorerURL.searchParams.set('cluster', cluster);
                      }

                      window.open(explorerURL.href, '_blank');
                    },
                    children: "Solana"
                  })]
                })]
              })
            })
          })]
        }), !auction && /*#__PURE__*/jsx_runtime_.jsx(external_antd_.Skeleton, {
          paragraph: {
            rows: 6
          }
        }), auction && /*#__PURE__*/jsx_runtime_.jsx(AuctionCard, {
          auctionView: auction,
          hideDefaultAction: false
        }), !(auction !== null && auction !== void 0 && auction.isInstantSale) && /*#__PURE__*/jsx_runtime_.jsx(AuctionBids, {
          auctionView: auction
        })]
      })]
    });
  }
};

const BidLine = props => {
  const {
    bid,
    mint,
    isCancelled,
    mintKey
  } = props;
  const {
    publicKey
  } = (0,wallet_adapter_react_.useWallet)();
  const bidder = bid.info.bidderPubkey;
  const isme = (publicKey === null || publicKey === void 0 ? void 0 : publicKey.toBase58()) === bidder;
  const tokenInfo = useTokenList().subscribedTokens.filter(m => m.address == mintKey)[0]; // Get Twitter Handle from address

  const connection = (0,lib.useConnection)();
  const {
    0: bidderTwitterHandle,
    1: setBidderTwitterHandle
  } = (0,external_react_.useState)('');
  (0,external_react_.useEffect)(() => {
    const getTwitterHandle = async (connection, bidder) => {
      try {
        const [twitterHandle] = await (0,spl_name_service_.getHandleAndRegistryKey)(connection, (0,lib.toPublicKey)(bidder));
        setBidderTwitterHandle(twitterHandle);
      } catch (err) {
        console.warn(`err`);
        return undefined;
      }
    };

    getTwitterHandle(connection, bidder);
  }, [bidderTwitterHandle]);
  const {
    width
  } = useWindowDimensions();

  if (width < 768) {
    return /*#__PURE__*/(0,jsx_runtime_.jsxs)(external_antd_.Row, {
      className: "mobile-bid-history",
      children: [/*#__PURE__*/(0,jsx_runtime_.jsxs)("div", {
        className: "bid-info-container",
        children: [/*#__PURE__*/(0,jsx_runtime_.jsxs)("div", {
          className: "bidder-info-container",
          children: [/*#__PURE__*/jsx_runtime_.jsx(lib.Identicon, {
            style: {
              width: 24,
              height: 24,
              marginRight: 10,
              marginTop: 2
            },
            address: bidder
          }), bidderTwitterHandle ? /*#__PURE__*/jsx_runtime_.jsx("a", {
            target: "_blank",
            title: (0,lib.shortenAddress)(bidder),
            href: `https://twitter.com/${bidderTwitterHandle}`,
            rel: "noreferrer",
            children: `@${bidderTwitterHandle}`
          }) : (0,lib.shortenAddress)(bidder)]
        }), /*#__PURE__*/jsx_runtime_.jsx("div", {
          children: !isCancelled && /*#__PURE__*/(0,jsx_runtime_.jsxs)("div", {
            className: 'flex ',
            children: [isme && /*#__PURE__*/(0,jsx_runtime_.jsxs)(jsx_runtime_.Fragment, {
              children: [/*#__PURE__*/jsx_runtime_.jsx(icons_.CheckOutlined, {}), "\xA0"]
            }), /*#__PURE__*/jsx_runtime_.jsx(AmountLabel, {
              style: {
                marginBottom: 0,
                fontSize: '16px'
              },
              containerStyle: {
                flexDirection: 'row',
                alignItems: 'center'
              },
              displaySymbol: (tokenInfo === null || tokenInfo === void 0 ? void 0 : tokenInfo.symbol) || 'CUSTOM',
              iconSize: 24,
              amount: (0,lib.formatTokenAmount)(bid.info.lastBid, mint)
            })]
          })
        })]
      }), /*#__PURE__*/jsx_runtime_.jsx("div", {
        className: "bid-info-container",
        children: (0,external_timeago_js_.format)(bid.info.lastBidTimestamp.toNumber() * 1000)
      })]
    });
  } else {
    return /*#__PURE__*/(0,jsx_runtime_.jsxs)(external_antd_.Row, {
      className: 'bid-history',
      children: [isCancelled && /*#__PURE__*/jsx_runtime_.jsx("div", {
        style: {
          position: 'absolute',
          left: 0,
          width: '100%',
          height: 1,
          background: 'grey',
          top: 'calc(50% - 1px)',
          zIndex: 2
        }
      }), /*#__PURE__*/jsx_runtime_.jsx(external_antd_.Col, {
        span: 8,
        children: !isCancelled && /*#__PURE__*/(0,jsx_runtime_.jsxs)("div", {
          className: 'flex ',
          children: [isme && /*#__PURE__*/(0,jsx_runtime_.jsxs)(jsx_runtime_.Fragment, {
            children: [/*#__PURE__*/jsx_runtime_.jsx(icons_.CheckOutlined, {}), "\xA0"]
          }), /*#__PURE__*/jsx_runtime_.jsx(AmountLabel, {
            style: {
              marginBottom: 0,
              fontSize: '16px'
            },
            containerStyle: {
              flexDirection: 'row',
              alignItems: 'center'
            },
            displaySymbol: (tokenInfo === null || tokenInfo === void 0 ? void 0 : tokenInfo.symbol) || 'CUSTOM',
            tokenInfo: tokenInfo,
            iconSize: 24,
            amount: (0,lib.formatTokenAmount)(bid.info.lastBid, mint)
          })]
        })
      }), /*#__PURE__*/jsx_runtime_.jsx(external_antd_.Col, {
        span: 8,
        style: {
          opacity: 0.7
        },
        children: (0,external_timeago_js_.format)(bid.info.lastBidTimestamp.toNumber() * 1000)
      }), /*#__PURE__*/jsx_runtime_.jsx(external_antd_.Col, {
        span: 8,
        children: /*#__PURE__*/(0,jsx_runtime_.jsxs)("div", {
          className: 'flex-right',
          children: [/*#__PURE__*/jsx_runtime_.jsx(lib.Identicon, {
            style: {
              width: 24,
              height: 24,
              marginRight: 10,
              marginTop: 2
            },
            address: bidder
          }), ' ', /*#__PURE__*/jsx_runtime_.jsx("span", {
            style: {
              opacity: 0.7
            },
            children: bidderTwitterHandle ? /*#__PURE__*/(0,jsx_runtime_.jsxs)(external_antd_.Row, {
              className: "pubkey-row",
              children: [/*#__PURE__*/jsx_runtime_.jsx("a", {
                target: "_blank",
                title: (0,lib.shortenAddress)(bidder),
                href: `https://twitter.com/${bidderTwitterHandle}`,
                rel: "noreferrer",
                children: `@${bidderTwitterHandle}`
              }), /*#__PURE__*/jsx_runtime_.jsx(ClickToCopy, {
                className: "copy-pubkey",
                copyText: bidder
              })]
            }) : /*#__PURE__*/(0,jsx_runtime_.jsxs)(external_antd_.Row, {
              className: "pubkey-row",
              children: [(0,lib.shortenAddress)(bidder), /*#__PURE__*/jsx_runtime_.jsx(ClickToCopy, {
                className: "copy-pubkey",
                copyText: bidder
              })]
            })
          })]
        })
      })]
    });
  }
};

const AuctionBids = ({
  auctionView
}) => {
  const bids = useBidsForAuction((auctionView === null || auctionView === void 0 ? void 0 : auctionView.auction.pubkey) || '');
  const mint = (0,lib.useMint)(auctionView === null || auctionView === void 0 ? void 0 : auctionView.auction.info.tokenMint);
  const {
    width
  } = useWindowDimensions();
  const {
    0: showHistoryModal,
    1: setShowHistoryModal
  } = (0,external_react_.useState)(false);
  const winnersCount = (auctionView === null || auctionView === void 0 ? void 0 : auctionView.auction.info.bidState.max.toNumber()) || 0;
  const activeBids = (auctionView === null || auctionView === void 0 ? void 0 : auctionView.auction.info.bidState.bids) || [];
  const activeBidders = (0,external_react_.useMemo)(() => {
    return new Set(activeBids.map(b => b.key));
  }, [activeBids]);
  const auctionState = auctionView ? auctionView.auction.info.state : lib.AuctionState.Created;
  const bidLines = (0,external_react_.useMemo)(() => {
    let activeBidIndex = 0;
    return bids.map((bid, index) => {
      const isCancelled = index < winnersCount && !!bid.info.cancelled || auctionState !== lib.AuctionState.Ended && !!bid.info.cancelled;

      const line = /*#__PURE__*/jsx_runtime_.jsx(BidLine, {
        bid: bid,
        index: activeBidIndex,
        mint: mint,
        isCancelled: isCancelled,
        isActive: !bid.info.cancelled,
        mintKey: (auctionView === null || auctionView === void 0 ? void 0 : auctionView.auction.info.tokenMint) || ''
      }, index);

      if (!isCancelled) {
        activeBidIndex++;
      }

      return line;
    });
  }, [auctionState, bids, activeBidders]);
  if (!auctionView || bids.length < 1) return null;
  return /*#__PURE__*/jsx_runtime_.jsx(external_antd_.Row, {
    children: /*#__PURE__*/(0,jsx_runtime_.jsxs)(external_antd_.Col, {
      className: "bids-lists",
      children: [/*#__PURE__*/jsx_runtime_.jsx("h6", {
        className: 'info-title',
        children: "Bid History"
      }), bidLines.slice(0, 10), bids.length > 10 && /*#__PURE__*/jsx_runtime_.jsx("div", {
        className: "full-history",
        onClick: () => setShowHistoryModal(true),
        style: {
          cursor: 'pointer'
        },
        children: "View full history"
      }), /*#__PURE__*/jsx_runtime_.jsx(lib.MetaplexModal, {
        visible: showHistoryModal,
        onCancel: () => setShowHistoryModal(false),
        title: "Bid history",
        bodyStyle: {
          background: 'unset',
          boxShadow: 'unset',
          borderRadius: 0
        },
        centered: true,
        width: width < 768 ? width - 10 : 600,
        children: /*#__PURE__*/jsx_runtime_.jsx("div", {
          style: {
            maxHeight: 600,
            overflowY: 'scroll',
            width: '100%'
          },
          children: bidLines
        })
      })]
    })
  });
};
;// CONCATENATED MODULE: ./src/components/PackCard/utils.ts
const getCreator = (whitelistedCreatorsByCreator, authority) => {
  const knownCreator = whitelistedCreatorsByCreator[authority];
  return {
    address: authority,
    verified: true,
    image: (knownCreator === null || knownCreator === void 0 ? void 0 : knownCreator.info.image) || '',
    name: (knownCreator === null || knownCreator === void 0 ? void 0 : knownCreator.info.name) || '',
    link: (knownCreator === null || knownCreator === void 0 ? void 0 : knownCreator.info.twitter) || ''
  };
};
;// CONCATENATED MODULE: ./src/components/PackCard/index.tsx











const PackCard = ({
  voucherMetadata,
  uri,
  name,
  authority,
  cardsRedeemed,
  allowedAmountToRedeem,
  artView,
  onClose
}) => {
  const {
    whitelistedCreatorsByCreator
  } = (0,lib.useMeta)();
  const art = useArt(voucherMetadata);
  const creator = (0,external_react_.useMemo)(() => getCreator(whitelistedCreatorsByCreator, authority), [whitelistedCreatorsByCreator, authority]);
  const packStatusTitle = cardsRedeemed ? 'Opened' : 'Sealed';
  const headingTitle = artView ? packStatusTitle : 'Pack';
  const badge = art.type === ArtType.Print && `${art.edition} of ${art.supply}`;
  const numberOfCardsLeft = allowedAmountToRedeem && cardsRedeemed ? allowedAmountToRedeem - cardsRedeemed : allowedAmountToRedeem || 0;
  const infoMessage = (0,external_react_.useMemo)(() => {
    if (!artView) return 'PACK OPENING UNLOCKS';
    return numberOfCardsLeft ? `${numberOfCardsLeft} NFT reveal left` : 'All revealed';
  }, [artView, numberOfCardsLeft]);
  return /*#__PURE__*/(0,jsx_runtime_.jsxs)(external_antd_.Card, {
    hoverable: true,
    className: "auction-render-card",
    bordered: false,
    children: [onClose && /*#__PURE__*/jsx_runtime_.jsx(external_antd_.Button, {
      className: "card-close-button",
      shape: "circle",
      onClick: e => {
        e.stopPropagation();
        e.preventDefault();
        onClose();
      },
      children: "X"
    }), /*#__PURE__*/(0,jsx_runtime_.jsxs)("div", {
      className: "card-art-info",
      children: [/*#__PURE__*/(0,jsx_runtime_.jsxs)("div", {
        className: "pack-gray-wrapper",
        children: [/*#__PURE__*/(0,jsx_runtime_.jsxs)("div", {
          className: "card-artist-info card-artist-info--pack",
          children: [/*#__PURE__*/(0,jsx_runtime_.jsxs)("div", {
            className: "pack-creator-info",
            children: [/*#__PURE__*/jsx_runtime_.jsx(MetaAvatar, {
              creators: [creator]
            }), /*#__PURE__*/jsx_runtime_.jsx("span", {
              className: "pack-creator-name",
              children: creator.name || (0,lib.shortenAddress)((creator === null || creator === void 0 ? void 0 : creator.address) || '')
            })]
          }), badge && /*#__PURE__*/jsx_runtime_.jsx("div", {
            className: "card-artist-info__subtitle",
            children: /*#__PURE__*/jsx_runtime_.jsx("p", {
              className: "info-message__main",
              children: badge
            })
          })]
        }), /*#__PURE__*/jsx_runtime_.jsx("div", {
          className: "art-content-wrapper",
          children: /*#__PURE__*/jsx_runtime_.jsx(ArtContent, {
            uri: uri,
            preview: false
          })
        }), /*#__PURE__*/jsx_runtime_.jsx("div", {
          className: "art-name",
          children: name
        })]
      }), /*#__PURE__*/(0,jsx_runtime_.jsxs)("div", {
        className: "art-auction-info",
        children: [/*#__PURE__*/(0,jsx_runtime_.jsxs)("div", {
          className: "art-auction-info__left-side",
          children: [/*#__PURE__*/jsx_runtime_.jsx("img", {
            src: "/grid-4.svg"
          }), /*#__PURE__*/jsx_runtime_.jsx("span", {
            className: "info-message",
            children: infoMessage
          })]
        }), /*#__PURE__*/jsx_runtime_.jsx("div", {
          className: "art-auction-info__right-side",
          children: /*#__PURE__*/jsx_runtime_.jsx("span", {
            children: headingTitle
          })
        })]
      })]
    }), !artView && /*#__PURE__*/jsx_runtime_.jsx("div", {
      className: "card-bid-info"
    })]
  });
};

/* harmony default export */ const components_PackCard = (PackCard);
;// CONCATENATED MODULE: ./src/views/auctionCreate/AuctionItemCard.tsx






const AuctionItemCard = ({
  current,
  isSelected,
  onSelect,
  onClose
}) => {
  const {
    packs,
    vouchers
  } = (0,meta.useMeta)();
  const shouldShowPacks = process.env.NEXT_ENABLE_NFT_PACKS === 'true';

  if (shouldShowPacks) {
    var _current$edition, _current$edition$info;

    const parent = (_current$edition = current.edition) === null || _current$edition === void 0 ? void 0 : (_current$edition$info = _current$edition.info) === null || _current$edition$info === void 0 ? void 0 : _current$edition$info.parent;
    const voucher = Object.values(vouchers).find(v => {
      var _v$info;

      return (v === null || v === void 0 ? void 0 : (_v$info = v.info) === null || _v$info === void 0 ? void 0 : _v$info.master) === parent;
    });

    if (voucher) {
      const {
        info: {
          authority,
          allowedAmountToRedeem,
          name,
          uri
        }
      } = packs[voucher.info.packSet];
      return (
        /*#__PURE__*/
        // use <div> for correct grid rendering
        jsx_runtime_.jsx("div", {
          onClick: onSelect,
          children: /*#__PURE__*/jsx_runtime_.jsx(components_PackCard, {
            name: name,
            voucherMetadata: current.metadata.pubkey,
            uri: uri,
            authority: authority,
            allowedAmountToRedeem: allowedAmountToRedeem,
            onClose: onClose,
            artView: true
          })
        })
      );
    }
  }

  return /*#__PURE__*/jsx_runtime_.jsx(ArtCard, {
    pubkey: current.metadata.pubkey,
    preview: false,
    onClick: onSelect,
    className: isSelected ? 'selected-card art-card-for-selector' : 'not-selected-card art-card-for-selector',
    onClose: onClose
  });
};

/* harmony default export */ const auctionCreate_AuctionItemCard = (AuctionItemCard);
;// CONCATENATED MODULE: ./src/views/auctionCreate/artSelector.tsx







const ArtSelector = props => {
  const {
    selected,
    setSelected,
    allowMultiple
  } = props;
  let items = useUserArts();
  if (props.filter) items = items.filter(props.filter);
  const selectedItems = (0,external_react_.useMemo)(() => new Set(selected.map(item => item.metadata.pubkey)), [selected]);
  const {
    0: visible,
    1: setVisible
  } = (0,external_react_.useState)(false);

  const open = () => {
    clear();
    setVisible(true);
  };

  const close = () => {
    setVisible(false);
  };

  const clear = () => {
    setSelected([]);
  };

  const confirm = () => {
    close();
  };

  return /*#__PURE__*/(0,jsx_runtime_.jsxs)(jsx_runtime_.Fragment, {
    children: [/*#__PURE__*/(0,jsx_runtime_.jsxs)("div", {
      className: "artwork-grid",
      children: [selected.map(m => {
        const key = (m === null || m === void 0 ? void 0 : m.metadata.pubkey) || '';
        return /*#__PURE__*/jsx_runtime_.jsx(auctionCreate_AuctionItemCard, {
          current: m,
          onSelect: open,
          onClose: () => {
            setSelected(selected.filter(_ => _.metadata.pubkey !== key));
            confirm();
          }
        }, key);
      }), (allowMultiple || selectedItems.size === 0) && /*#__PURE__*/jsx_runtime_.jsx("div", {
        className: "ant-card ant-card-bordered ant-card-hoverable art-card",
        style: {
          width: 200,
          height: 300,
          display: 'flex'
        },
        onClick: open,
        children: /*#__PURE__*/jsx_runtime_.jsx("span", {
          className: "text-center",
          children: "Add an NFT"
        })
      })]
    }), /*#__PURE__*/(0,jsx_runtime_.jsxs)(external_antd_.Modal, {
      visible: visible,
      onCancel: close,
      onOk: confirm,
      width: 1100,
      footer: null,
      className: 'modalp-40 big-modal',
      children: [/*#__PURE__*/(0,jsx_runtime_.jsxs)(external_antd_.Row, {
        className: "call-to-action",
        style: {
          marginBottom: 0
        },
        children: [/*#__PURE__*/jsx_runtime_.jsx("h2", {
          children: "Select the NFT you want to sell"
        }), /*#__PURE__*/jsx_runtime_.jsx("p", {
          style: {
            fontSize: '1.2rem'
          },
          children: "Select the NFT that you want to sell copy/copies of."
        })]
      }), /*#__PURE__*/jsx_runtime_.jsx(external_antd_.Row, {
        className: "content-action",
        style: {
          overflowY: 'auto',
          height: '50vh'
        },
        children: /*#__PURE__*/jsx_runtime_.jsx("div", {
          className: "artwork-grid",
          children: items.map(m => {
            const id = m.metadata.pubkey;
            const isSelected = selectedItems.has(id);

            const onSelect = () => {
              let list = [...selectedItems.keys()];

              if (allowMultiple) {
                list = [];
              }

              const newSet = isSelected ? new Set(list.filter(item => item !== id)) : new Set([...list, id]);
              const selected = items.filter(item => newSet.has(item.metadata.pubkey));
              setSelected(selected);

              if (!allowMultiple) {
                confirm();
              }
            };

            return /*#__PURE__*/jsx_runtime_.jsx(auctionCreate_AuctionItemCard, {
              isSelected: isSelected,
              current: m,
              onSelect: onSelect
            }, id);
          })
        })
      }), /*#__PURE__*/jsx_runtime_.jsx(external_antd_.Row, {
        children: /*#__PURE__*/jsx_runtime_.jsx(external_antd_.Button, {
          type: "primary",
          size: "large",
          onClick: confirm,
          className: "action-btn",
          children: "Confirm"
        })
      })]
    })]
  });
};
;// CONCATENATED MODULE: ./src/actions/addTokensToVault.ts







const addTokensToVault_BATCH_SIZE = 1; // This command batches out adding tokens to a vault using a prefilled payer account, and then activates and combines
// the vault for use. It issues a series of transaction instructions and signers for the sendTransactions batch.

async function addTokensToVault(connection, wallet, vault, nfts) {
  if (!wallet.publicKey) throw new wallet_adapter_base_.WalletNotConnectedError();
  const PROGRAM_IDS = lib.utils.programIds();
  const accountRentExempt = await connection.getMinimumBalanceForRentExemption(spl_token_.AccountLayout.span);
  const vaultAuthority = (await (0,lib.findProgramAddress)([Buffer.from(actions_vault.VAULT_PREFIX), (0,lib.toPublicKey)(PROGRAM_IDS.vault).toBuffer(), (0,lib.toPublicKey)(vault).toBuffer()], (0,lib.toPublicKey)(PROGRAM_IDS.vault)))[0];
  let batchCounter = 0;
  const signers = [];
  const instructions = [];
  const newStores = [];
  let currSigners = [];
  let currInstructions = [];

  for (let i = 0; i < nfts.length; i++) {
    const nft = nfts[i];

    if (nft.box.tokenAccount) {
      const newStoreAccount = (0,account.createTokenAccount)(currInstructions, wallet.publicKey, accountRentExempt, (0,lib.toPublicKey)(nft.box.tokenMint), (0,lib.toPublicKey)(vaultAuthority), currSigners);
      newStores.push(newStoreAccount.toBase58());
      const transferAuthority = (0,models_account.approve)(currInstructions, [], (0,lib.toPublicKey)(nft.box.tokenAccount), wallet.publicKey, nft.box.amount.toNumber());
      currSigners.push(transferAuthority);
      await (0,actions_vault.addTokenToInactiveVault)(nft.draft.masterEdition && nft.draft.masterEdition.info.key === lib.MetadataKey.MasterEditionV2 ? new (external_bn_js_default())(1) : nft.box.amount, nft.box.tokenMint, nft.box.tokenAccount, newStoreAccount.toBase58(), vault, wallet.publicKey.toBase58(), wallet.publicKey.toBase58(), transferAuthority.publicKey.toBase58(), currInstructions);

      if (batchCounter === addTokensToVault_BATCH_SIZE) {
        signers.push(currSigners);
        instructions.push(currInstructions);
        batchCounter = 0;
        currSigners = [];
        currInstructions = [];
      }

      batchCounter++;
    }
  }

  if (instructions[instructions.length - 1] !== currInstructions) {
    signers.push(currSigners);
    instructions.push(currInstructions);
  }

  return {
    signers,
    instructions,
    safetyDepositTokenStores: newStores
  };
}
;// CONCATENATED MODULE: ./src/actions/createExternalPriceAccount.ts





 // This command creates the external pricing oracle

async function createExternalPriceAccount(connection, wallet) {
  if (!wallet.publicKey) throw new wallet_adapter_base_.WalletNotConnectedError();
  const PROGRAM_IDS = lib.utils.programIds();
  const signers = [];
  const instructions = [];
  const epaRentExempt = await connection.getMinimumBalanceForRentExemption(actions_vault.MAX_EXTERNAL_ACCOUNT_SIZE);
  const externalPriceAccount = web3_js_.Keypair.generate();
  const key = externalPriceAccount.publicKey.toBase58();
  const epaStruct = new actions_vault.ExternalPriceAccount({
    pricePerShare: new (external_bn_js_default())(0),
    priceMint: QUOTE_MINT.toBase58(),
    allowedToCombine: true
  });
  const uninitializedEPA = web3_js_.SystemProgram.createAccount({
    fromPubkey: wallet.publicKey,
    newAccountPubkey: externalPriceAccount.publicKey,
    lamports: epaRentExempt,
    space: actions_vault.MAX_EXTERNAL_ACCOUNT_SIZE,
    programId: (0,lib.toPublicKey)(PROGRAM_IDS.vault)
  });
  instructions.push(uninitializedEPA);
  signers.push(externalPriceAccount);
  await (0,actions_vault.updateExternalPriceAccount)(key, epaStruct, instructions);
  return {
    externalPriceAccount: key,
    priceMint: QUOTE_MINT.toBase58(),
    instructions,
    signers
  };
}
// EXTERNAL MODULE: ../common/dist/lib/models/metaplex/deprecatedValidateParticipation.js
var deprecatedValidateParticipation = __webpack_require__(9041);
;// CONCATENATED MODULE: ./src/actions/deprecatedCreateReservationListsForTokens.ts



const deprecatedCreateReservationListsForTokens_BATCH_SIZE = 10; // This command batches out creating reservation lists for those tokens who are being sold in PrintingV1 mode.
// Reservation lists are used to insure printing order among limited editions.

async function deprecatedCreateReservationListForTokens(wallet, auctionManager, safetyDepositInstructionTemplates) {
  if (!wallet.publicKey) throw new wallet_adapter_base_.WalletNotConnectedError();
  let batchCounter = 0;
  const signers = [];
  const instructions = [];
  let currSigners = [];
  let currInstructions = [];

  for (let i = 0; i < safetyDepositInstructionTemplates.length; i++) {
    const safetyDeposit = safetyDepositInstructionTemplates[i];
    if (safetyDeposit.config.winningConfigType === metaplex.WinningConfigType.PrintingV1 && safetyDeposit.draft.masterEdition) await (0,lib.deprecatedCreateReservationList)(safetyDeposit.draft.metadata.pubkey, safetyDeposit.draft.masterEdition.pubkey, auctionManager, wallet.publicKey.toBase58(), wallet.publicKey.toBase58(), currInstructions);

    if (batchCounter === deprecatedCreateReservationListsForTokens_BATCH_SIZE) {
      signers.push(currSigners);
      instructions.push(currInstructions);
      batchCounter = 0;
      currSigners = [];
      currInstructions = [];
    }

    batchCounter++;
  }

  if (instructions[instructions.length - 1] !== currInstructions) {
    signers.push(currSigners);
    instructions.push(currInstructions);
  }

  return {
    signers,
    instructions
  };
}
;// CONCATENATED MODULE: ./src/actions/deprecatedPopulatePrintingTokens.ts



const deprecatedPopulatePrintingTokens_BATCH_SIZE = 4; // Printing tokens are minted on the fly as needed. We need to pre-mint them to give to the vault
// for all relevant NFTs.

async function deprecatedPopulatePrintingTokens(connection, wallet, safetyDepositConfigs) {
  if (!wallet.publicKey) throw new wallet_adapter_base_.WalletNotConnectedError();
  const PROGRAM_IDS = lib.utils.programIds();
  let batchCounter = 0;
  const signers = [];
  const instructions = [];
  let currSigners = [];
  let currInstructions = [];

  for (let i = 0; i < safetyDepositConfigs.length; i++) {
    var _nft$draft$masterEdit, _nft$draft$masterEdit2;

    const nft = safetyDepositConfigs[i];

    if (((_nft$draft$masterEdit = nft.draft.masterEdition) === null || _nft$draft$masterEdit === void 0 ? void 0 : _nft$draft$masterEdit.info.key) != lib.MetadataKey.MasterEditionV1) {
      continue;
    }

    const printingMint = (_nft$draft$masterEdit2 = nft.draft.masterEdition) === null || _nft$draft$masterEdit2 === void 0 ? void 0 : _nft$draft$masterEdit2.info.printingMint;

    if (nft.box.tokenMint === printingMint && !nft.box.tokenAccount) {
      const holdingKey = (await (0,lib.findProgramAddress)([wallet.publicKey.toBuffer(), PROGRAM_IDS.token.toBuffer(), (0,lib.toPublicKey)(printingMint).toBuffer()], PROGRAM_IDS.associatedToken))[0];
      (0,lib.createAssociatedTokenAccountInstruction)(currInstructions, (0,lib.toPublicKey)(holdingKey), wallet.publicKey, wallet.publicKey, (0,lib.toPublicKey)(printingMint));
      console.log('Making atas');
      nft.draft.printingMintHolding = holdingKey;
      nft.box.tokenAccount = holdingKey;
    }

    if (nft.box.tokenAccount && nft.box.tokenMint === printingMint) {
      let balance = 0;

      try {
        balance = (await connection.getTokenAccountBalance((0,lib.toPublicKey)(nft.box.tokenAccount))).value.uiAmount || 0;
      } catch (e) {
        console.error(e);
      }

      if (balance < nft.box.amount.toNumber() && nft.draft.masterEdition) await (0,lib.deprecatedMintPrintingTokens)(nft.box.tokenAccount, nft.box.tokenMint, wallet.publicKey.toBase58(), nft.draft.metadata.pubkey, nft.draft.masterEdition.pubkey, new (external_bn_js_default())(nft.box.amount.toNumber() - balance), currInstructions);
      batchCounter++;
    }

    if (batchCounter === deprecatedPopulatePrintingTokens_BATCH_SIZE) {
      signers.push(currSigners);
      instructions.push(currInstructions);
      batchCounter = 0;
      currSigners = [];
      currInstructions = [];
    }
  }

  if (instructions[instructions.length - 1] !== currInstructions) {
    signers.push(currSigners);
    instructions.push(currInstructions);
  }

  return {
    signers,
    instructions,
    safetyDepositConfigs
  };
}
;// CONCATENATED MODULE: ./src/actions/setVaultAndAuctionAuthorities.ts

 // This command sets the authorities on the vault and auction to be the newly created auction manager.

async function setVaultAndAuctionAuthorities(wallet, vault, auction, auctionManager) {
  if (!wallet.publicKey) throw new wallet_adapter_base_.WalletNotConnectedError();
  const signers = [];
  const instructions = [];
  await (0,lib.setAuctionAuthority)(auction, wallet.publicKey.toBase58(), auctionManager, instructions);
  await (0,lib.setVaultAuthority)(vault, wallet.publicKey.toBase58(), auctionManager, instructions);
  return {
    instructions,
    signers
  };
}
;// CONCATENATED MODULE: ./src/actions/markItemsThatArentMineAsSold.ts


const SALE_TRANSACTION_SIZE = 10;
async function markItemsThatArentMineAsSold(wallet, safetyDepositDrafts) {
  if (!wallet.publicKey) throw new wallet_adapter_base_.WalletNotConnectedError();
  const publicKey = wallet.publicKey.toBase58();
  const signers = [];
  const instructions = [];
  let markSigners = [];
  let markInstructions = []; // TODO replace all this with payer account so user doesnt need to click approve several times.

  for (let i = 0; i < safetyDepositDrafts.length; i++) {
    var _item$info$data$creat;

    const item = safetyDepositDrafts[i].metadata;

    if (!((_item$info$data$creat = item.info.data.creators) !== null && _item$info$data$creat !== void 0 && _item$info$data$creat.find(c => c.address === publicKey)) && !item.info.primarySaleHappened) {
      console.log('For token', item.info.data.name, 'marking it sold because i didnt make it but i want to keep proceeds');
      await (0,lib.updatePrimarySaleHappenedViaToken)(item.pubkey, publicKey, safetyDepositDrafts[i].holding, markInstructions);

      if (markInstructions.length === SALE_TRANSACTION_SIZE) {
        signers.push(markSigners);
        instructions.push(markInstructions);
        markSigners = [];
        markInstructions = [];
      }
    }
  }

  if (markInstructions.length < SALE_TRANSACTION_SIZE && markInstructions.length > 0) {
    signers.push(markSigners);
    instructions.push(markInstructions);
  }

  return {
    instructions,
    signers
  };
}
// EXTERNAL MODULE: ../common/dist/lib/models/metaplex/validateSafetyDepositBoxV2.js
var validateSafetyDepositBoxV2 = __webpack_require__(3751);
// EXTERNAL MODULE: ../common/dist/lib/models/metaplex/initAuctionManagerV2.js
var initAuctionManagerV2 = __webpack_require__(3607);
// EXTERNAL MODULE: ../common/dist/lib/models/metaplex/setStoreIndex.js
var setStoreIndex = __webpack_require__(3290);
// EXTERNAL MODULE: ../common/dist/lib/models/metaplex/setAuctionCache.js
var setAuctionCache = __webpack_require__(3446);
;// CONCATENATED MODULE: ./src/actions/cacheAuctionInIndexer.ts





 // This command caches an auction at position 0, page 0, and moves everything up

async function cacheAuctionIndexer(wallet, vault, auction, auctionManager, tokenMints, storeIndexer, skipCache) {
  if (!wallet.publicKey) throw new wallet_adapter_base_.WalletNotConnectedError();
  const payer = wallet.publicKey.toBase58();
  const instructions = [];
  const {
    auctionCache,
    instructions: createAuctionCacheInstructions,
    signers: createAuctionCacheSigners
  } = await createAuctionCache(wallet, vault, auction, auctionManager, tokenMints);
  const above = storeIndexer.length == 0 ? undefined : storeIndexer[0].info.auctionCaches[0];
  const storeIndexKey = await (0,metaplex.getStoreIndexer)(0);
  await (0,setStoreIndex/* setStoreIndex */.I)(storeIndexKey, auctionCache, payer, new (external_bn_js_default())(0), new (external_bn_js_default())(0), instructions, undefined, above);
  const {
    instructions: propagationInstructions,
    signers: propagationSigners
  } = await propagateIndex(wallet, storeIndexer);
  return {
    instructions: [...(skipCache ? [] : createAuctionCacheInstructions), instructions, ...propagationInstructions],
    signers: [...(skipCache ? [] : createAuctionCacheSigners), [], ...propagationSigners]
  };
}
const INDEX_TRANSACTION_SIZE = 10;

async function propagateIndex(wallet, storeIndexer) {
  if (!wallet.publicKey) throw new wallet_adapter_base_.WalletNotConnectedError();
  const payer = wallet.publicKey.toBase58();
  const currSignerBatch = [];
  const currInstrBatch = [];
  let indexSigners = [];
  let indexInstructions = [];
  let currPage = storeIndexer[0];
  let lastPage = null;

  while (currPage && currPage.info.auctionCaches.length == metaplex.MAX_INDEXED_ELEMENTS) {
    const cacheLeavingThePage = currPage.info.auctionCaches[currPage.info.auctionCaches.length - 1];
    const nextPage = storeIndexer[currPage.info.page.toNumber() + 1];

    if (nextPage) {
      lastPage = currPage;
      currPage = nextPage;
    } else {
      lastPage = currPage;
      currPage = null;
    }

    const storeIndexKey = currPage ? currPage.pubkey : await (0,metaplex.getStoreIndexer)(lastPage.info.page.toNumber() + 1);
    const above = currPage ? currPage.info.auctionCaches[0] : undefined;
    await (0,setStoreIndex/* setStoreIndex */.I)(storeIndexKey, cacheLeavingThePage, payer, lastPage.info.page.add(new (external_bn_js_default())(1)), new (external_bn_js_default())(0), indexInstructions, undefined, above);

    if (indexInstructions.length >= INDEX_TRANSACTION_SIZE) {
      currSignerBatch.push(indexSigners);
      currInstrBatch.push(indexInstructions);
      indexSigners = [];
      indexInstructions = [];
    }
  }

  if (indexInstructions.length < INDEX_TRANSACTION_SIZE && indexInstructions.length > 0) {
    currSignerBatch.push(indexSigners);
    currInstrBatch.push(indexInstructions);
  }

  return {
    instructions: currInstrBatch,
    signers: currSignerBatch
  };
}

const TRANSACTION_SIZE = 10;

async function createAuctionCache(wallet, vault, auction, auctionManager, tokenMints) {
  if (!wallet.publicKey) throw new wallet_adapter_base_.WalletNotConnectedError();
  const payer = wallet.publicKey.toBase58();
  const currSignerBatch = [];
  const currInstrBatch = [];
  let cacheSigners = [];
  let cacheInstructions = [];
  const auctionCache = await (0,metaplex.getAuctionCache)(auction);

  for (let i = 0; i < tokenMints.length; i++) {
    const safetyDeposit = await (0,actions_vault.getSafetyDepositBoxAddress)(vault, tokenMints[i]);
    await (0,setAuctionCache/* setAuctionCache */.t)(auctionCache, payer, auction, safetyDeposit, auctionManager, new (external_bn_js_default())(0), cacheInstructions);

    if (cacheInstructions.length >= TRANSACTION_SIZE) {
      currSignerBatch.push(cacheSigners);
      currInstrBatch.push(cacheInstructions);
      cacheSigners = [];
      cacheInstructions = [];
    }
  }

  if (cacheInstructions.length < TRANSACTION_SIZE && cacheInstructions.length > 0) {
    currSignerBatch.push(cacheSigners);
    currInstrBatch.push(cacheInstructions);
  }

  return {
    auctionCache,
    instructions: currInstrBatch,
    signers: currSignerBatch
  };
}
;// CONCATENATED MODULE: ./src/actions/createAuctionManager.ts




















// This is a super command that executes many transactions to create a Vault, Auction, and AuctionManager starting
// from some AuctionManagerSettings.
async function createAuctionManager(connection, wallet, whitelistedCreatorsByCreator, auctionSettings, safetyDepositDrafts, participationSafetyDepositDraft, paymentMint, storeIndexer) {
  var _participationSafetyD, _lookup$deprecatedBui, _lookup$deprecatedVal, _lookup$deprecatedBui2, _lookup$deprecatedVal2;

  const accountRentExempt = await connection.getMinimumBalanceForRentExemption(spl_token_.AccountLayout.span);
  const {
    externalPriceAccount,
    priceMint,
    instructions: epaInstructions,
    signers: epaSigners
  } = await createExternalPriceAccount(connection, wallet);
  const {
    instructions: createVaultInstructions,
    signers: createVaultSigners,
    vault,
    fractionalMint,
    redeemTreasury,
    fractionTreasury
  } = await createVault(connection, wallet, priceMint, externalPriceAccount);
  const {
    instructions: makeAuctionInstructions,
    signers: makeAuctionSigners,
    auction
  } = await makeAuction(wallet, vault, auctionSettings);
  const safetyDepositConfigsWithPotentiallyUnsetTokens = await buildSafetyDepositArray(wallet, safetyDepositDrafts, participationSafetyDepositDraft); // Only creates for PrintingV1 deprecated configs

  const {
    instructions: populateInstr,
    signers: populateSigners,
    safetyDepositConfigs
  } = await deprecatedPopulatePrintingTokens(connection, wallet, safetyDepositConfigsWithPotentiallyUnsetTokens);
  const {
    instructions: auctionManagerInstructions,
    signers: auctionManagerSigners,
    auctionManager
  } = await setupAuctionManagerInstructions(wallet, vault, paymentMint, accountRentExempt, safetyDepositConfigs, auctionSettings);
  const {
    instructions: addTokenInstructions,
    signers: addTokenSigners,
    safetyDepositTokenStores
  } = await addTokensToVault(connection, wallet, vault, safetyDepositConfigs); // Only creates for deprecated PrintingV1 configs

  const {
    instructions: createReservationInstructions,
    signers: createReservationSigners
  } = await deprecatedCreateReservationListForTokens(wallet, auctionManager, safetyDepositConfigs);
  const lookup = {
    markItemsThatArentMineAsSold: await markItemsThatArentMineAsSold(wallet, safetyDepositDrafts),
    externalPriceAccount: {
      instructions: epaInstructions,
      signers: epaSigners
    },
    createVault: {
      instructions: createVaultInstructions,
      signers: createVaultSigners
    },
    closeVault: await closeVault(connection, wallet, vault, fractionalMint, fractionTreasury, redeemTreasury, priceMint, externalPriceAccount),
    addTokens: {
      instructions: addTokenInstructions,
      signers: addTokenSigners
    },
    deprecatedCreateReservationList: {
      instructions: createReservationInstructions,
      signers: createReservationSigners
    },
    makeAuction: {
      instructions: makeAuctionInstructions,
      signers: makeAuctionSigners
    },
    initAuctionManager: {
      instructions: auctionManagerInstructions,
      signers: auctionManagerSigners
    },
    setVaultAndAuctionAuthorities: await setVaultAndAuctionAuthorities(wallet, vault, auction, auctionManager),
    startAuction: await setupStartAuction(wallet, vault),
    deprecatedValidateParticipation: participationSafetyDepositDraft ? await deprecatedValidateParticipationHelper(wallet, auctionManager, whitelistedCreatorsByCreator, vault, safetyDepositTokenStores[safetyDepositTokenStores.length - 1], // The last one is always the participation
    participationSafetyDepositDraft, accountRentExempt) : undefined,
    deprecatedBuildAndPopulateOneTimeAuthorizationAccount: participationSafetyDepositDraft ? await deprecatedBuildAndPopulateOneTimeAuthorizationAccount(connection, wallet, participationSafetyDepositDraft === null || participationSafetyDepositDraft === void 0 ? void 0 : (_participationSafetyD = participationSafetyDepositDraft.masterEdition) === null || _participationSafetyD === void 0 ? void 0 : _participationSafetyD.info.oneTimePrintingAuthorizationMint) : undefined,
    validateBoxes: await validateBoxes(wallet, whitelistedCreatorsByCreator, vault, // Participation NFTs validate differently, with above
    safetyDepositConfigs.filter(c => {
      var _participationSafetyD2, _participationSafetyD3;

      return !participationSafetyDepositDraft || ((_participationSafetyD2 = participationSafetyDepositDraft.masterEdition) === null || _participationSafetyD2 === void 0 ? void 0 : _participationSafetyD2.info.key) == lib.MetadataKey.MasterEditionV1 && c.draft.metadata.pubkey !== participationSafetyDepositDraft.metadata.pubkey || ((_participationSafetyD3 = participationSafetyDepositDraft.masterEdition) === null || _participationSafetyD3 === void 0 ? void 0 : _participationSafetyD3.info.key) == lib.MetadataKey.MasterEditionV2;
    }), safetyDepositTokenStores),
    deprecatedPopulatePrintingTokens: {
      instructions: populateInstr,
      signers: populateSigners
    },
    cacheAuctionIndexer: await cacheAuctionIndexer(wallet, vault, auction, auctionManager, safetyDepositConfigs.map(s => s.draft.metadata.info.mint), storeIndexer)
  };
  const signers = [...lookup.markItemsThatArentMineAsSold.signers, lookup.externalPriceAccount.signers, ((_lookup$deprecatedBui = lookup.deprecatedBuildAndPopulateOneTimeAuthorizationAccount) === null || _lookup$deprecatedBui === void 0 ? void 0 : _lookup$deprecatedBui.signers) || [], ...lookup.deprecatedPopulatePrintingTokens.signers, lookup.createVault.signers, ...lookup.addTokens.signers, ...lookup.deprecatedCreateReservationList.signers, lookup.closeVault.signers, lookup.makeAuction.signers, lookup.initAuctionManager.signers, lookup.setVaultAndAuctionAuthorities.signers, ((_lookup$deprecatedVal = lookup.deprecatedValidateParticipation) === null || _lookup$deprecatedVal === void 0 ? void 0 : _lookup$deprecatedVal.signers) || [], ...lookup.validateBoxes.signers, lookup.startAuction.signers, ...lookup.cacheAuctionIndexer.signers];
  const toRemoveSigners = {};
  let instructions = [...lookup.markItemsThatArentMineAsSold.instructions, lookup.externalPriceAccount.instructions, ((_lookup$deprecatedBui2 = lookup.deprecatedBuildAndPopulateOneTimeAuthorizationAccount) === null || _lookup$deprecatedBui2 === void 0 ? void 0 : _lookup$deprecatedBui2.instructions) || [], ...lookup.deprecatedPopulatePrintingTokens.instructions, lookup.createVault.instructions, ...lookup.addTokens.instructions, ...lookup.deprecatedCreateReservationList.instructions, lookup.closeVault.instructions, lookup.makeAuction.instructions, lookup.initAuctionManager.instructions, lookup.setVaultAndAuctionAuthorities.instructions, ((_lookup$deprecatedVal2 = lookup.deprecatedValidateParticipation) === null || _lookup$deprecatedVal2 === void 0 ? void 0 : _lookup$deprecatedVal2.instructions) || [], ...lookup.validateBoxes.instructions, lookup.startAuction.instructions, ...lookup.cacheAuctionIndexer.instructions].filter((instr, i) => {
    if (instr.length > 0) {
      return true;
    } else {
      toRemoveSigners[i] = true;
      return false;
    }
  });
  let filteredSigners = signers.filter((_, i) => !toRemoveSigners[i]);
  let stopPoint = 0;
  let tries = 0;
  let lastInstructionsLength = null;

  while (stopPoint < instructions.length && tries < 3) {
    instructions = instructions.slice(stopPoint, instructions.length);
    filteredSigners = filteredSigners.slice(stopPoint, filteredSigners.length);
    if (instructions.length === lastInstructionsLength) tries = tries + 1;else tries = 0;

    try {
      if (instructions.length === 1) {
        await (0,lib.sendTransactionWithRetry)(connection, wallet, instructions[0], filteredSigners[0], 'single');
        stopPoint = 1;
      } else {
        stopPoint = await (0,lib.sendTransactions)(connection, wallet, instructions, filteredSigners, lib.SequenceType.StopOnFailure, 'single');
      }
    } catch (e) {
      console.error(e);
    }

    console.log('Died on ', stopPoint, 'retrying from instruction', instructions[stopPoint], 'instructions length is', instructions.length);
    lastInstructionsLength = instructions.length;
  }

  if (stopPoint < instructions.length) throw new Error('Failed to create');
  return {
    vault,
    auction,
    auctionManager
  };
}

async function buildSafetyDepositArray(wallet, safetyDeposits, participationSafetyDepositDraft) {
  if (!wallet.publicKey) throw new wallet_adapter_base_.WalletNotConnectedError();
  const safetyDepositTemplates = [];
  safetyDeposits.forEach((s, i) => {
    var _s$masterEdition;

    const maxAmount = [...s.amountRanges.map(a => a.amount)].sort().reverse()[0];
    const maxLength = [...s.amountRanges.map(a => a.length)].sort().reverse()[0];
    safetyDepositTemplates.push({
      box: {
        tokenAccount: s.winningConfigType !== metaplex.WinningConfigType.PrintingV1 ? s.holding : s.printingMintHolding,
        tokenMint: s.winningConfigType !== metaplex.WinningConfigType.PrintingV1 ? s.metadata.info.mint : (_s$masterEdition = s.masterEdition) === null || _s$masterEdition === void 0 ? void 0 : _s$masterEdition.info.printingMint,
        amount: s.winningConfigType == metaplex.WinningConfigType.PrintingV2 || s.winningConfigType == metaplex.WinningConfigType.FullRightsTransfer ? new (external_bn_js_default())(1) : new (external_bn_js_default())(s.amountRanges.reduce((acc, r) => acc.add(r.amount.mul(r.length)), new (external_bn_js_default())(0)))
      },
      config: new metaplex.SafetyDepositConfig({
        directArgs: {
          auctionManager: web3_js_.SystemProgram.programId.toBase58(),
          order: new (external_bn_js_default())(i),
          amountRanges: s.amountRanges,
          amountType: maxAmount.gte(new (external_bn_js_default())(254)) ? metaplex.TupleNumericType.U16 : metaplex.TupleNumericType.U8,
          lengthType: maxLength.gte(new (external_bn_js_default())(254)) ? metaplex.TupleNumericType.U16 : metaplex.TupleNumericType.U8,
          winningConfigType: s.winningConfigType,
          participationConfig: null,
          participationState: null
        }
      }),
      draft: s
    });
  });

  if (participationSafetyDepositDraft && participationSafetyDepositDraft.masterEdition) {
    const maxAmount = [...participationSafetyDepositDraft.amountRanges.map(s => s.amount)].sort().reverse()[0];
    const maxLength = [...participationSafetyDepositDraft.amountRanges.map(s => s.length)].sort().reverse()[0];
    const config = new metaplex.SafetyDepositConfig({
      directArgs: {
        auctionManager: web3_js_.SystemProgram.programId.toBase58(),
        order: new (external_bn_js_default())(safetyDeposits.length),
        amountRanges: participationSafetyDepositDraft.amountRanges,
        amountType: maxAmount !== null && maxAmount !== void 0 && maxAmount.gte(new (external_bn_js_default())(255)) ? metaplex.TupleNumericType.U32 : metaplex.TupleNumericType.U8,
        lengthType: maxLength !== null && maxLength !== void 0 && maxLength.gte(new (external_bn_js_default())(255)) ? metaplex.TupleNumericType.U32 : metaplex.TupleNumericType.U8,
        winningConfigType: metaplex.WinningConfigType.Participation,
        participationConfig: participationSafetyDepositDraft.participationConfig || null,
        participationState: new metaplex.ParticipationStateV2({
          collectedToAcceptPayment: new (external_bn_js_default())(0)
        })
      }
    });

    if (participationSafetyDepositDraft.masterEdition.info.key == lib.MetadataKey.MasterEditionV1) {
      const me = participationSafetyDepositDraft.masterEdition;
      safetyDepositTemplates.push({
        box: {
          tokenAccount: (await (0,lib.findProgramAddress)([wallet.publicKey.toBuffer(), (0,lib.programIds)().token.toBuffer(), (0,lib.toPublicKey)(me === null || me === void 0 ? void 0 : me.info.oneTimePrintingAuthorizationMint).toBuffer()], (0,lib.programIds)().associatedToken))[0],
          tokenMint: me === null || me === void 0 ? void 0 : me.info.oneTimePrintingAuthorizationMint,
          amount: new (external_bn_js_default())(1)
        },
        config,
        draft: participationSafetyDepositDraft
      });
    } else {
      safetyDepositTemplates.push({
        box: {
          tokenAccount: participationSafetyDepositDraft.holding,
          tokenMint: participationSafetyDepositDraft.metadata.info.mint,
          amount: new (external_bn_js_default())(1)
        },
        config,
        draft: participationSafetyDepositDraft
      });
    }
  }

  console.log('Temps', safetyDepositTemplates);
  return safetyDepositTemplates;
}

async function setupAuctionManagerInstructions(wallet, vault, paymentMint, accountRentExempt, safetyDeposits, auctionSettings) {
  var _programIds$store;

  if (!wallet.publicKey) throw new wallet_adapter_base_.WalletNotConnectedError();
  const store = (_programIds$store = (0,lib.programIds)().store) === null || _programIds$store === void 0 ? void 0 : _programIds$store.toBase58();

  if (!store) {
    throw new Error('Store not initialized');
  }

  const signers = [];
  const instructions = [];
  const {
    auctionManagerKey
  } = await (0,metaplex.getAuctionKeys)(vault);
  const acceptPayment = (0,account.createTokenAccount)(instructions, wallet.publicKey, accountRentExempt, (0,lib.toPublicKey)(paymentMint), (0,lib.toPublicKey)(auctionManagerKey), signers).toBase58();
  let maxRanges = [auctionSettings.winners.usize.toNumber(), safetyDeposits.length, 100].sort()[0];

  if (maxRanges < 10) {
    maxRanges = 10;
  }

  await (0,initAuctionManagerV2/* initAuctionManagerV2 */.J)(vault, wallet.publicKey.toBase58(), wallet.publicKey.toBase58(), acceptPayment, store, safetyDeposits.length >= 254 ? metaplex.TupleNumericType.U16 : metaplex.TupleNumericType.U8, auctionSettings.winners.usize.toNumber() >= 254 ? metaplex.TupleNumericType.U16 : metaplex.TupleNumericType.U8, new (external_bn_js_default())(maxRanges), instructions);
  return {
    instructions,
    signers,
    auctionManager: auctionManagerKey
  };
}

async function setupStartAuction(wallet, vault) {
  if (!wallet.publicKey) throw new wallet_adapter_base_.WalletNotConnectedError();
  const signers = [];
  const instructions = [];
  await (0,metaplex.startAuction)(vault, wallet.publicKey.toBase58(), instructions);
  return {
    instructions,
    signers
  };
}

async function deprecatedValidateParticipationHelper(wallet, auctionManager, whitelistedCreatorsByCreator, vault, tokenStore, participationSafetyDepositDraft, accountRentExempt) {
  var _programIds$store2;

  if (!wallet.publicKey) throw new wallet_adapter_base_.WalletNotConnectedError();
  const store = (_programIds$store2 = (0,lib.programIds)().store) === null || _programIds$store2 === void 0 ? void 0 : _programIds$store2.toBase58();

  if (!store) {
    throw new Error('Store not initialized');
  }

  const instructions = [];
  const signers = [];
  const whitelistedCreator = participationSafetyDepositDraft.metadata.info.data.creators ? await findValidWhitelistedCreator(whitelistedCreatorsByCreator, //@ts-ignore
  participationSafetyDepositDraft.metadata.info.data.creators) : undefined;
  const {
    auctionManagerKey
  } = await (0,metaplex.getAuctionKeys)(vault); // V2s do not need to call this special endpoint.

  if (participationSafetyDepositDraft.masterEdition && participationSafetyDepositDraft.masterEdition.info.key == lib.MetadataKey.MasterEditionV1) {
    var _participationSafetyD4;

    const me = participationSafetyDepositDraft.masterEdition;
    const printingTokenHoldingAccount = (0,account.createTokenAccount)(instructions, wallet.publicKey, accountRentExempt, (0,lib.toPublicKey)(me.info.printingMint), (0,lib.toPublicKey)(auctionManagerKey), signers).toBase58();
    await (0,deprecatedValidateParticipation/* deprecatedValidateParticipation */.I)(auctionManager, participationSafetyDepositDraft.metadata.pubkey, (_participationSafetyD4 = participationSafetyDepositDraft.masterEdition) === null || _participationSafetyD4 === void 0 ? void 0 : _participationSafetyD4.pubkey, printingTokenHoldingAccount, wallet.publicKey.toBase58(), whitelistedCreator, store, await (0,lib.getSafetyDepositBoxAddress)(vault, me.info.oneTimePrintingAuthorizationMint), tokenStore, vault, instructions);
  }

  return {
    instructions,
    signers
  };
}

async function findValidWhitelistedCreator(whitelistedCreatorsByCreator, creators) {
  var _creators$;

  for (let i = 0; i < creators.length; i++) {
    var _whitelistedCreatorsB;

    const creator = creators[i];
    if ((_whitelistedCreatorsB = whitelistedCreatorsByCreator[creator.address]) !== null && _whitelistedCreatorsB !== void 0 && _whitelistedCreatorsB.info.activated) return whitelistedCreatorsByCreator[creator.address].pubkey;
  }

  return await (0,metaplex.getWhitelistedCreator)((_creators$ = creators[0]) === null || _creators$ === void 0 ? void 0 : _creators$.address);
}

async function validateBoxes(wallet, whitelistedCreatorsByCreator, vault, safetyDeposits, safetyDepositTokenStores) {
  var _programIds$store3;

  if (!wallet.publicKey) throw new wallet_adapter_base_.WalletNotConnectedError();
  const store = (_programIds$store3 = (0,lib.programIds)().store) === null || _programIds$store3 === void 0 ? void 0 : _programIds$store3.toBase58();

  if (!store) {
    throw new Error('Store not initialized');
  }

  const signers = [];
  const instructions = [];

  for (let i = 0; i < safetyDeposits.length; i++) {
    const tokenSigners = [];
    const tokenInstructions = [];
    let safetyDepositBox;
    const me = safetyDeposits[i].draft.masterEdition;

    if (safetyDeposits[i].config.winningConfigType === metaplex.WinningConfigType.PrintingV1 && me && me.info.printingMint) {
      safetyDepositBox = await (0,lib.getSafetyDepositBox)(vault, //@ts-ignore
      safetyDeposits[i].draft.masterEdition.info.printingMint);
    } else {
      safetyDepositBox = await (0,lib.getSafetyDepositBox)(vault, safetyDeposits[i].draft.metadata.info.mint);
    }

    const edition = await (0,lib.getEdition)(safetyDeposits[i].draft.metadata.info.mint);
    const whitelistedCreator = safetyDeposits[i].draft.metadata.info.data.creators ? await findValidWhitelistedCreator(whitelistedCreatorsByCreator, //@ts-ignore
    safetyDeposits[i].draft.metadata.info.data.creators) : undefined;
    await (0,validateSafetyDepositBoxV2/* validateSafetyDepositBoxV2 */.e)(vault, safetyDeposits[i].draft.metadata.pubkey, safetyDepositBox, safetyDepositTokenStores[i], safetyDeposits[i].config.winningConfigType === metaplex.WinningConfigType.PrintingV1 ? me === null || me === void 0 ? void 0 : me.info.printingMint : safetyDeposits[i].draft.metadata.info.mint, wallet.publicKey.toBase58(), wallet.publicKey.toBase58(), wallet.publicKey.toBase58(), tokenInstructions, edition, whitelistedCreator, store, safetyDeposits[i].config);
    signers.push(tokenSigners);
    instructions.push(tokenInstructions);
  }

  return {
    instructions,
    signers
  };
}

async function deprecatedBuildAndPopulateOneTimeAuthorizationAccount(connection, wallet, oneTimePrintingAuthorizationMint) {
  if (!wallet.publicKey) throw new wallet_adapter_base_.WalletNotConnectedError();
  if (!oneTimePrintingAuthorizationMint) return {
    instructions: [],
    signers: []
  };
  const signers = [];
  const instructions = [];
  const recipientKey = (await (0,lib.findProgramAddress)([wallet.publicKey.toBuffer(), (0,lib.programIds)().token.toBuffer(), (0,lib.toPublicKey)(oneTimePrintingAuthorizationMint).toBuffer()], (0,lib.programIds)().associatedToken))[0];

  if (!(await connection.getAccountInfo((0,lib.toPublicKey)(recipientKey)))) {
    (0,lib.createAssociatedTokenAccountInstruction)(instructions, (0,lib.toPublicKey)(recipientKey), wallet.publicKey, wallet.publicKey, (0,lib.toPublicKey)(oneTimePrintingAuthorizationMint));
  }

  instructions.push(spl_token_.Token.createMintToInstruction((0,lib.programIds)().token, (0,lib.toPublicKey)(oneTimePrintingAuthorizationMint), (0,lib.toPublicKey)(recipientKey), wallet.publicKey, [], 1));
  return {
    instructions,
    signers
  };
}
;// CONCATENATED MODULE: ./src/components/DateTimePicker/index.tsx
function DateTimePicker_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

function DateTimePicker_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { DateTimePicker_ownKeys(Object(source), true).forEach(function (key) { DateTimePicker_defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { DateTimePicker_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function DateTimePicker_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }






const DateTimePicker = props => {
  const {
    momentObj,
    setMomentObj,
    datePickerProps = {},
    timePickerProps = {}
  } = props;
  return /*#__PURE__*/(0,jsx_runtime_.jsxs)(jsx_runtime_.Fragment, {
    children: [/*#__PURE__*/jsx_runtime_.jsx(external_antd_.DatePicker, DateTimePicker_objectSpread({
      className: "field-date",
      size: "large",
      value: momentObj,
      onChange: value => {
        if (!value) return;
        if (!momentObj) return setMomentObj(value);
        const currentMoment = momentObj.clone();
        currentMoment.year(value.year());
        currentMoment.month(value.month());
        currentMoment.date(value.date());
        setMomentObj(currentMoment);
      }
    }, datePickerProps)), /*#__PURE__*/jsx_runtime_.jsx(external_antd_.TimePicker, DateTimePicker_objectSpread({
      className: "field-date",
      size: "large",
      value: momentObj,
      onChange: value => {
        if (!value) return;
        if (!momentObj) return setMomentObj(value);
        const currentMoment = momentObj.clone();
        currentMoment.hour(value.hour());
        currentMoment.minute(value.minute());
        currentMoment.second(value.second());
        setMomentObj(currentMoment);
      }
    }, timePickerProps))]
  });
};
;// CONCATENATED MODULE: ./src/components/TokenDialog/index.tsx









const {
  Search
} = external_antd_.Input;
const {
  TabPane: TokenDialog_TabPane
} = external_antd_.Tabs;
let TokenViewState;

(function (TokenViewState) {
  TokenViewState["Main"] = "0";
  TokenViewState["Wormhole"] = "1";
  TokenViewState["Sollet"] = "2";
})(TokenViewState || (TokenViewState = {}));

function TokenButton({
  mint,
  onClick
}) {
  const tokenMap = useTokenList().subscribedTokens;
  const tokenInfo = tokenMap.filter(t => t.address == mint.toBase58())[0];
  return /*#__PURE__*/(0,jsx_runtime_.jsxs)(external_antd_.Row, {
    onClick: onClick,
    className: 'token-button',
    justify: "space-between",
    children: [/*#__PURE__*/jsx_runtime_.jsx(external_antd_.Col, {
      children: /*#__PURE__*/(0,jsx_runtime_.jsxs)(external_antd_.Row, {
        children: [/*#__PURE__*/jsx_runtime_.jsx(TokenCircle, {
          iconSize: 40,
          iconFile: tokenInfo === null || tokenInfo === void 0 ? void 0 : tokenInfo.logoURI,
          style: {
            marginTop: 2.5
          }
        }), /*#__PURE__*/jsx_runtime_.jsx(TokenName, {
          mint: mint
        })]
      })
    }), /*#__PURE__*/jsx_runtime_.jsx(external_antd_.Col, {
      children: /*#__PURE__*/jsx_runtime_.jsx(icons_.DownOutlined, {
        style: {
          marginLeft: 10,
          fontWeight: 700
        }
      })
    })]
  });
}
function TokenDialog({
  open,
  onClose,
  setMint
}) {
  const {
    0: tabSelection,
    1: setTabSelection
  } = (0,external_react_.useState)(TokenViewState.Main);
  const {
    0: tokenFilter,
    1: setTokenFilter
  } = (0,external_react_.useState)('');
  const filter = tokenFilter.toLowerCase();
  const {
    swappableTokens,
    swappableTokensSollet,
    swappableTokensWormhole
  } = useSwappableTokens();
  const selectedTokens = tabSelection === TokenViewState.Main ? swappableTokens : tabSelection === TokenViewState.Wormhole ? swappableTokensWormhole : swappableTokensSollet;
  const tokens = tokenFilter === '' ? selectedTokens : selectedTokens.filter(t => t.symbol.toLowerCase().startsWith(filter) || t.name.toLowerCase().startsWith(filter) || t.address.toLowerCase().startsWith(filter));

  const validateTokenMint = quoteMintAddress => {
    // try to convert to publicKey and check if it is on curve
    let quoteMintAddressOnCurve = false;

    try {
      quoteMintAddressOnCurve = web3_js_.PublicKey.isOnCurve((0,lib.toPublicKey)(quoteMintAddress).toBuffer().slice(0, 32));
    } catch {
      console.log('Not an ed25519 curve pubkey');
    }

    if (quoteMintAddressOnCurve) {
      console.log('MINT OK');
      setMint((0,lib.toPublicKey)(quoteMintAddress));
      onClose();
    }
  };

  return /*#__PURE__*/(0,jsx_runtime_.jsxs)(lib.MetaplexModal, {
    visible: open,
    onCancel: onClose,
    bodyStyle: {
      padding: '25px 0 0 0'
    },
    children: [/*#__PURE__*/(0,jsx_runtime_.jsxs)(external_antd_.Col, {
      className: 'dialog-header',
      children: [/*#__PURE__*/jsx_runtime_.jsx(external_antd_.Typography, {
        style: {
          paddingBottom: '16px',
          textAlign: 'center',
          textTransform: 'uppercase',
          fontWeight: 600
        },
        children: "Select a token as your auction mint"
      }), /*#__PURE__*/jsx_runtime_.jsx(external_antd_.Input, {
        autoFocus: true,
        className: "input text-field",
        placeholder: "Search token mints",
        allowClear: true,
        value: tokenFilter,
        onChange: e => setTokenFilter(e.target.value)
      })]
    }), /*#__PURE__*/(0,jsx_runtime_.jsxs)("div", {
      className: 'dialog-content',
      children: [/*#__PURE__*/jsx_runtime_.jsx(external_antd_.List, {
        style: {
          padding: '16px 0'
        },
        children: tokens.map(tokenInfo => /*#__PURE__*/jsx_runtime_.jsx(TokenListItem, {
          tokenInfo: tokenInfo,
          onClick: mint => {
            setMint(mint);
            console.log('SET MINT TO', mint.toBase58());
            onClose();
          }
        }, tokenInfo.address))
      }), /*#__PURE__*/jsx_runtime_.jsx(Search, {
        enterButton: "Go!",
        className: "input search-text-field",
        placeholder: "Can't find your token? set it here!",
        allowClear: true,
        size: "large",
        onSearch: e => validateTokenMint(e)
      })]
    }), /*#__PURE__*/(0,jsx_runtime_.jsxs)(external_antd_.Tabs, {
      activeKey: tabSelection,
      onTabClick: key => setTabSelection(key),
      className: 'token-tabs',
      children: [/*#__PURE__*/jsx_runtime_.jsx(TokenDialog_TabPane, {
        className: 'token-tab'
        /*  classes={{ selected: 'tab-selected' }} */
        ,
        tab: /*#__PURE__*/jsx_runtime_.jsx("span", {
          className: "tab-title",
          children: "Main"
        })
      }, TokenViewState.Main), /*#__PURE__*/jsx_runtime_.jsx(TokenDialog_TabPane, {
        className: 'token-tab'
        /* classes={{ selected: 'tab-selected' }} */
        ,
        tab: /*#__PURE__*/jsx_runtime_.jsx("span", {
          className: "tab-title",
          children: "Wormhole"
        })
      }, TokenViewState.Wormhole), /*#__PURE__*/jsx_runtime_.jsx(TokenDialog_TabPane, {
        className: 'token-tab'
        /* classes={{ selected: 'tab-selected' }} */
        ,
        tab: /*#__PURE__*/jsx_runtime_.jsx("span", {
          className: "tab-title",
          children: "Sollet"
        })
      }, TokenViewState.Sollet)]
    })]
  });
}

function TokenListItem({
  tokenInfo,
  onClick
}) {
  const mint = new web3_js_.PublicKey(tokenInfo.address);
  return /*#__PURE__*/(0,jsx_runtime_.jsxs)(external_antd_.List.Item, {
    onClick: () => onClick(mint),
    className: 'token-list-item',
    children: [/*#__PURE__*/jsx_runtime_.jsx(TokenIcon, {
      mint: mint,
      style: {
        width: '30px',
        borderRadius: '15px'
      }
    }), /*#__PURE__*/jsx_runtime_.jsx(TokenName, {
      mint: mint
    })]
  });
}

function TokenIcon({
  mint,
  style
}) {
  const tokenMap = useTokenList().tokenMap;
  const tokenInfo = tokenMap.get(mint.toString());
  return /*#__PURE__*/jsx_runtime_.jsx("div", {
    style: {
      display: 'flex',
      justifyContent: 'center',
      flexDirection: 'column'
    },
    children: tokenInfo !== null && tokenInfo !== void 0 && tokenInfo.logoURI ? /*#__PURE__*/jsx_runtime_.jsx("img", {
      alt: "Logo",
      style: style,
      src: tokenInfo === null || tokenInfo === void 0 ? void 0 : tokenInfo.logoURI
    }) : /*#__PURE__*/jsx_runtime_.jsx("div", {
      style: style
    })
  });
}

function TokenName({
  mint
}) {
  const tokenMap = useTokenList().tokenMap;
  const tokenInfo = tokenMap.get(mint.toString());
  const tokenName = tokenInfo ? tokenInfo.name : 'Custom Token';
  return /*#__PURE__*/(0,jsx_runtime_.jsxs)("div", {
    style: {
      marginLeft: '16px',
      overflow: 'hidden'
    },
    children: [/*#__PURE__*/jsx_runtime_.jsx("div", {
      style: {
        fontWeight: 500,
        color: 'white'
      },
      children: tokenInfo ? tokenName : `${(0,lib.shortenAddress)(mint.toBase58())}`
    }), /*#__PURE__*/jsx_runtime_.jsx("div", {
      color: "textSecondary",
      style: {
        fontSize: '14px',
        color: '#797A8C',
        whiteSpace: 'nowrap',
        overflow: 'hidden',
        textOverflow: 'ellipsis'
      },
      children: tokenName
    })]
  });
}
;// CONCATENATED MODULE: ./src/components/FundsIssueModal/index.tsx







const FundsIssueModal = props => {
  const {
    currentFunds: balance,
    minimumFunds,
    message
  } = props;
  const tokenInfo = useTokenList().subscribedTokens.filter(m => m.address == lib.WRAPPED_SOL_MINT.toBase58())[0];
  return /*#__PURE__*/(0,jsx_runtime_.jsxs)(lib.MetaplexModal, {
    title: "Transaction Alert",
    visible: props.isModalVisible,
    footer: null,
    onCancel: props.onClose,
    className: "fundsissue",
    closeIcon: /*#__PURE__*/jsx_runtime_.jsx("img", {
      src: '/modals/close.svg'
    }),
    children: [/*#__PURE__*/jsx_runtime_.jsx("b", {
      className: "issue-title",
      children: "Insufficient funds"
    }), /*#__PURE__*/jsx_runtime_.jsx("div", {
      className: "card-bid-info",
      children: /*#__PURE__*/jsx_runtime_.jsx(AmountLabel, {
        containerStyle: {
          flexDirection: 'row'
        },
        title: "Your Balance",
        displaySymbol: "SOL",
        amount: balance,
        iconSize: 24,
        tokenInfo: tokenInfo
      })
    }), /*#__PURE__*/jsx_runtime_.jsx("hr", {}), /*#__PURE__*/jsx_runtime_.jsx("div", {
      className: "card-bid-info",
      children: /*#__PURE__*/jsx_runtime_.jsx(AmountLabel, {
        containerStyle: {
          flexDirection: 'row'
        },
        title: message,
        displaySymbol: "SOL",
        amount: minimumFunds,
        iconSize: 24,
        tokenInfo: tokenInfo
      })
    }), /*#__PURE__*/jsx_runtime_.jsx("hr", {}), /*#__PURE__*/jsx_runtime_.jsx("span", {
      className: "issue-desc",
      children: "Deposit the minimum amount of SOL and try again."
    }), /*#__PURE__*/jsx_runtime_.jsx(external_antd_.Button, {
      className: "secondary-btn width-100",
      onClick: props.onClose,
      children: "Dismiss"
    })]
  });
};
;// CONCATENATED MODULE: ./src/views/auctionCreate/index.tsx
function auctionCreate_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

function auctionCreate_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { auctionCreate_ownKeys(Object(source), true).forEach(function (key) { auctionCreate_defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { auctionCreate_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function auctionCreate_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }





























const {
  Option
} = external_antd_.Select;
const {
  Step: auctionCreate_Step
} = external_antd_.Steps;
const {
  ZERO
} = lib.constants;
let AuctionCategory;

(function (AuctionCategory) {
  AuctionCategory[AuctionCategory["InstantSale"] = 0] = "InstantSale";
  AuctionCategory[AuctionCategory["Limited"] = 1] = "Limited";
  AuctionCategory[AuctionCategory["Single"] = 2] = "Single";
  AuctionCategory[AuctionCategory["Open"] = 3] = "Open";
  AuctionCategory[AuctionCategory["Tiered"] = 4] = "Tiered";
})(AuctionCategory || (AuctionCategory = {}));

var InstantSaleType;

(function (InstantSaleType) {
  InstantSaleType[InstantSaleType["Limited"] = 0] = "Limited";
  InstantSaleType[InstantSaleType["Single"] = 1] = "Single";
  InstantSaleType[InstantSaleType["Open"] = 2] = "Open";
})(InstantSaleType || (InstantSaleType = {}));

const AuctionCreateView = () => {
  const connection = (0,lib.useConnection)();
  const wallet = (0,wallet_adapter_react_.useWallet)();
  const {
    whitelistedCreatorsByCreator,
    storeIndexer
  } = (0,meta.useMeta)();
  const {
    step_param
  } = (0,external_react_router_dom_.useParams)();
  const history = (0,external_react_router_dom_.useHistory)();
  const mint = (0,lib.useMint)(QUOTE_MINT);
  const {
    width
  } = useWindowDimensions();
  const {
    0: step,
    1: setStep
  } = (0,external_react_.useState)(0);
  const {
    0: stepsVisible,
    1: setStepsVisible
  } = (0,external_react_.useState)(true);
  const {
    0: auctionObj,
    1: setAuctionObj
  } = (0,external_react_.useState)(undefined);
  const {
    0: attributes,
    1: setAttributes
  } = (0,external_react_.useState)({
    reservationPrice: 0,
    items: [],
    category: AuctionCategory.Open,
    auctionDurationType: 'minutes',
    gapTimeType: 'minutes',
    winnersCount: 1,
    startSaleTS: undefined,
    startListTS: undefined,
    quoteMintAddress: '',
    //@ts-ignore
    quoteMintInfo: undefined,
    //@ts-ignore
    quoteMintInfoExtended: undefined
  });
  const {
    0: tieredAttributes,
    1: setTieredAttributes
  } = (0,external_react_.useState)({
    items: [],
    tiers: []
  });
  (0,external_react_.useEffect)(() => {
    if (step_param) setStep(parseInt(step_param));else gotoNextStep(0);
  }, [step_param]);

  const gotoNextStep = _step => {
    const nextStep = _step === undefined ? step + 1 : _step;
    history.push(`/auction/create/${nextStep.toString()}`);
  };

  const createAuction = async () => {
    let winnerLimit; //const mint = attributes.quoteMintInfo

    if (attributes.category === AuctionCategory.InstantSale && attributes.instantSaleType === InstantSaleType.Open) {
      const {
        items,
        instantSalePrice
      } = attributes;

      if (items.length > 0 && items[0].participationConfig) {
        items[0].participationConfig.fixedPrice = new (external_bn_js_default())((0,lib.toLamports)(instantSalePrice, mint) || 0);
      }

      winnerLimit = new lib.WinnerLimit({
        type: lib.WinnerLimitType.Unlimited,
        usize: ZERO
      });
    } else if (attributes.category === AuctionCategory.InstantSale) {
      const {
        items,
        editions
      } = attributes;

      if (items.length > 0) {
        const item = items[0];

        if (!editions) {
          item.winningConfigType = item.metadata.info.updateAuthority === ((wallet === null || wallet === void 0 ? void 0 : wallet.publicKey) || web3_js_.SystemProgram.programId).toBase58() ? metaplex.WinningConfigType.FullRightsTransfer : metaplex.WinningConfigType.TokenOnlyTransfer;
        }

        item.amountRanges = [new metaplex.AmountRange({
          amount: new (external_bn_js_default())(1),
          length: new (external_bn_js_default())(editions || 1)
        })];
      }

      winnerLimit = new lib.WinnerLimit({
        type: lib.WinnerLimitType.Capped,
        usize: new (external_bn_js_default())(editions || 1)
      });
    } else if (attributes.category === AuctionCategory.Open) {
      if (attributes.items.length > 0 && attributes.items[0].participationConfig) {
        attributes.items[0].participationConfig.fixedPrice = new (external_bn_js_default())((0,lib.toLamports)(attributes.participationFixedPrice, mint) || 0);
      }

      winnerLimit = new lib.WinnerLimit({
        type: lib.WinnerLimitType.Unlimited,
        usize: ZERO
      });
    } else if (attributes.category === AuctionCategory.Limited || attributes.category === AuctionCategory.Single) {
      if (attributes.items.length > 0) {
        const item = attributes.items[0];

        if (attributes.category == AuctionCategory.Single && item.masterEdition) {
          item.winningConfigType = item.metadata.info.updateAuthority === ((wallet === null || wallet === void 0 ? void 0 : wallet.publicKey) || web3_js_.SystemProgram.programId).toBase58() ? metaplex.WinningConfigType.FullRightsTransfer : metaplex.WinningConfigType.TokenOnlyTransfer;
        }

        item.amountRanges = [new metaplex.AmountRange({
          amount: new (external_bn_js_default())(1),
          length: attributes.category === AuctionCategory.Single ? new (external_bn_js_default())(1) : new (external_bn_js_default())(attributes.editions || 1)
        })];
      }

      winnerLimit = new lib.WinnerLimit({
        type: lib.WinnerLimitType.Capped,
        usize: attributes.category === AuctionCategory.Single ? new (external_bn_js_default())(1) : new (external_bn_js_default())(attributes.editions || 1)
      });

      if (attributes.participationNFT && attributes.participationNFT.participationConfig) {
        attributes.participationNFT.participationConfig.fixedPrice = new (external_bn_js_default())((0,lib.toLamports)(attributes.participationFixedPrice, mint) || 0);
      }
    } else {
      const tiers = tieredAttributes.tiers;
      tiers.forEach(c => c.items = c.items.filter(i => i.winningConfigType !== undefined));
      const filteredTiers = tiers.filter(i => i.items.length > 0 && i.winningSpots.length > 0);
      tieredAttributes.items.forEach((config, index) => {
        let ranges = [];
        filteredTiers.forEach(tier => {
          const tierRangeLookup = {};
          const tierRanges = [];
          const item = tier.items.find(i => i.safetyDepositBoxIndex == index);

          if (item) {
            config.winningConfigType = item.winningConfigType;
            const sorted = tier.winningSpots.sort();
            sorted.forEach((spot, i) => {
              if (tierRangeLookup[spot - 1]) {
                tierRangeLookup[spot] = tierRangeLookup[spot - 1];
                tierRangeLookup[spot].length = tierRangeLookup[spot].length.add(new (external_bn_js_default())(1));
              } else {
                tierRangeLookup[spot] = new metaplex.AmountRange({
                  amount: new (external_bn_js_default())(item.amount),
                  length: new (external_bn_js_default())(1)
                }); // If the first spot with anything is winner spot 1, you want a section of 0 covering winning
                // spot 0.
                // If we have a gap, we want a gap area covered with zeroes.

                const zeroLength = i - 1 > 0 ? spot - sorted[i - 1] - 1 : spot;

                if (zeroLength > 0) {
                  tierRanges.push(new metaplex.AmountRange({
                    amount: new (external_bn_js_default())(0),
                    length: new (external_bn_js_default())(zeroLength)
                  }));
                }

                tierRanges.push(tierRangeLookup[spot]);
              }
            }); // Ok now we have combined ranges from this tier range. Now we merge them into the ranges
            // at the top level.

            const oldRanges = ranges;
            ranges = [];
            let oldRangeCtr = 0,
                tierRangeCtr = 0;

            while (oldRangeCtr < oldRanges.length || tierRangeCtr < tierRanges.length) {
              let toAdd = new (external_bn_js_default())(0);

              if (tierRangeCtr < tierRanges.length && tierRanges[tierRangeCtr].amount.gt(new (external_bn_js_default())(0))) {
                toAdd = tierRanges[tierRangeCtr].amount;
              }

              if (oldRangeCtr == oldRanges.length) {
                ranges.push(new metaplex.AmountRange({
                  amount: toAdd,
                  length: tierRanges[tierRangeCtr].length
                }));
                tierRangeCtr++;
              } else if (tierRangeCtr == tierRanges.length) {
                ranges.push(oldRanges[oldRangeCtr]);
                oldRangeCtr++;
              } else if (oldRanges[oldRangeCtr].length.gt(tierRanges[tierRangeCtr].length)) {
                oldRanges[oldRangeCtr].length = oldRanges[oldRangeCtr].length.sub(tierRanges[tierRangeCtr].length);
                ranges.push(new metaplex.AmountRange({
                  amount: oldRanges[oldRangeCtr].amount.add(toAdd),
                  length: tierRanges[tierRangeCtr].length
                }));
                tierRangeCtr += 1; // dont increment oldRangeCtr since i still have length to give
              } else if (tierRanges[tierRangeCtr].length.gt(oldRanges[oldRangeCtr].length)) {
                tierRanges[tierRangeCtr].length = tierRanges[tierRangeCtr].length.sub(oldRanges[oldRangeCtr].length);
                ranges.push(new metaplex.AmountRange({
                  amount: oldRanges[oldRangeCtr].amount.add(toAdd),
                  length: oldRanges[oldRangeCtr].length
                }));
                oldRangeCtr += 1; // dont increment tierRangeCtr since they still have length to give
              } else if (tierRanges[tierRangeCtr].length.eq(oldRanges[oldRangeCtr].length)) {
                ranges.push(new metaplex.AmountRange({
                  amount: oldRanges[oldRangeCtr].amount.add(toAdd),
                  length: oldRanges[oldRangeCtr].length
                })); // Move them both in this degen case

                oldRangeCtr++;
                tierRangeCtr++;
              }
            }
          }
        });
        console.log('Ranges');
        config.amountRanges = ranges;
      });
      winnerLimit = new lib.WinnerLimit({
        type: lib.WinnerLimitType.Capped,
        usize: new (external_bn_js_default())(attributes.winnersCount)
      });

      if (attributes.participationNFT && attributes.participationNFT.participationConfig) {
        attributes.participationNFT.participationConfig.fixedPrice = new (external_bn_js_default())((0,lib.toLamports)(attributes.participationFixedPrice, mint) || 0);
      }

      console.log('Tiered settings', tieredAttributes.items);
    }

    const isInstantSale = attributes.instantSalePrice && attributes.priceFloor === attributes.instantSalePrice;
    const LAMPORTS_PER_TOKEN = attributes.quoteMintAddress == lib.WRAPPED_SOL_MINT.toBase58() ? web3_js_.LAMPORTS_PER_SOL : Math.pow(10, attributes.quoteMintInfo.decimals || 0);
    const auctionSettings = {
      winners: winnerLimit,
      endAuctionAt: isInstantSale ? null : new (external_bn_js_default())((attributes.auctionDuration || 0) * (attributes.auctionDurationType == 'days' ? 60 * 60 * 24 // 1 day in seconds
      : attributes.auctionDurationType == 'hours' ? 60 * 60 // 1 hour in seconds
      : 60)),
      // endAuctionAt is actually auction duration, poorly named, in seconds
      auctionGap: isInstantSale ? null : new (external_bn_js_default())((attributes.gapTime || 0) * (attributes.gapTimeType == 'days' ? 60 * 60 * 24 // 1 day in seconds
      : attributes.gapTimeType == 'hours' ? 60 * 60 // 1 hour in seconds
      : 60)),
      priceFloor: new lib.PriceFloor({
        type: attributes.priceFloor ? lib.PriceFloorType.Minimum : lib.PriceFloorType.None,
        minPrice: new (external_bn_js_default())((attributes.priceFloor || 0) * LAMPORTS_PER_TOKEN)
      }),
      tokenMint: attributes.quoteMintAddress,
      gapTickSizePercentage: attributes.tickSizeEndingPhase || null,
      tickSize: attributes.priceTick ? new (external_bn_js_default())(attributes.priceTick * LAMPORTS_PER_TOKEN) : null,
      instantSalePrice: attributes.instantSalePrice ? new (external_bn_js_default())((attributes.instantSalePrice || 0) * LAMPORTS_PER_TOKEN) : null,
      name: null
    };
    const isOpenEdition = attributes.category === AuctionCategory.Open || attributes.instantSaleType === InstantSaleType.Open;
    const safetyDepositDrafts = isOpenEdition ? [] : attributes.category !== AuctionCategory.Tiered ? attributes.items : tieredAttributes.items;
    const participationSafetyDepositDraft = isOpenEdition ? attributes.items[0] : attributes.participationNFT;

    const _auctionObj = await createAuctionManager(connection, wallet, whitelistedCreatorsByCreator, auctionSettings, safetyDepositDrafts, participationSafetyDepositDraft, attributes.quoteMintAddress, storeIndexer);

    setAuctionObj(_auctionObj);
  };

  const categoryStep = /*#__PURE__*/jsx_runtime_.jsx(auctionCreate_CategoryStep, {
    confirm: category => {
      setAttributes(auctionCreate_objectSpread(auctionCreate_objectSpread({}, attributes), {}, {
        category
      }));
      gotoNextStep();
    }
  });

  const instantSaleStep = /*#__PURE__*/jsx_runtime_.jsx(InstantSaleStep, {
    attributes: attributes,
    setAttributes: setAttributes,
    confirm: () => gotoNextStep()
  });

  const copiesStep = /*#__PURE__*/jsx_runtime_.jsx(CopiesStep, {
    attributes: attributes,
    setAttributes: setAttributes,
    confirm: () => gotoNextStep()
  });

  const winnersStep = /*#__PURE__*/jsx_runtime_.jsx(NumberOfWinnersStep, {
    attributes: attributes,
    setAttributes: setAttributes,
    confirm: () => gotoNextStep()
  });

  const priceAuction = /*#__PURE__*/jsx_runtime_.jsx(PriceAuction, {
    attributes: attributes,
    setAttributes: setAttributes,
    confirm: () => gotoNextStep()
  });

  const initialStep = /*#__PURE__*/jsx_runtime_.jsx(InitialPhaseStep, {
    attributes: attributes,
    setAttributes: setAttributes,
    confirm: () => gotoNextStep()
  });

  const endingStep = /*#__PURE__*/jsx_runtime_.jsx(EndingPhaseAuction, {
    attributes: attributes,
    setAttributes: setAttributes,
    confirm: () => gotoNextStep()
  });

  const participationStep = /*#__PURE__*/jsx_runtime_.jsx(ParticipationStep, {
    attributes: attributes,
    setAttributes: setAttributes,
    confirm: () => gotoNextStep()
  });

  const tierTableStep = /*#__PURE__*/jsx_runtime_.jsx(TierTableStep, {
    attributes: tieredAttributes,
    setAttributes: setTieredAttributes,
    maxWinners: attributes.winnersCount,
    confirm: () => gotoNextStep()
  });

  const reviewStep = /*#__PURE__*/jsx_runtime_.jsx(ReviewStep, {
    attributes: attributes,
    setAttributes: setAttributes,
    confirm: () => {
      setStepsVisible(false);
      gotoNextStep();
    },
    connection: connection
  });

  const waitStep = /*#__PURE__*/jsx_runtime_.jsx(auctionCreate_WaitingStep, {
    createAuction: createAuction,
    confirm: () => gotoNextStep()
  });

  const congratsStep = /*#__PURE__*/jsx_runtime_.jsx(auctionCreate_Congrats, {
    auction: auctionObj
  });

  const stepsByCategory = {
    [AuctionCategory.InstantSale]: [['Category', categoryStep], ['Instant Sale', instantSaleStep], ['Review', reviewStep], ['Publish', waitStep], [undefined, congratsStep]],
    [AuctionCategory.Limited]: [['Category', categoryStep], ['Copies', copiesStep], ['Price', priceAuction], ['Initial Phase', initialStep], ['Ending Phase', endingStep], ['Participation NFT', participationStep], ['Review', reviewStep], ['Publish', waitStep], [undefined, congratsStep]],
    [AuctionCategory.Single]: [['Category', categoryStep], ['Copies', copiesStep], ['Price', priceAuction], ['Initial Phase', initialStep], ['Ending Phase', endingStep], ['Participation NFT', participationStep], ['Review', reviewStep], ['Publish', waitStep], [undefined, congratsStep]],
    [AuctionCategory.Open]: [['Category', categoryStep], ['Copies', copiesStep], ['Price', priceAuction], ['Initial Phase', initialStep], ['Ending Phase', endingStep], ['Review', reviewStep], ['Publish', waitStep], [undefined, congratsStep]],
    [AuctionCategory.Tiered]: [['Category', categoryStep], ['Winners', winnersStep], ['Tiers', tierTableStep], ['Price', priceAuction], ['Initial Phase', initialStep], ['Ending Phase', endingStep], ['Participation NFT', participationStep], ['Review', reviewStep], ['Publish', waitStep], [undefined, congratsStep]]
  };
  return /*#__PURE__*/jsx_runtime_.jsx(jsx_runtime_.Fragment, {
    children: /*#__PURE__*/(0,jsx_runtime_.jsxs)(external_antd_.Row, {
      className: "creator-base-page",
      style: {
        paddingTop: 50
      },
      children: [stepsVisible && /*#__PURE__*/jsx_runtime_.jsx(external_antd_.Col, {
        span: 24,
        md: 4,
        children: /*#__PURE__*/jsx_runtime_.jsx(external_antd_.Steps, {
          progressDot: true,
          direction: width < 768 ? 'horizontal' : 'vertical',
          current: step,
          style: {
            width: 'fit-content',
            margin: '0 auto 30px auto',
            overflowX: 'auto',
            maxWidth: '100%'
          },
          children: stepsByCategory[attributes.category].filter(_ => !!_[0]).map((step, idx) => /*#__PURE__*/jsx_runtime_.jsx(auctionCreate_Step, {
            title: step[0]
          }, idx))
        })
      }), /*#__PURE__*/(0,jsx_runtime_.jsxs)(external_antd_.Col, auctionCreate_objectSpread(auctionCreate_objectSpread({
        span: 24
      }, stepsVisible ? {
        md: 20
      } : {
        md: 24
      }), {}, {
        children: [stepsByCategory[attributes.category][step][1], 0 < step && stepsVisible && /*#__PURE__*/jsx_runtime_.jsx("div", {
          style: {
            margin: 'auto',
            width: 'fit-content'
          },
          children: /*#__PURE__*/jsx_runtime_.jsx(external_antd_.Button, {
            onClick: () => gotoNextStep(step - 1),
            children: "Back"
          })
        })]
      }))]
    })
  });
};

const auctionCreate_CategoryStep = props => {
  const {
    width
  } = useWindowDimensions();
  return /*#__PURE__*/(0,jsx_runtime_.jsxs)(jsx_runtime_.Fragment, {
    children: [/*#__PURE__*/(0,jsx_runtime_.jsxs)(external_antd_.Row, {
      className: "call-to-action",
      children: [/*#__PURE__*/jsx_runtime_.jsx("h2", {
        children: "List an item"
      }), /*#__PURE__*/(0,jsx_runtime_.jsxs)("p", {
        children: ["First time listing on Metaplex? ", /*#__PURE__*/jsx_runtime_.jsx("a", {
          children: "Read our sellers' guide."
        })]
      })]
    }), /*#__PURE__*/jsx_runtime_.jsx(external_antd_.Row, {
      justify: width < 768 ? 'center' : 'start',
      children: /*#__PURE__*/(0,jsx_runtime_.jsxs)(external_antd_.Col, {
        children: [/*#__PURE__*/jsx_runtime_.jsx(external_antd_.Row, {
          children: /*#__PURE__*/jsx_runtime_.jsx(external_antd_.Button, {
            className: "type-btn",
            size: "large",
            onClick: () => props.confirm(AuctionCategory.InstantSale),
            children: /*#__PURE__*/(0,jsx_runtime_.jsxs)("div", {
              children: [/*#__PURE__*/jsx_runtime_.jsx("div", {
                children: "Instant Sale"
              }), /*#__PURE__*/jsx_runtime_.jsx("div", {
                className: "type-btn-description",
                children: "At a fixed price, sell a single Master NFT or copies of it"
              })]
            })
          })
        }), /*#__PURE__*/jsx_runtime_.jsx(external_antd_.Row, {
          children: /*#__PURE__*/jsx_runtime_.jsx(external_antd_.Button, {
            className: "type-btn",
            size: "large",
            onClick: () => props.confirm(AuctionCategory.Limited),
            children: /*#__PURE__*/(0,jsx_runtime_.jsxs)("div", {
              children: [/*#__PURE__*/jsx_runtime_.jsx("div", {
                children: "Limited Edition"
              }), /*#__PURE__*/jsx_runtime_.jsx("div", {
                className: "type-btn-description",
                children: "Sell a limited copy or copies of a single Master NFT"
              })]
            })
          })
        }), /*#__PURE__*/jsx_runtime_.jsx(external_antd_.Row, {
          children: /*#__PURE__*/jsx_runtime_.jsx(external_antd_.Button, {
            className: "type-btn",
            size: "large",
            onClick: () => props.confirm(AuctionCategory.Open),
            children: /*#__PURE__*/(0,jsx_runtime_.jsxs)("div", {
              children: [/*#__PURE__*/jsx_runtime_.jsx("div", {
                children: "Open Edition"
              }), /*#__PURE__*/jsx_runtime_.jsx("div", {
                className: "type-btn-description",
                children: "Sell unlimited copies of a single Master NFT"
              })]
            })
          })
        }), /*#__PURE__*/jsx_runtime_.jsx(external_antd_.Row, {
          children: /*#__PURE__*/jsx_runtime_.jsx(external_antd_.Button, {
            className: "type-btn",
            size: "large",
            onClick: () => props.confirm(AuctionCategory.Tiered),
            children: /*#__PURE__*/(0,jsx_runtime_.jsxs)("div", {
              children: [/*#__PURE__*/jsx_runtime_.jsx("div", {
                children: "Tiered Auction"
              }), /*#__PURE__*/jsx_runtime_.jsx("div", {
                className: "type-btn-description",
                children: "Participants get unique rewards based on their leaderboard rank"
              })]
            })
          })
        }), /*#__PURE__*/jsx_runtime_.jsx(external_antd_.Row, {
          children: /*#__PURE__*/jsx_runtime_.jsx(external_antd_.Button, {
            className: "type-btn",
            size: "large",
            onClick: () => props.confirm(AuctionCategory.Single),
            children: /*#__PURE__*/(0,jsx_runtime_.jsxs)("div", {
              children: [/*#__PURE__*/jsx_runtime_.jsx("div", {
                children: "Sell an Existing Item"
              }), /*#__PURE__*/jsx_runtime_.jsx("div", {
                className: "type-btn-description",
                children: "Sell an existing item in your NFT collection, including Master NFTs"
              })]
            })
          })
        })]
      })
    })]
  });
};

const InstantSaleStep = ({
  attributes,
  setAttributes,
  confirm
}) => {
  var _attributes$items, _attributes$items$, _attributes$items3;

  const {
    0: showTokenDialog,
    1: setShowTokenDialog
  } = (0,external_react_.useState)(false);
  const {
    0: mint,
    1: setMint
  } = (0,external_react_.useState)(lib.WRAPPED_SOL_MINT); // give default value to mint

  const {
    hasOtherTokens,
    tokenMap
  } = useTokenList(); // give default value to mint

  const mintInfo = tokenMap.get(!mint ? QUOTE_MINT.toString() : mint.toString());
  attributes.quoteMintAddress = mint ? mint.toBase58() : QUOTE_MINT.toBase58();

  if (attributes.quoteMintAddress) {
    attributes.quoteMintInfo = (0,lib.useMint)(attributes.quoteMintAddress);
    attributes.quoteMintInfoExtended = useTokenList().tokenMap.get(attributes.quoteMintAddress);
  } //console.log("OBJ MINT", mint.toBase58())


  const isMasterEdition = !!(attributes !== null && attributes !== void 0 && (_attributes$items = attributes.items) !== null && _attributes$items !== void 0 && (_attributes$items$ = _attributes$items[0]) !== null && _attributes$items$ !== void 0 && _attributes$items$.masterEdition);
  const copiesEnabled = (0,external_react_.useMemo)(() => {
    var _attributes$items2, _attributes$items2$, _attributes$items2$$m, _attributes$items2$$m2;

    const maxSupply = attributes === null || attributes === void 0 ? void 0 : (_attributes$items2 = attributes.items) === null || _attributes$items2 === void 0 ? void 0 : (_attributes$items2$ = _attributes$items2[0]) === null || _attributes$items2$ === void 0 ? void 0 : (_attributes$items2$$m = _attributes$items2$.masterEdition) === null || _attributes$items2$$m === void 0 ? void 0 : (_attributes$items2$$m2 = _attributes$items2$$m.info) === null || _attributes$items2$$m2 === void 0 ? void 0 : _attributes$items2$$m2.maxSupply;
    return !!maxSupply && maxSupply.toNumber() > 0;
  }, [attributes === null || attributes === void 0 ? void 0 : (_attributes$items3 = attributes.items) === null || _attributes$items3 === void 0 ? void 0 : _attributes$items3[0]]);
  const artistFilter = (0,external_react_.useCallback)(i => !(i.metadata.info.data.creators || []).some(c => !c.verified), []);
  const isLimitedEdition = attributes.instantSaleType === InstantSaleType.Limited;
  const shouldRenderSelect = attributes.items.length > 0;
  return /*#__PURE__*/(0,jsx_runtime_.jsxs)(jsx_runtime_.Fragment, {
    children: [/*#__PURE__*/jsx_runtime_.jsx(external_antd_.Row, {
      className: "call-to-action",
      style: {
        marginBottom: 0
      },
      children: /*#__PURE__*/jsx_runtime_.jsx("h2", {
        children: "Select which item to sell:"
      })
    }), /*#__PURE__*/jsx_runtime_.jsx(external_antd_.Row, {
      className: "content-action",
      children: /*#__PURE__*/(0,jsx_runtime_.jsxs)(external_antd_.Col, {
        xl: 24,
        children: [/*#__PURE__*/jsx_runtime_.jsx(ArtSelector, {
          filter: artistFilter,
          selected: attributes.items,
          setSelected: items => {
            setAttributes(auctionCreate_objectSpread(auctionCreate_objectSpread({}, attributes), {}, {
              items
            }));
          },
          allowMultiple: false,
          children: "Select NFT"
        }), shouldRenderSelect && /*#__PURE__*/(0,jsx_runtime_.jsxs)("label", {
          className: "action-field",
          children: [/*#__PURE__*/(0,jsx_runtime_.jsxs)(external_antd_.Select, {
            defaultValue: attributes.instantSaleType || InstantSaleType.Single,
            onChange: value => setAttributes(auctionCreate_objectSpread(auctionCreate_objectSpread({}, attributes), {}, {
              instantSaleType: value
            })),
            children: [/*#__PURE__*/jsx_runtime_.jsx(Option, {
              value: InstantSaleType.Single,
              children: "Sell unique token"
            }), copiesEnabled && /*#__PURE__*/jsx_runtime_.jsx(Option, {
              value: InstantSaleType.Limited,
              children: "Sell limited number of copies"
            }), !copiesEnabled && isMasterEdition && /*#__PURE__*/jsx_runtime_.jsx(Option, {
              value: InstantSaleType.Open,
              children: "Sell unlimited number of copies"
            })]
          }), isLimitedEdition && /*#__PURE__*/(0,jsx_runtime_.jsxs)(jsx_runtime_.Fragment, {
            children: [/*#__PURE__*/jsx_runtime_.jsx("span", {
              className: "field-info",
              children: "Each copy will be given unique edition number e.g. 1 of 30"
            }), /*#__PURE__*/jsx_runtime_.jsx(external_antd_.Input, {
              autoFocus: true,
              className: "input",
              placeholder: "Enter number of copies sold",
              allowClear: true,
              onChange: info => setAttributes(auctionCreate_objectSpread(auctionCreate_objectSpread({}, attributes), {}, {
                editions: parseInt(info.target.value)
              }))
            })]
          })]
        }), hasOtherTokens && /*#__PURE__*/(0,jsx_runtime_.jsxs)("label", {
          className: "action-field",
          children: [/*#__PURE__*/jsx_runtime_.jsx("span", {
            className: "field-title",
            children: "Auction mint"
          }), /*#__PURE__*/jsx_runtime_.jsx(TokenButton, {
            mint: mint,
            onClick: () => setShowTokenDialog(true)
          }), /*#__PURE__*/jsx_runtime_.jsx(TokenDialog, {
            setMint: setMint,
            open: showTokenDialog,
            onClose: () => {
              setShowTokenDialog(false);
            }
          })]
        }), /*#__PURE__*/(0,jsx_runtime_.jsxs)("label", {
          className: "action-field",
          children: [/*#__PURE__*/jsx_runtime_.jsx("span", {
            className: "field-title",
            children: "Price"
          }), /*#__PURE__*/jsx_runtime_.jsx("span", {
            className: "field-info",
            children: "This is the instant sale price for your item."
          }), /*#__PURE__*/jsx_runtime_.jsx(external_antd_.Input, {
            type: "number",
            min: 0,
            autoFocus: true,
            className: "input",
            placeholder: "Price",
            prefix: "\u25CE",
            suffix: (mintInfo === null || mintInfo === void 0 ? void 0 : mintInfo.symbol) || 'CUSTOM',
            onChange: info => setAttributes(auctionCreate_objectSpread(auctionCreate_objectSpread({}, attributes), {}, {
              priceFloor: parseFloat(info.target.value),
              instantSalePrice: parseFloat(info.target.value)
            }))
          })]
        })]
      })
    }), /*#__PURE__*/jsx_runtime_.jsx(external_antd_.Row, {
      children: /*#__PURE__*/jsx_runtime_.jsx(external_antd_.Button, {
        type: "primary",
        size: "large",
        onClick: () => {
          confirm();
        },
        className: "action-btn",
        children: "Continue"
      })
    })]
  });
};

const CopiesStep = props => {
  const {
    0: showTokenDialog,
    1: setShowTokenDialog
  } = (0,external_react_.useState)(false);
  const {
    0: mint,
    1: setMint
  } = (0,external_react_.useState)(lib.WRAPPED_SOL_MINT);
  const {
    hasOtherTokens
  } = useTokenList();
  props.attributes.quoteMintAddress = mint ? mint.toBase58() : QUOTE_MINT.toBase58();

  if (props.attributes.quoteMintAddress) {
    props.attributes.quoteMintInfo = (0,lib.useMint)(props.attributes.quoteMintAddress);
    props.attributes.quoteMintInfoExtended = useTokenList().tokenMap.get(props.attributes.quoteMintAddress);
  }

  const artistFilter = i => !(i.metadata.info.data.creators || []).find(c => !c.verified);

  let filter = () => true;

  if (props.attributes.category === AuctionCategory.Limited) {
    filter = i => !!i.masterEdition && !!i.masterEdition.info.maxSupply;
  } else if (props.attributes.category === AuctionCategory.Open) {
    filter = i => !!(i.masterEdition && (i.masterEdition.info.maxSupply === undefined || i.masterEdition.info.maxSupply === null));
  }

  const overallFilter = i => filter(i) && artistFilter(i);

  return /*#__PURE__*/(0,jsx_runtime_.jsxs)(jsx_runtime_.Fragment, {
    children: [/*#__PURE__*/(0,jsx_runtime_.jsxs)(external_antd_.Row, {
      className: "call-to-action",
      style: {
        marginBottom: 0
      },
      children: [/*#__PURE__*/jsx_runtime_.jsx("h2", {
        children: "Select which item to sell"
      }), /*#__PURE__*/jsx_runtime_.jsx("p", {
        style: {
          fontSize: '1.2rem'
        },
        children: "Select the item(s) that you want to list."
      })]
    }), /*#__PURE__*/jsx_runtime_.jsx(external_antd_.Row, {
      className: "content-action",
      children: /*#__PURE__*/(0,jsx_runtime_.jsxs)(external_antd_.Col, {
        xl: 24,
        children: [/*#__PURE__*/jsx_runtime_.jsx(ArtSelector, {
          filter: overallFilter,
          selected: props.attributes.items,
          setSelected: items => {
            props.setAttributes(auctionCreate_objectSpread(auctionCreate_objectSpread({}, props.attributes), {}, {
              items
            }));
          },
          allowMultiple: false,
          children: "Select NFT"
        }), hasOtherTokens && /*#__PURE__*/(0,jsx_runtime_.jsxs)("label", {
          className: "action-field",
          children: [/*#__PURE__*/jsx_runtime_.jsx("span", {
            className: "field-title",
            children: "Auction mint"
          }), /*#__PURE__*/jsx_runtime_.jsx(TokenButton, {
            mint: mint,
            onClick: () => setShowTokenDialog(true)
          }), /*#__PURE__*/jsx_runtime_.jsx(TokenDialog, {
            setMint: setMint,
            open: showTokenDialog,
            onClose: () => {
              setShowTokenDialog(false);
            }
          })]
        }), props.attributes.category === AuctionCategory.Limited && /*#__PURE__*/(0,jsx_runtime_.jsxs)("label", {
          className: "action-field",
          children: [/*#__PURE__*/jsx_runtime_.jsx("span", {
            className: "field-title",
            children: "How many copies do you want to create?"
          }), /*#__PURE__*/jsx_runtime_.jsx("span", {
            className: "field-info",
            children: "Each copy will be given unique edition number e.g. 1 of 30"
          }), /*#__PURE__*/jsx_runtime_.jsx(external_antd_.Input, {
            autoFocus: true,
            className: "input",
            placeholder: "Enter number of copies sold",
            allowClear: true,
            onChange: info => props.setAttributes(auctionCreate_objectSpread(auctionCreate_objectSpread({}, props.attributes), {}, {
              editions: parseInt(info.target.value)
            }))
          })]
        })]
      })
    }), /*#__PURE__*/jsx_runtime_.jsx(external_antd_.Row, {
      children: /*#__PURE__*/jsx_runtime_.jsx(external_antd_.Button, {
        type: "primary",
        size: "large",
        onClick: () => {
          props.confirm();
        },
        className: "action-btn",
        children: "Continue to Terms"
      })
    })]
  });
};

const NumberOfWinnersStep = props => {
  const {
    0: showTokenDialog,
    1: setShowTokenDialog
  } = (0,external_react_.useState)(false);
  const {
    0: mint,
    1: setMint
  } = (0,external_react_.useState)(lib.WRAPPED_SOL_MINT);
  const {
    hasOtherTokens
  } = useTokenList();
  props.attributes.quoteMintAddress = mint ? mint.toBase58() : QUOTE_MINT.toBase58();

  if (props.attributes.quoteMintAddress) {
    props.attributes.quoteMintInfo = (0,lib.useMint)(props.attributes.quoteMintAddress);
    props.attributes.quoteMintInfoExtended = useTokenList().tokenMap.get(props.attributes.quoteMintAddress);
  }

  return /*#__PURE__*/(0,jsx_runtime_.jsxs)(jsx_runtime_.Fragment, {
    children: [/*#__PURE__*/(0,jsx_runtime_.jsxs)(external_antd_.Row, {
      className: "call-to-action",
      children: [/*#__PURE__*/jsx_runtime_.jsx("h2", {
        children: "Tiered Auction"
      }), /*#__PURE__*/jsx_runtime_.jsx("p", {
        children: "Create a Tiered Auction"
      })]
    }), /*#__PURE__*/jsx_runtime_.jsx(external_antd_.Row, {
      className: "content-action",
      children: /*#__PURE__*/(0,jsx_runtime_.jsxs)(external_antd_.Col, {
        className: "section",
        xl: 24,
        children: [/*#__PURE__*/(0,jsx_runtime_.jsxs)("label", {
          className: "action-field",
          children: [/*#__PURE__*/jsx_runtime_.jsx("span", {
            className: "field-title",
            children: "How many participants can win the auction?"
          }), /*#__PURE__*/jsx_runtime_.jsx("span", {
            className: "field-info",
            children: "This is the number of spots in the leaderboard."
          }), /*#__PURE__*/jsx_runtime_.jsx(external_antd_.Input, {
            type: "number",
            autoFocus: true,
            className: "input",
            placeholder: "Number of spots in the leaderboard",
            onChange: info => props.setAttributes(auctionCreate_objectSpread(auctionCreate_objectSpread({}, props.attributes), {}, {
              winnersCount: parseInt(info.target.value)
            }))
          })]
        }), hasOtherTokens && /*#__PURE__*/(0,jsx_runtime_.jsxs)("label", {
          className: "action-field",
          children: [/*#__PURE__*/jsx_runtime_.jsx("span", {
            className: "field-title",
            children: "Auction mint"
          }), /*#__PURE__*/jsx_runtime_.jsx("span", {
            className: "field-info",
            children: "This will be the quote mint for your auction."
          }), /*#__PURE__*/jsx_runtime_.jsx(TokenButton, {
            mint: mint,
            onClick: () => setShowTokenDialog(true)
          }), /*#__PURE__*/jsx_runtime_.jsx(TokenDialog, {
            setMint: setMint,
            open: showTokenDialog,
            onClose: () => {
              setShowTokenDialog(false);
            }
          })]
        })]
      })
    }), /*#__PURE__*/jsx_runtime_.jsx(external_antd_.Row, {
      children: /*#__PURE__*/jsx_runtime_.jsx(external_antd_.Button, {
        type: "primary",
        size: "large",
        onClick: props.confirm,
        className: "action-btn",
        children: "Continue"
      })
    })]
  });
};

const PriceAuction = props => {
  var _props$attributes, _props$attributes$quo, _props$attributes2, _props$attributes2$qu, _props$attributes3, _props$attributes4;

  console.log(props.attributes);
  const quoteMintName = ((_props$attributes = props.attributes) === null || _props$attributes === void 0 ? void 0 : (_props$attributes$quo = _props$attributes.quoteMintInfoExtended) === null || _props$attributes$quo === void 0 ? void 0 : _props$attributes$quo.name) || 'Custom Token';
  const quoteMintExt = ((_props$attributes2 = props.attributes) === null || _props$attributes2 === void 0 ? void 0 : (_props$attributes2$qu = _props$attributes2.quoteMintInfoExtended) === null || _props$attributes2$qu === void 0 ? void 0 : _props$attributes2$qu.symbol) || (0,lib.shortenAddress)(props.attributes.quoteMintAddress);
  return /*#__PURE__*/(0,jsx_runtime_.jsxs)(jsx_runtime_.Fragment, {
    children: [/*#__PURE__*/(0,jsx_runtime_.jsxs)(external_antd_.Row, {
      className: "call-to-action",
      children: [/*#__PURE__*/jsx_runtime_.jsx("h2", {
        children: "Price"
      }), /*#__PURE__*/(0,jsx_runtime_.jsxs)("p", {
        children: ["Set the price for your auction.", props.attributes.quoteMintAddress != lib.WRAPPED_SOL_MINT.toBase58() && ` Warning! the auction quote mint is `, props.attributes.quoteMintAddress != lib.WRAPPED_SOL_MINT.toBase58() && /*#__PURE__*/(0,jsx_runtime_.jsxs)("a", {
          href: `https://explorer.solana.com/address/${(_props$attributes3 = props.attributes) === null || _props$attributes3 === void 0 ? void 0 : _props$attributes3.quoteMintAddress}`,
          target: "_blank",
          rel: "noreferrer",
          children: [' ', ((_props$attributes4 = props.attributes) === null || _props$attributes4 === void 0 ? void 0 : _props$attributes4.quoteMintAddress) != lib.WRAPPED_SOL_MINT.toBase58() && `${quoteMintName} (${quoteMintExt})`]
        })]
      })]
    }), /*#__PURE__*/jsx_runtime_.jsx(external_antd_.Row, {
      className: "content-action",
      children: /*#__PURE__*/(0,jsx_runtime_.jsxs)(external_antd_.Col, {
        className: "section",
        xl: 24,
        children: [props.attributes.category === AuctionCategory.Open && /*#__PURE__*/(0,jsx_runtime_.jsxs)("label", {
          className: "action-field",
          children: [/*#__PURE__*/jsx_runtime_.jsx("span", {
            className: "field-title",
            children: "Price"
          }), /*#__PURE__*/jsx_runtime_.jsx("span", {
            className: "field-info",
            children: "This is the fixed price that everybody will pay for your Participation NFT."
          }), /*#__PURE__*/jsx_runtime_.jsx(external_antd_.Input, {
            type: "number",
            min: 0,
            autoFocus: true,
            className: "input",
            placeholder: "Fixed Price",
            prefix: "\u25CE",
            suffix: props.attributes.quoteMintInfoExtended ? props.attributes.quoteMintInfoExtended.symbol : props.attributes.quoteMintAddress == lib.WRAPPED_SOL_MINT.toBase58() ? 'SOL' : 'CUSTOM',
            onChange: info => props.setAttributes(auctionCreate_objectSpread(auctionCreate_objectSpread({}, props.attributes), {}, {
              // Do both, since we know this is the only item being sold.
              participationFixedPrice: parseFloat(info.target.value),
              priceFloor: parseFloat(info.target.value)
            }))
          })]
        }), props.attributes.category !== AuctionCategory.Open && /*#__PURE__*/(0,jsx_runtime_.jsxs)("label", {
          className: "action-field",
          children: [/*#__PURE__*/jsx_runtime_.jsx("span", {
            className: "field-title",
            children: "Price Floor"
          }), /*#__PURE__*/jsx_runtime_.jsx("span", {
            className: "field-info",
            children: "This is the starting bid price for your auction."
          }), /*#__PURE__*/jsx_runtime_.jsx(external_antd_.Input, {
            type: "number",
            min: 0,
            autoFocus: true,
            className: "input",
            placeholder: "Price",
            prefix: "\u25CE",
            suffix: props.attributes.quoteMintInfoExtended ? props.attributes.quoteMintInfoExtended.symbol : props.attributes.quoteMintAddress == lib.WRAPPED_SOL_MINT.toBase58() ? 'SOL' : 'CUSTOM',
            onChange: info => props.setAttributes(auctionCreate_objectSpread(auctionCreate_objectSpread({}, props.attributes), {}, {
              priceFloor: parseFloat(info.target.value)
            }))
          })]
        }), /*#__PURE__*/(0,jsx_runtime_.jsxs)("label", {
          className: "action-field",
          children: [/*#__PURE__*/jsx_runtime_.jsx("span", {
            className: "field-title",
            children: "Tick Size"
          }), /*#__PURE__*/jsx_runtime_.jsx("span", {
            className: "field-info",
            children: "All bids must fall within this price increment."
          }), /*#__PURE__*/jsx_runtime_.jsx(external_antd_.Input, {
            type: "number",
            min: 0,
            className: "input",
            placeholder: `Tick size in ${props.attributes.quoteMintInfoExtended ? props.attributes.quoteMintInfoExtended.symbol : props.attributes.quoteMintAddress == lib.WRAPPED_SOL_MINT.toBase58() ? 'SOL' : 'your custom currency'}`,
            prefix: "\u25CE",
            suffix: props.attributes.quoteMintInfoExtended ? props.attributes.quoteMintInfoExtended.symbol : props.attributes.quoteMintAddress == lib.WRAPPED_SOL_MINT.toBase58() ? 'SOL' : 'CUSTOM',
            onChange: info => props.setAttributes(auctionCreate_objectSpread(auctionCreate_objectSpread({}, props.attributes), {}, {
              priceTick: parseFloat(info.target.value)
            }))
          })]
        })]
      })
    }), /*#__PURE__*/jsx_runtime_.jsx(external_antd_.Row, {
      children: /*#__PURE__*/jsx_runtime_.jsx(external_antd_.Button, {
        type: "primary",
        size: "large",
        onClick: props.confirm,
        className: "action-btn",
        children: "Continue"
      })
    })]
  });
};

const InitialPhaseStep = props => {
  const {
    0: startNow,
    1: setStartNow
  } = (0,external_react_.useState)(true);
  const {
    0: listNow,
    1: setListNow
  } = (0,external_react_.useState)(true);
  const {
    0: saleMoment,
    1: setSaleMoment
  } = (0,external_react_.useState)(props.attributes.startSaleTS ? external_moment_default().unix(props.attributes.startSaleTS) : undefined);
  const {
    0: listMoment,
    1: setListMoment
  } = (0,external_react_.useState)(props.attributes.startListTS ? external_moment_default().unix(props.attributes.startListTS) : undefined);
  (0,external_react_.useEffect)(() => {
    props.setAttributes(auctionCreate_objectSpread(auctionCreate_objectSpread({}, props.attributes), {}, {
      startSaleTS: saleMoment && saleMoment.unix()
    }));
  }, [saleMoment]);
  (0,external_react_.useEffect)(() => {
    props.setAttributes(auctionCreate_objectSpread(auctionCreate_objectSpread({}, props.attributes), {}, {
      startListTS: listMoment && listMoment.unix()
    }));
  }, [listMoment]);
  (0,external_react_.useEffect)(() => {
    if (startNow) {
      setSaleMoment(undefined);
      setListNow(true);
    } else {
      setSaleMoment(external_moment_default()());
    }
  }, [startNow]);
  (0,external_react_.useEffect)(() => {
    if (listNow) setListMoment(undefined);else setListMoment(external_moment_default()());
  }, [listNow]);
  return /*#__PURE__*/(0,jsx_runtime_.jsxs)(jsx_runtime_.Fragment, {
    children: [/*#__PURE__*/(0,jsx_runtime_.jsxs)(external_antd_.Row, {
      className: "call-to-action",
      children: [/*#__PURE__*/jsx_runtime_.jsx("h2", {
        children: "Initial Phase"
      }), /*#__PURE__*/jsx_runtime_.jsx("p", {
        children: "Set the terms for your auction."
      })]
    }), /*#__PURE__*/jsx_runtime_.jsx(external_antd_.Row, {
      className: "content-action",
      children: /*#__PURE__*/(0,jsx_runtime_.jsxs)(external_antd_.Col, {
        className: "section",
        xl: 24,
        children: [/*#__PURE__*/(0,jsx_runtime_.jsxs)("label", {
          className: "action-field",
          children: [/*#__PURE__*/jsx_runtime_.jsx("span", {
            className: "field-title",
            children: "When do you want the auction to begin?"
          }), /*#__PURE__*/(0,jsx_runtime_.jsxs)(external_antd_.Radio.Group, {
            defaultValue: "now",
            onChange: info => setStartNow(info.target.value === 'now'),
            children: [/*#__PURE__*/jsx_runtime_.jsx(external_antd_.Radio, {
              className: "radio-field",
              value: "now",
              children: "Immediately"
            }), /*#__PURE__*/jsx_runtime_.jsx("div", {
              className: "radio-subtitle",
              children: "Participants can buy the NFT as soon as you finish setting up the auction."
            }), /*#__PURE__*/jsx_runtime_.jsx(external_antd_.Radio, {
              className: "radio-field",
              value: "later",
              children: "At a specified date"
            }), /*#__PURE__*/jsx_runtime_.jsx("div", {
              className: "radio-subtitle",
              children: "Participants can start buying the NFT at a specified date."
            })]
          })]
        }), !startNow && /*#__PURE__*/(0,jsx_runtime_.jsxs)(jsx_runtime_.Fragment, {
          children: [/*#__PURE__*/(0,jsx_runtime_.jsxs)("label", {
            className: "action-field",
            children: [/*#__PURE__*/jsx_runtime_.jsx("span", {
              className: "field-title",
              children: "Auction Start Date"
            }), saleMoment && /*#__PURE__*/jsx_runtime_.jsx(DateTimePicker, {
              momentObj: saleMoment,
              setMomentObj: setSaleMoment,
              datePickerProps: {
                disabledDate: current => current && current < external_moment_default()().endOf('day')
              }
            })]
          }), /*#__PURE__*/(0,jsx_runtime_.jsxs)("label", {
            className: "action-field",
            children: [/*#__PURE__*/jsx_runtime_.jsx("span", {
              className: "field-title",
              children: "When do you want the listing to go live?"
            }), /*#__PURE__*/(0,jsx_runtime_.jsxs)(external_antd_.Radio.Group, {
              defaultValue: "now",
              onChange: info => setListNow(info.target.value === 'now'),
              children: [/*#__PURE__*/jsx_runtime_.jsx(external_antd_.Radio, {
                className: "radio-field",
                value: "now",
                defaultChecked: true,
                children: "Immediately"
              }), /*#__PURE__*/jsx_runtime_.jsx("div", {
                className: "radio-subtitle",
                children: "Participants will be able to view the listing with a countdown to the start date as soon as you finish setting up the sale."
              }), /*#__PURE__*/jsx_runtime_.jsx(external_antd_.Radio, {
                className: "radio-field",
                value: "later",
                children: "At a specified date"
              }), /*#__PURE__*/jsx_runtime_.jsx("div", {
                className: "radio-subtitle",
                children: "Participants will be able to view the listing with a countdown to the start date at the specified date."
              })]
            })]
          }), !listNow && /*#__PURE__*/(0,jsx_runtime_.jsxs)("label", {
            className: "action-field",
            children: [/*#__PURE__*/jsx_runtime_.jsx("span", {
              className: "field-title",
              children: "Preview Start Date"
            }), listMoment && /*#__PURE__*/jsx_runtime_.jsx(DateTimePicker, {
              momentObj: listMoment,
              setMomentObj: setListMoment,
              datePickerProps: {
                disabledDate: current => current && saleMoment && (current < external_moment_default()().endOf('day') || current > saleMoment)
              }
            })]
          })]
        })]
      })
    }), /*#__PURE__*/jsx_runtime_.jsx(external_antd_.Row, {
      children: /*#__PURE__*/jsx_runtime_.jsx(external_antd_.Button, {
        type: "primary",
        size: "large",
        onClick: props.confirm,
        className: "action-btn",
        children: "Continue"
      })
    })]
  });
};

const EndingPhaseAuction = props => {
  return /*#__PURE__*/(0,jsx_runtime_.jsxs)(jsx_runtime_.Fragment, {
    children: [/*#__PURE__*/(0,jsx_runtime_.jsxs)(external_antd_.Row, {
      className: "call-to-action",
      children: [/*#__PURE__*/jsx_runtime_.jsx("h2", {
        children: "Ending Phase"
      }), /*#__PURE__*/jsx_runtime_.jsx("p", {
        children: "Set the terms for your auction."
      })]
    }), /*#__PURE__*/jsx_runtime_.jsx(external_antd_.Row, {
      className: "content-action",
      children: /*#__PURE__*/(0,jsx_runtime_.jsxs)(external_antd_.Col, {
        className: "section",
        xl: 24,
        children: [/*#__PURE__*/(0,jsx_runtime_.jsxs)("div", {
          className: "action-field",
          children: [/*#__PURE__*/jsx_runtime_.jsx("span", {
            className: "field-title",
            children: "Auction Duration"
          }), /*#__PURE__*/jsx_runtime_.jsx("span", {
            className: "field-info",
            children: "This is how long the auction will last for."
          }), /*#__PURE__*/jsx_runtime_.jsx(external_antd_.Input, {
            addonAfter: /*#__PURE__*/(0,jsx_runtime_.jsxs)(external_antd_.Select, {
              defaultValue: props.attributes.auctionDurationType,
              onChange: value => props.setAttributes(auctionCreate_objectSpread(auctionCreate_objectSpread({}, props.attributes), {}, {
                auctionDurationType: value
              })),
              children: [/*#__PURE__*/jsx_runtime_.jsx(Option, {
                value: "minutes",
                children: "Minutes"
              }), /*#__PURE__*/jsx_runtime_.jsx(Option, {
                value: "hours",
                children: "Hours"
              }), /*#__PURE__*/jsx_runtime_.jsx(Option, {
                value: "days",
                children: "Days"
              })]
            }),
            autoFocus: true,
            type: "number",
            className: "input",
            placeholder: "Set the auction duration",
            onChange: info => props.setAttributes(auctionCreate_objectSpread(auctionCreate_objectSpread({}, props.attributes), {}, {
              auctionDuration: parseInt(info.target.value)
            }))
          })]
        }), /*#__PURE__*/(0,jsx_runtime_.jsxs)("div", {
          className: "action-field",
          children: [/*#__PURE__*/jsx_runtime_.jsx("span", {
            className: "field-title",
            children: "Gap Time"
          }), /*#__PURE__*/jsx_runtime_.jsx("span", {
            className: "field-info",
            children: "The final phase of the auction will begin when there is this much time left on the countdown. Any bids placed during the final phase will extend the end time by this same duration."
          }), /*#__PURE__*/jsx_runtime_.jsx(external_antd_.Input, {
            addonAfter: /*#__PURE__*/(0,jsx_runtime_.jsxs)(external_antd_.Select, {
              defaultValue: props.attributes.gapTimeType,
              onChange: value => props.setAttributes(auctionCreate_objectSpread(auctionCreate_objectSpread({}, props.attributes), {}, {
                gapTimeType: value
              })),
              children: [/*#__PURE__*/jsx_runtime_.jsx(Option, {
                value: "minutes",
                children: "Minutes"
              }), /*#__PURE__*/jsx_runtime_.jsx(Option, {
                value: "hours",
                children: "Hours"
              }), /*#__PURE__*/jsx_runtime_.jsx(Option, {
                value: "days",
                children: "Days"
              })]
            }),
            type: "number",
            className: "input",
            placeholder: "Set the gap time",
            onChange: info => props.setAttributes(auctionCreate_objectSpread(auctionCreate_objectSpread({}, props.attributes), {}, {
              gapTime: parseInt(info.target.value)
            }))
          })]
        }), /*#__PURE__*/(0,jsx_runtime_.jsxs)("label", {
          className: "action-field",
          children: [/*#__PURE__*/jsx_runtime_.jsx("span", {
            className: "field-title",
            children: "Tick Size for Ending Phase"
          }), /*#__PURE__*/jsx_runtime_.jsx("span", {
            className: "field-info",
            children: "In order for winners to move up in the auction, they must place a bid that\u2019s at least this percentage higher than the next highest bid."
          }), /*#__PURE__*/jsx_runtime_.jsx(external_antd_.Input, {
            type: "number",
            className: "input",
            placeholder: "Percentage",
            suffix: "%",
            onChange: info => props.setAttributes(auctionCreate_objectSpread(auctionCreate_objectSpread({}, props.attributes), {}, {
              tickSizeEndingPhase: parseInt(info.target.value)
            }))
          })]
        })]
      })
    }), /*#__PURE__*/jsx_runtime_.jsx(external_antd_.Row, {
      children: /*#__PURE__*/jsx_runtime_.jsx(external_antd_.Button, {
        type: "primary",
        size: "large",
        onClick: props.confirm,
        className: "action-btn",
        children: "Continue"
      })
    })]
  });
};

const TierTableStep = props => {
  const newImmutableTiers = tiers => {
    return tiers.map(wc => ({
      items: [...wc.items.map(it => auctionCreate_objectSpread({}, it))],
      winningSpots: [...wc.winningSpots]
    }));
  };

  const artistFilter = i => !(i.metadata.info.data.creators || []).find(c => !c.verified);

  const options = [];

  for (let i = 0; i < props.maxWinners; i++) {
    options.push({
      label: `Winner ${i + 1}`,
      value: i
    });
  }

  return /*#__PURE__*/(0,jsx_runtime_.jsxs)(jsx_runtime_.Fragment, {
    children: [/*#__PURE__*/(0,jsx_runtime_.jsxs)(external_antd_.Row, {
      className: "call-to-action",
      children: [/*#__PURE__*/jsx_runtime_.jsx("h2", {
        children: "Add Winning Tiers and Their Prizes"
      }), /*#__PURE__*/jsx_runtime_.jsx("p", {
        children: "Each row represents a tier. You can choose which winning spots get which tiers."
      })]
    }), props.attributes.tiers.map((wcg, configIndex) => /*#__PURE__*/(0,jsx_runtime_.jsxs)(external_antd_.Row, {
      className: "content-action",
      children: [/*#__PURE__*/jsx_runtime_.jsx(external_antd_.Col, {
        xl: 24,
        children: /*#__PURE__*/(0,jsx_runtime_.jsxs)("h3", {
          children: ["Tier #", configIndex + 1, " Basket"]
        })
      }), /*#__PURE__*/jsx_runtime_.jsx(external_antd_.Checkbox.Group, {
        options: options,
        onChange: value => {
          const newTiers = newImmutableTiers(props.attributes.tiers);
          const myNewTier = newTiers[configIndex];
          myNewTier.winningSpots = value.map(i => i.valueOf());
          props.setAttributes(auctionCreate_objectSpread(auctionCreate_objectSpread({}, props.attributes), {}, {
            tiers: newTiers
          }));
        }
      }), wcg.items.map((i, itemIndex) => /*#__PURE__*/jsx_runtime_.jsx(external_antd_.Col, {
        className: "section",
        xl: 8,
        children: /*#__PURE__*/(0,jsx_runtime_.jsxs)(external_antd_.Card, {
          children: [/*#__PURE__*/jsx_runtime_.jsx(ArtSelector, {
            filter: artistFilter,
            selected: i.safetyDepositBoxIndex !== undefined ? [props.attributes.items[i.safetyDepositBoxIndex]] : [],
            setSelected: items => {
              const newItems = [...props.attributes.items.map(it => auctionCreate_objectSpread({}, it))];
              const newTiers = newImmutableTiers(props.attributes.tiers);

              if (items[0]) {
                const existing = props.attributes.items.find(it => it.metadata.pubkey === items[0].metadata.pubkey);
                if (!existing) newItems.push(items[0]);
                const index = newItems.findIndex(it => it.metadata.pubkey === items[0].metadata.pubkey);
                const myNewTier = newTiers[configIndex].items[itemIndex];
                myNewTier.safetyDepositBoxIndex = index;

                if (items[0].masterEdition && items[0].masterEdition.info.key == lib.MetadataKey.MasterEditionV1) {
                  myNewTier.winningConfigType = metaplex.WinningConfigType.PrintingV1;
                } else if (items[0].masterEdition && items[0].masterEdition.info.key == lib.MetadataKey.MasterEditionV2) {
                  myNewTier.winningConfigType = metaplex.WinningConfigType.PrintingV2;
                } else {
                  myNewTier.winningConfigType = metaplex.WinningConfigType.TokenOnlyTransfer;
                }

                myNewTier.amount = 1;
              } else if (i.safetyDepositBoxIndex !== undefined) {
                const myNewTier = newTiers[configIndex];
                myNewTier.items.splice(itemIndex, 1);
                if (myNewTier.items.length === 0) newTiers.splice(configIndex, 1);
                const othersWithSameItem = newTiers.find(c => c.items.find(it => it.safetyDepositBoxIndex === i.safetyDepositBoxIndex));

                if (!othersWithSameItem) {
                  for (let j = i.safetyDepositBoxIndex + 1; j < props.attributes.items.length; j++) {
                    newTiers.forEach(c => c.items.forEach(it => {
                      if (it.safetyDepositBoxIndex === j) it.safetyDepositBoxIndex--;
                    }));
                  }

                  newItems.splice(i.safetyDepositBoxIndex, 1);
                }
              }

              props.setAttributes(auctionCreate_objectSpread(auctionCreate_objectSpread({}, props.attributes), {}, {
                items: newItems,
                tiers: newTiers
              }));
            },
            allowMultiple: false,
            children: "Select item"
          }), i.winningConfigType !== undefined && /*#__PURE__*/(0,jsx_runtime_.jsxs)(jsx_runtime_.Fragment, {
            children: [/*#__PURE__*/(0,jsx_runtime_.jsxs)(external_antd_.Select, {
              defaultValue: i.winningConfigType,
              style: {
                width: 120
              },
              onChange: value => {
                var _props$attributes$ite;

                const newTiers = newImmutableTiers(props.attributes.tiers);
                const myNewTier = newTiers[configIndex].items[itemIndex]; // Legacy hack...

                if (value == metaplex.WinningConfigType.PrintingV2 && myNewTier.safetyDepositBoxIndex && ((_props$attributes$ite = props.attributes.items[myNewTier.safetyDepositBoxIndex].masterEdition) === null || _props$attributes$ite === void 0 ? void 0 : _props$attributes$ite.info.key) == lib.MetadataKey.MasterEditionV1) {
                  value = metaplex.WinningConfigType.PrintingV1;
                }

                myNewTier.winningConfigType = value;
                props.setAttributes(auctionCreate_objectSpread(auctionCreate_objectSpread({}, props.attributes), {}, {
                  tiers: newTiers
                }));
              },
              children: [/*#__PURE__*/jsx_runtime_.jsx(Option, {
                value: metaplex.WinningConfigType.FullRightsTransfer,
                children: "Full Rights Transfer"
              }), /*#__PURE__*/jsx_runtime_.jsx(Option, {
                value: metaplex.WinningConfigType.TokenOnlyTransfer,
                children: "Token Only Transfer"
              }), /*#__PURE__*/jsx_runtime_.jsx(Option, {
                value: metaplex.WinningConfigType.PrintingV2,
                children: "Printing V2"
              }), /*#__PURE__*/jsx_runtime_.jsx(Option, {
                value: metaplex.WinningConfigType.PrintingV1,
                children: "Printing V1"
              })]
            }), (i.winningConfigType === metaplex.WinningConfigType.PrintingV1 || i.winningConfigType === metaplex.WinningConfigType.PrintingV2) && /*#__PURE__*/(0,jsx_runtime_.jsxs)("label", {
              className: "action-field",
              children: [/*#__PURE__*/jsx_runtime_.jsx("span", {
                className: "field-title",
                children: "How many copies do you want to create for each winner? If you put 2, then each winner will get 2 copies."
              }), /*#__PURE__*/jsx_runtime_.jsx("span", {
                className: "field-info",
                children: "Each copy will be given unique edition number e.g. 1 of 30"
              }), /*#__PURE__*/jsx_runtime_.jsx(external_antd_.Input, {
                autoFocus: true,
                className: "input",
                placeholder: "Enter number of copies sold",
                allowClear: true,
                onChange: info => {
                  const newTiers = newImmutableTiers(props.attributes.tiers);
                  const myNewTier = newTiers[configIndex].items[itemIndex];
                  myNewTier.amount = parseInt(info.target.value);
                  props.setAttributes(auctionCreate_objectSpread(auctionCreate_objectSpread({}, props.attributes), {}, {
                    tiers: newTiers
                  }));
                }
              })]
            })]
          })]
        })
      }, itemIndex)), /*#__PURE__*/jsx_runtime_.jsx(external_antd_.Col, {
        xl: 4,
        children: /*#__PURE__*/jsx_runtime_.jsx(external_antd_.Button, {
          type: "primary",
          size: "large",
          onClick: () => {
            const newTiers = newImmutableTiers(props.attributes.tiers);
            const myNewTier = newTiers[configIndex];
            myNewTier.items.push({});
            props.setAttributes(auctionCreate_objectSpread(auctionCreate_objectSpread({}, props.attributes), {}, {
              tiers: newTiers
            }));
          },
          className: "action-btn",
          children: /*#__PURE__*/jsx_runtime_.jsx(icons_.PlusCircleOutlined, {})
        })
      })]
    }, configIndex)), /*#__PURE__*/jsx_runtime_.jsx(external_antd_.Row, {
      children: /*#__PURE__*/jsx_runtime_.jsx(external_antd_.Col, {
        xl: 24,
        children: /*#__PURE__*/jsx_runtime_.jsx(external_antd_.Button, {
          type: "primary",
          size: "large",
          onClick: () => {
            const newTiers = newImmutableTiers(props.attributes.tiers);
            newTiers.push({
              items: [],
              winningSpots: []
            });
            props.setAttributes(auctionCreate_objectSpread(auctionCreate_objectSpread({}, props.attributes), {}, {
              tiers: newTiers
            }));
          },
          className: "action-btn",
          children: /*#__PURE__*/jsx_runtime_.jsx(icons_.PlusCircleOutlined, {})
        })
      })
    }), /*#__PURE__*/jsx_runtime_.jsx(external_antd_.Row, {
      children: /*#__PURE__*/jsx_runtime_.jsx(external_antd_.Button, {
        type: "primary",
        size: "large",
        onClick: props.confirm,
        className: "action-btn",
        children: "Continue to Review"
      })
    })]
  });
};

const ParticipationStep = props => {
  return /*#__PURE__*/(0,jsx_runtime_.jsxs)(jsx_runtime_.Fragment, {
    children: [/*#__PURE__*/(0,jsx_runtime_.jsxs)(external_antd_.Row, {
      className: "call-to-action",
      children: [/*#__PURE__*/jsx_runtime_.jsx("h2", {
        children: "Participation NFT"
      }), /*#__PURE__*/jsx_runtime_.jsx("p", {
        children: "Provide NFT that will be awarded as an Open Edition NFT for auction participation."
      })]
    }), /*#__PURE__*/jsx_runtime_.jsx(external_antd_.Row, {
      className: "content-action",
      children: /*#__PURE__*/(0,jsx_runtime_.jsxs)(external_antd_.Col, {
        className: "section",
        xl: 24,
        children: [/*#__PURE__*/jsx_runtime_.jsx(ArtSelector, {
          filter: i => !!i.masterEdition && i.masterEdition.info.maxSupply === undefined,
          selected: props.attributes.participationNFT ? [props.attributes.participationNFT] : [],
          setSelected: items => {
            props.setAttributes(auctionCreate_objectSpread(auctionCreate_objectSpread({}, props.attributes), {}, {
              participationNFT: items[0]
            }));
          },
          allowMultiple: false,
          children: "Select Participation NFT"
        }), /*#__PURE__*/(0,jsx_runtime_.jsxs)("label", {
          className: "action-field",
          children: [/*#__PURE__*/jsx_runtime_.jsx("span", {
            className: "field-title",
            children: "Price"
          }), /*#__PURE__*/jsx_runtime_.jsx("span", {
            className: "field-info",
            children: "This is an optional fixed price that non-winners will pay for your Participation NFT."
          }), /*#__PURE__*/jsx_runtime_.jsx(external_antd_.Input, {
            type: "number",
            min: 0,
            autoFocus: true,
            className: "input",
            placeholder: "Fixed Price",
            prefix: "\u25CE",
            suffix: props.attributes.quoteMintInfoExtended ? props.attributes.quoteMintInfoExtended.symbol : props.attributes.quoteMintAddress == lib.WRAPPED_SOL_MINT.toBase58() ? 'SOL' : 'CUSTOM',
            onChange: info => props.setAttributes(auctionCreate_objectSpread(auctionCreate_objectSpread({}, props.attributes), {}, {
              participationFixedPrice: parseFloat(info.target.value)
            }))
          })]
        })]
      })
    }), /*#__PURE__*/jsx_runtime_.jsx(external_antd_.Row, {
      children: /*#__PURE__*/jsx_runtime_.jsx(external_antd_.Button, {
        type: "primary",
        size: "large",
        onClick: props.confirm,
        className: "action-btn",
        children: "Continue to Review"
      })
    })]
  });
};

const ReviewStep = props => {
  var _props$attributes$ite2;

  const {
    0: showFundsIssueModal,
    1: setShowFundsIssueModal
  } = (0,external_react_.useState)(false);
  const {
    0: cost,
    1: setCost
  } = (0,external_react_.useState)(0);
  const {
    account
  } = (0,lib.useNativeAccount)();
  (0,external_react_.useEffect)(() => {
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    const rentCall = Promise.all([props.connection.getMinimumBalanceForRentExemption(spl_token_.MintLayout.span), props.connection.getMinimumBalanceForRentExemption(lib.MAX_METADATA_LEN)]); // TODO: add
  }, [setCost]);
  const balance = ((account === null || account === void 0 ? void 0 : account.lamports) || 0) / web3_js_.LAMPORTS_PER_SOL;
  const item = (_props$attributes$ite2 = props.attributes.items) === null || _props$attributes$ite2 === void 0 ? void 0 : _props$attributes$ite2[0];

  const handleConfirm = () => {
    props.setAttributes(auctionCreate_objectSpread(auctionCreate_objectSpread({}, props.attributes), {}, {
      startListTS: props.attributes.startListTS || external_moment_default()().unix(),
      startSaleTS: props.attributes.startSaleTS || external_moment_default()().unix()
    }));
    props.confirm();
  };

  return /*#__PURE__*/(0,jsx_runtime_.jsxs)(jsx_runtime_.Fragment, {
    children: [/*#__PURE__*/(0,jsx_runtime_.jsxs)(external_antd_.Row, {
      className: "call-to-action",
      children: [/*#__PURE__*/jsx_runtime_.jsx("h2", {
        children: "Review and list"
      }), /*#__PURE__*/jsx_runtime_.jsx("p", {
        children: "Review your listing before publishing."
      })]
    }), /*#__PURE__*/(0,jsx_runtime_.jsxs)(external_antd_.Row, {
      className: "content-action",
      children: [/*#__PURE__*/jsx_runtime_.jsx(external_antd_.Col, {
        xl: 12,
        children: (item === null || item === void 0 ? void 0 : item.metadata.info) && /*#__PURE__*/jsx_runtime_.jsx(ArtCard, {
          pubkey: item.metadata.pubkey,
          small: true
        })
      }), /*#__PURE__*/(0,jsx_runtime_.jsxs)(external_antd_.Col, {
        className: "section",
        xl: 12,
        children: [/*#__PURE__*/jsx_runtime_.jsx(external_antd_.Statistic, {
          className: "create-statistic",
          title: "Copies",
          value: props.attributes.editions === undefined ? 'Unique' : props.attributes.editions
        }), cost ? /*#__PURE__*/jsx_runtime_.jsx(AmountLabel, {
          title: "Cost to Create",
          amount: cost,
          tokenInfo: useTokenList().tokenMap.get(lib.WRAPPED_SOL_MINT.toString())
        }) : /*#__PURE__*/jsx_runtime_.jsx(external_antd_.Spin, {})]
      })]
    }), /*#__PURE__*/(0,jsx_runtime_.jsxs)(external_antd_.Row, {
      style: {
        display: 'block'
      },
      children: [/*#__PURE__*/jsx_runtime_.jsx(external_antd_.Divider, {}), /*#__PURE__*/jsx_runtime_.jsx(external_antd_.Statistic, {
        className: "create-statistic",
        title: "Start date",
        value: props.attributes.startSaleTS ? external_moment_default().unix(props.attributes.startSaleTS).format('dddd, MMMM Do YYYY, h:mm a') : 'Right after successfully published'
      }), /*#__PURE__*/jsx_runtime_.jsx("br", {}), props.attributes.startListTS && /*#__PURE__*/jsx_runtime_.jsx(external_antd_.Statistic, {
        className: "create-statistic",
        title: "Listing go live date",
        value: external_moment_default().unix(props.attributes.startListTS).format('dddd, MMMM Do YYYY, h:mm a')
      }), /*#__PURE__*/jsx_runtime_.jsx(external_antd_.Divider, {}), /*#__PURE__*/jsx_runtime_.jsx(external_antd_.Statistic, {
        className: "create-statistic",
        title: "Sale ends",
        value: props.attributes.endTS ? external_moment_default().unix(props.attributes.endTS).format('dddd, MMMM Do YYYY, h:mm a') : 'Until sold'
      })]
    }), /*#__PURE__*/(0,jsx_runtime_.jsxs)(external_antd_.Row, {
      children: [/*#__PURE__*/jsx_runtime_.jsx(external_antd_.Button, {
        type: "primary",
        size: "large",
        onClick: () => {
          if (balance < MINIMUM_SAFE_FEE_AUCTION_CREATION) {
            setShowFundsIssueModal(true);
          } else {
            handleConfirm();
          }
        },
        className: "action-btn",
        children: props.attributes.category === AuctionCategory.InstantSale ? 'List for Sale' : 'Publish Auction'
      }), /*#__PURE__*/jsx_runtime_.jsx(FundsIssueModal, {
        message: 'Estimated Minimum Fee',
        minimumFunds: MINIMUM_SAFE_FEE_AUCTION_CREATION,
        currentFunds: balance,
        isModalVisible: showFundsIssueModal,
        onClose: () => setShowFundsIssueModal(false)
      })]
    })]
  });
};

const auctionCreate_WaitingStep = props => {
  const {
    0: progress,
    1: setProgress
  } = (0,external_react_.useState)(0);
  (0,external_react_.useEffect)(() => {
    const func = async () => {
      const inte = setInterval(() => setProgress(prog => Math.min(prog + 1, 99)), 600);
      await props.createAuction();
      clearInterval(inte);
      props.confirm();
    };

    func();
  }, []);
  return /*#__PURE__*/(0,jsx_runtime_.jsxs)("div", {
    style: {
      marginTop: 70,
      display: 'flex',
      flexDirection: 'column',
      alignItems: 'center'
    },
    children: [/*#__PURE__*/jsx_runtime_.jsx(external_antd_.Progress, {
      type: "circle",
      percent: progress
    }), /*#__PURE__*/jsx_runtime_.jsx("div", {
      className: "waiting-title",
      children: "Your creation is being listed with Metaplex..."
    }), /*#__PURE__*/jsx_runtime_.jsx("div", {
      className: "waiting-subtitle",
      children: "This can take up to 30 seconds."
    })]
  });
};

const auctionCreate_Congrats = props => {
  const history = (0,external_react_router_dom_.useHistory)();

  const newTweetURL = () => {
    var _props$auction;

    const params = {
      text: "I've created a new NFT auction on Metaplex, check it out!",
      url: `${window.location.origin}/#/auction/${(_props$auction = props.auction) === null || _props$auction === void 0 ? void 0 : _props$auction.auction.toString()}`,
      hashtags: 'NFT,Crypto,Metaplex',
      // via: "Metaplex",
      related: 'Metaplex,Solana'
    };
    const queryParams = new URLSearchParams(params).toString();
    return `https://twitter.com/intent/tweet?${queryParams}`;
  };

  return /*#__PURE__*/(0,jsx_runtime_.jsxs)(jsx_runtime_.Fragment, {
    children: [/*#__PURE__*/(0,jsx_runtime_.jsxs)("div", {
      style: {
        marginTop: 70,
        display: 'flex',
        flexDirection: 'column',
        alignItems: 'center'
      },
      children: [/*#__PURE__*/jsx_runtime_.jsx("div", {
        className: "waiting-title",
        children: "Congratulations! Your auction is now live."
      }), /*#__PURE__*/(0,jsx_runtime_.jsxs)("div", {
        className: "congrats-button-container",
        children: [/*#__PURE__*/(0,jsx_runtime_.jsxs)(external_antd_.Button, {
          className: "metaplex-button",
          onClick: () => window.open(newTweetURL(), '_blank'),
          children: [/*#__PURE__*/jsx_runtime_.jsx("span", {
            children: "Share it on Twitter"
          }), /*#__PURE__*/jsx_runtime_.jsx("span", {
            children: ">"
          })]
        }), /*#__PURE__*/(0,jsx_runtime_.jsxs)(external_antd_.Button, {
          className: "metaplex-button",
          onClick: () => {
            history.push(`/`);
            history.go(0);
          },
          children: [/*#__PURE__*/jsx_runtime_.jsx("span", {
            children: "See it in your auctions"
          }), /*#__PURE__*/jsx_runtime_.jsx("span", {
            children: ">"
          })]
        })]
      })]
    }), /*#__PURE__*/jsx_runtime_.jsx(Confetti, {})]
  });
};
;// CONCATENATED MODULE: ./src/views/artworks/types.ts
let ArtworkViewState;

(function (ArtworkViewState) {
  ArtworkViewState["Metaplex"] = "0";
  ArtworkViewState["Owned"] = "1";
  ArtworkViewState["Created"] = "2";
})(ArtworkViewState || (ArtworkViewState = {}));
;// CONCATENATED MODULE: ./src/views/artworks/hooks/useUserMetadataWithPacks.ts
function useUserMetadataWithPacks_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

function useUserMetadataWithPacks_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { useUserMetadataWithPacks_ownKeys(Object(source), true).forEach(function (key) { useUserMetadataWithPacks_defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { useUserMetadataWithPacks_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function useUserMetadataWithPacks_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }



// This hook joins user metadata with packs in the same view
// If there is a pack that can be assigned to a metadata edition
// Then a pack entity will be returned
// SafetyDeposit otherwise
const useUserMetadataWithPacks = () => {
  const {
    vouchers,
    packs,
    provingProcesses
  } = (0,lib.useMeta)();
  const ownedMetadata = useUserArts();
  const shouldEnableNftPacks = process.env.NEXT_ENABLE_NFT_PACKS === 'true';

  if (!shouldEnableNftPacks) {
    return ownedMetadata;
  }

  return getMetadataWithPacks({
    ownedMetadata,
    vouchers,
    packs,
    provingProcesses
  });
};

const getMetadataWithPacks = ({
  ownedMetadata,
  vouchers,
  packs,
  provingProcesses
}) => // Go through owned metadata
// If it's an edition, check if this edition can be used as a voucher to open a pack
// Return ExtendedPack entity if so
ownedMetadata.reduce((acc, metadata) => {
  var _metadata$edition;

  if (!metadata.edition) {
    return [...acc, metadata];
  }

  const masterEdition = (_metadata$edition = metadata.edition) === null || _metadata$edition === void 0 ? void 0 : _metadata$edition.info.parent;
  const voucher = Object.values(vouchers).find(({
    info
  }) => info.master === masterEdition);

  if (!voucher) {
    return [...acc, metadata];
  }

  const doesHaveProvingProcess = Object.values(provingProcesses).find(({
    info
  }) => info.voucherMint === metadata.metadata.info.mint);

  if (doesHaveProvingProcess) {
    return acc;
  }

  return [...acc, useUserMetadataWithPacks_objectSpread(useUserMetadataWithPacks_objectSpread({}, packs[voucher.info.packSet]), {}, {
    voucher: voucher.pubkey,
    voucherMetadataKey: metadata.metadata.pubkey,
    mint: metadata.metadata.info.mint
  })];
}, []);
;// CONCATENATED MODULE: ./src/views/artworks/hooks/usePacksBasedOnProvingProcesses.ts
function usePacksBasedOnProvingProcesses_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

function usePacksBasedOnProvingProcesses_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { usePacksBasedOnProvingProcesses_ownKeys(Object(source), true).forEach(function (key) { usePacksBasedOnProvingProcesses_defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { usePacksBasedOnProvingProcesses_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function usePacksBasedOnProvingProcesses_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }


const usePacksBasedOnProvingProcesses = () => {
  const {
    provingProcesses,
    packs,
    vouchers
  } = (0,lib.useMeta)();
  const shouldEnableNftPacks = process.env.NEXT_ENABLE_NFT_PACKS === 'true';

  if (!shouldEnableNftPacks) {
    return [];
  }

  return getPacksBasedOnProvingProcesses({
    provingProcesses,
    packs,
    vouchers
  });
};

const getPacksBasedOnProvingProcesses = ({
  provingProcesses,
  vouchers,
  packs
}) => Object.values(provingProcesses).reduce((acc, process) => {
  const pack = packs[process.info.packSet];
  const voucher = Object.values(vouchers).find(({
    info
  }) => info.packSet === process.info.packSet);

  if (!voucher) {
    return acc;
  }

  return [...acc, usePacksBasedOnProvingProcesses_objectSpread(usePacksBasedOnProvingProcesses_objectSpread({}, pack), {}, {
    voucher: voucher.pubkey,
    voucherMetadataKey: voucher.info.metadata,
    cardsRedeemed: process.info.cardsRedeemed,
    provingProcessKey: process.pubkey
  })];
}, []);
;// CONCATENATED MODULE: ./src/views/artworks/hooks/useItems.ts






const useItems = ({
  activeKey
}) => {
  const {
    publicKey
  } = (0,wallet_adapter_react_.useWallet)();
  const {
    metadata
  } = (0,lib.useMeta)();
  const createdMetadata = useCreatorArts((publicKey === null || publicKey === void 0 ? void 0 : publicKey.toBase58()) || '');
  const userMetadataWithPacks = useUserMetadataWithPacks();
  const packsBasedOnProvingProcesses = usePacksBasedOnProvingProcesses();

  if (activeKey === ArtworkViewState.Owned) {
    return [...userMetadataWithPacks, ...packsBasedOnProvingProcesses];
  }

  if (activeKey === ArtworkViewState.Created) {
    return createdMetadata;
  }

  return metadata;
};
;// CONCATENATED MODULE: ./src/views/artworks/utils.ts
const isPack = item => (item === null || item === void 0 ? void 0 : item.info) && !!item.info.randomOracle;
const isMetadata = item => (item === null || item === void 0 ? void 0 : item.info) && !!item.info.data;
;// CONCATENATED MODULE: ./src/views/artworks/components/ItemCard/index.tsx






const ART_CARD_SIZE = 250;

const ItemCard = ({
  item
}) => {
  if (isPack(item)) {
    const {
      pubkey,
      cardsRedeemed,
      mint,
      info: {
        authority,
        allowedAmountToRedeem,
        uri
      },
      provingProcessKey,
      voucherMetadataKey
    } = item;
    const search = mint ? `voucherMint=${mint}` : `provingProcessKey=${provingProcessKey}`;
    return /*#__PURE__*/jsx_runtime_.jsx(external_react_router_dom_.Link, {
      to: `/pack/${pubkey}?${search}`,
      children: /*#__PURE__*/jsx_runtime_.jsx(components_PackCard, {
        name: item.info.name,
        voucherMetadata: voucherMetadataKey,
        authority: authority,
        cardsRedeemed: cardsRedeemed,
        allowedAmountToRedeem: allowedAmountToRedeem,
        uri: uri,
        artView: true
      })
    });
  }

  const pubkey = isMetadata(item) ? item.pubkey : item.metadata.pubkey;
  return /*#__PURE__*/jsx_runtime_.jsx(external_react_router_dom_.Link, {
    to: `/art/${pubkey}`,
    children: /*#__PURE__*/jsx_runtime_.jsx(ArtCard, {
      pubkey: pubkey,
      preview: false,
      height: ART_CARD_SIZE,
      width: ART_CARD_SIZE,
      artView: true
    })
  });
};

/* harmony default export */ const components_ItemCard = (ItemCard);
;// CONCATENATED MODULE: ./src/views/artworks/index.tsx













const {
  TabPane: artworks_TabPane
} = external_antd_.Tabs;
const {
  Content: artworks_Content
} = external_antd_.Layout;
const ArtworksView = () => {
  const {
    connected
  } = (0,wallet_adapter_react_.useWallet)();
  const {
    isLoading,
    pullAllMetadata,
    storeIndexer,
    pullItemsPage,
    isFetching
  } = (0,meta.useMeta)();
  const {
    userAccounts
  } = (0,lib.useUserAccounts)();
  const {
    0: activeKey,
    1: setActiveKey
  } = (0,external_react_.useState)(ArtworkViewState.Metaplex);
  const userItems = useItems({
    activeKey
  });
  (0,external_react_.useEffect)(() => {
    if (!isFetching) {
      pullItemsPage(userAccounts);
    }
  }, [isFetching]);
  (0,external_react_.useEffect)(() => {
    if (connected) {
      setActiveKey(ArtworkViewState.Owned);
    } else {
      setActiveKey(ArtworkViewState.Metaplex);
    }
  }, [connected, setActiveKey]);
  const isDataLoading = isLoading || isFetching;

  const artworkGrid = /*#__PURE__*/(0,jsx_runtime_.jsxs)("div", {
    className: "artwork-grid",
    children: [isDataLoading && [...Array(10)].map((_, idx) => /*#__PURE__*/jsx_runtime_.jsx(CardLoader, {}, idx)), !isDataLoading && userItems.map(item => {
      var _item$edition;

      const pubkey = isMetadata(item) ? item.pubkey : isPack(item) ? item.provingProcessKey : ((_item$edition = item.edition) === null || _item$edition === void 0 ? void 0 : _item$edition.pubkey) || item.metadata.pubkey;
      return /*#__PURE__*/jsx_runtime_.jsx(components_ItemCard, {
        item: item
      }, pubkey);
    })]
  });

  const refreshButton = connected && storeIndexer.length !== 0 && /*#__PURE__*/jsx_runtime_.jsx(external_antd_.Dropdown.Button, {
    className: "refresh-button padding0",
    onClick: () => pullItemsPage(userAccounts),
    icon: /*#__PURE__*/jsx_runtime_.jsx(icons_.DownOutlined, {}),
    overlayClassName: "refresh-overlay",
    overlay: /*#__PURE__*/jsx_runtime_.jsx(external_antd_.Menu, {
      className: "gray-dropdown",
      children: /*#__PURE__*/jsx_runtime_.jsx(external_antd_.Menu.Item, {
        onClick: () => pullAllMetadata(),
        children: "Load All Metadata"
      })
    }),
    children: "Refresh"
  });

  return /*#__PURE__*/jsx_runtime_.jsx(external_antd_.Layout, {
    style: {
      margin: 0,
      marginTop: 30
    },
    children: /*#__PURE__*/jsx_runtime_.jsx(artworks_Content, {
      style: {
        display: 'flex',
        flexWrap: 'wrap'
      },
      children: /*#__PURE__*/jsx_runtime_.jsx(external_antd_.Col, {
        style: {
          width: '100%',
          marginTop: 10
        },
        children: /*#__PURE__*/jsx_runtime_.jsx(external_antd_.Row, {
          children: /*#__PURE__*/(0,jsx_runtime_.jsxs)(external_antd_.Tabs, {
            activeKey: activeKey,
            onTabClick: key => setActiveKey(key),
            tabBarExtraContent: refreshButton,
            children: [/*#__PURE__*/jsx_runtime_.jsx(artworks_TabPane, {
              tab: /*#__PURE__*/jsx_runtime_.jsx("span", {
                className: "tab-title",
                children: "All"
              }),
              children: artworkGrid
            }, ArtworkViewState.Metaplex), connected && /*#__PURE__*/jsx_runtime_.jsx(artworks_TabPane, {
              tab: /*#__PURE__*/jsx_runtime_.jsx("span", {
                className: "tab-title",
                children: "Owned"
              }),
              children: artworkGrid
            }, ArtworkViewState.Owned), connected && /*#__PURE__*/jsx_runtime_.jsx(artworks_TabPane, {
              tab: /*#__PURE__*/jsx_runtime_.jsx("span", {
                className: "tab-title",
                children: "Created"
              }),
              children: artworkGrid
            }, ArtworkViewState.Created)]
          })
        })
      })
    })
  });
};
// EXTERNAL MODULE: external "react-chartjs-2"
var external_react_chartjs_2_ = __webpack_require__(8182);
;// CONCATENATED MODULE: ./src/views/analytics/index.tsx
function analytics_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

function analytics_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { analytics_ownKeys(Object(source), true).forEach(function (key) { analytics_defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { analytics_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function analytics_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }











const {
  Content: analytics_Content
} = external_antd_.Layout;
const AnalyticsView = () => {
  const mint = (0,lib.useMint)(QUOTE_MINT);
  return mint ? /*#__PURE__*/jsx_runtime_.jsx(InnerAnalytics, {
    mint: mint
  }) : /*#__PURE__*/jsx_runtime_.jsx(external_antd_.Spin, {});
};
var AuctionType;

(function (AuctionType) {
  AuctionType[AuctionType["Open"] = 0] = "Open";
  AuctionType[AuctionType["Limited"] = 1] = "Limited";
  AuctionType[AuctionType["Tiered"] = 2] = "Tiered";
  AuctionType[AuctionType["OneOfKind"] = 3] = "OneOfKind";
})(AuctionType || (AuctionType = {}));

const LOOKUP = {};

const rerun = async ({
  auctionViews,
  auctionManagersByAuction,
  usersEngaged,
  auctionDataExtended,
  bidderPotsByAuctionAndBidder,
  metadata,
  setByType,
  setAverageBids,
  setUsersPublished,
  setAverageSale,
  setHighestSale,
  setSortedSales,
  setUsersWithMetadata,
  setUsersBid,
  setUsersEngaged
}) => {
  let averageBidders = 0;
  let newAverageSale = 0;
  let newHighestSale = 0;
  let totalAuctions = 0;
  const newByType = {
    [AuctionType.Open]: 0,
    [AuctionType.Limited]: 0,
    [AuctionType.Tiered]: 0,
    [AuctionType.OneOfKind]: 0
  };
  const newUsersPublished = {};

  const existingUsersEngaged = analytics_objectSpread({}, usersEngaged);

  let newSortedSales = [];
  const PROGRAM_IDS = (0,lib.programIds)();

  for (let i = 0; i < auctionViews.length; i++) {
    const auction = auctionViews[i]; // Not entirely correct because we're not covering open edition auction bids
    // and their amounts which are super hard to track, but I think they
    // are probably a minority anyway.

    if (auction.auction.info.ended() && auction.auction.info.tokenMint === QUOTE_MINT.toBase58()) {
      if (!LOOKUP[auction.auction.pubkey]) {
        LOOKUP[auction.auction.pubkey] = await (0,lib.getAuctionExtended)({
          auctionProgramId: PROGRAM_IDS.auction,
          resource: auction.vault.pubkey
        });
      }

      const extended = auctionDataExtended[LOOKUP[auction.auction.pubkey]];

      if (extended && extended.info.totalUncancelledBids.toNumber() > 0) {
        totalAuctions++;
        averageBidders += extended.info.totalUncancelledBids.toNumber();
        const bids = auction.auction.info.bidState;
        const highestBid = bids.getAmountAt(0);

        if (highestBid && highestBid.toNumber() > newHighestSale) {
          newHighestSale = highestBid.toNumber();
        }

        const allWinningBids = bids.bids.slice(bids.bids.length - bids.max.toNumber()).map(i => i.amount.toNumber());
        newAverageSale += allWinningBids.reduce((acc, r) => acc += r, 0);
        newSortedSales = newSortedSales.concat(allWinningBids);
      }
    }

    newUsersPublished[auction.auctionManager.authority] = true;
    existingUsersEngaged[auction.auctionManager.authority] = true;
    let type = undefined;

    if (auction.items.find(set => set.length > 1)) {
      type = AuctionType.Tiered;
    } else if (auction.items.length && auction.items[0].length) {
      type = auction.items[0][0].winningConfigType == metaplex.WinningConfigType.TokenOnlyTransfer ? AuctionType.OneOfKind : AuctionType.Limited;
    } else {
      type = AuctionType.Open;
    }

    newByType[type]++;
  }

  const newUsersBid = {};
  Object.values(bidderPotsByAuctionAndBidder).forEach(acct => {
    if (auctionManagersByAuction[acct.info.auctionAct]) {
      newUsersBid[acct.info.bidderAct] = true;
      existingUsersEngaged[acct.info.bidderAct] = true;
    }
  });
  const newBuild = {};
  metadata.forEach(acct => {
    var _acct$info$data$creat;

    newBuild[acct.info.updateAuthority] = true;
    existingUsersEngaged[acct.info.updateAuthority] = true;
    (_acct$info$data$creat = acct.info.data.creators) === null || _acct$info$data$creat === void 0 ? void 0 : _acct$info$data$creat.forEach(c => {
      newBuild[c.address] = true;
      existingUsersEngaged[c.address] = true;
    });
  });
  setByType(newByType);
  setAverageBids(averageBidders / totalAuctions);
  setUsersPublished(newUsersPublished);
  setAverageSale(newAverageSale / totalAuctions);
  setHighestSale(newHighestSale);
  setSortedSales(newSortedSales.sort());
  setUsersWithMetadata(newBuild);
  setUsersBid(newUsersBid);
  setUsersEngaged(engaged => analytics_objectSpread(analytics_objectSpread({}, engaged), existingUsersEngaged));
};

const MemoizedBar = /*#__PURE__*/external_react_default().memo(function BarImpl(props) {
  const histogrammedData = {
    0: 0,
    5: 0,
    20: 0,
    50: 0,
    100: 0,
    500: 0,
    1000: 0,
    10000: 0
  };
  const asArray = [0, 5, 20, 50, 100, 500, 1000, 10000];

  for (let i = 0; i < asArray.length; i++) {
    const currRange = asArray[i];

    if (i < asArray.length - 1) {
      const nextRange = asArray[i + 1];
      histogrammedData[currRange] = props.sortedSales.filter(s => (0,lib.fromLamports)(s, props.mint) >= currRange && (0,lib.fromLamports)(s, props.mint) < nextRange).length;
    } else {
      histogrammedData[currRange] = props.sortedSales.filter(s => (0,lib.fromLamports)(s, props.mint) >= currRange).length;
    }
  }

  const histoData = {
    labels: ['◎ [0 - 5)', '◎ [5 - 20)', '◎ [20 - 50)', '◎ [50 - 100)', '◎ [100 - 500)', '◎ [500 - 1000)', '◎ [1000 - 10000)', '◎ [10000 -'],
    datasets: [{
      label: '# bids in these bins',
      data: asArray.map(a => histogrammedData[a]),
      backgroundColor: ['rgba(255, 99, 132, 0.2)', 'rgba(54, 162, 235, 0.2)', 'rgba(255, 206, 86, 0.2)', 'rgba(75, 192, 192, 0.2)', 'rgba(153, 102, 255, 0.2)', 'rgba(255, 159, 64, 0.2)', 'rgba(255, 139, 24, 0.2)', 'rgba(212, 39, 24, 0.2)'],
      borderColor: ['rgba(255, 99, 132, 1)', 'rgba(54, 162, 235, 1)', 'rgba(255, 206, 86, 1)', 'rgba(75, 192, 192, 1)', 'rgba(153, 102, 255, 1)', 'rgba(255, 159, 64, 1)', 'rgba(255, 139, 24, 1)', 'rgba(212, 39, 24, 1)'],
      borderWidth: 1
    }]
  };
  const histoOptions = {
    scales: {
      yAxes: [{
        ticks: {
          beginAtZero: true
        }
      }]
    }
  }; // @ts-ignore

  return /*#__PURE__*/jsx_runtime_.jsx(external_react_chartjs_2_.Bar, {
    data: histoData,
    options: histoOptions
  });
});
const MemoizedPie = /*#__PURE__*/external_react_default().memo(function PieImpl(props) {
  const pieData = {
    labels: ['Open', 'Limited', 'Tiered', 'One of a Kind'],
    datasets: [{
      label: '#',
      data: [props.byType[AuctionType.Open], props.byType[AuctionType.Limited], props.byType[AuctionType.Tiered], props.byType[AuctionType.OneOfKind]],
      backgroundColor: ['rgba(255, 99, 132, 0.2)', 'rgba(54, 162, 235, 0.2)', 'rgba(255, 206, 86, 0.2)', 'rgba(75, 192, 192, 0.2)'],
      borderColor: ['rgba(255, 99, 132, 1)', 'rgba(54, 162, 235, 1)', 'rgba(255, 206, 86, 1)', 'rgba(75, 192, 192, 1)'],
      borderWidth: 1
    }]
  };
  return /*#__PURE__*/jsx_runtime_.jsx(external_react_chartjs_2_.Pie, {
    data: pieData
  });
});

function InnerAnalytics({
  mint
}) {
  const {
    0: usersWithMetadata,
    1: setUsersWithMetadata
  } = (0,external_react_.useState)({});
  const {
    0: usersPublished,
    1: setUsersPublished
  } = (0,external_react_.useState)({});
  const {
    0: usersBid,
    1: setUsersBid
  } = (0,external_react_.useState)({});
  const {
    0: usersEngaged,
    1: setUsersEngaged
  } = (0,external_react_.useState)({});
  const {
    0: byType,
    1: setByType
  } = (0,external_react_.useState)({
    [AuctionType.Open]: 0,
    [AuctionType.Limited]: 0,
    [AuctionType.Tiered]: 0,
    [AuctionType.OneOfKind]: 0
  });
  const {
    0: averageBids,
    1: setAverageBids
  } = (0,external_react_.useState)(0);
  const {
    0: averageSale,
    1: setAverageSale
  } = (0,external_react_.useState)(0);
  const {
    0: highestSale,
    1: setHighestSale
  } = (0,external_react_.useState)(0);
  const {
    0: sortedSales,
    1: setSortedSales
  } = (0,external_react_.useState)([]);
  const {
    metadata,
    // stores,
    auctionManagersByAuction,
    bidderPotsByAuctionAndBidder,
    auctionDataExtended
  } = (0,meta.useMeta)();
  const totalNFTs = metadata.length; // const totalMarketplaces = Object.values(stores).length;

  const auctionViews = useAuctions();
  return /*#__PURE__*/jsx_runtime_.jsx(analytics_Content, {
    children: /*#__PURE__*/(0,jsx_runtime_.jsxs)(external_antd_.Col, {
      style: {
        marginTop: 10
      },
      children: [/*#__PURE__*/jsx_runtime_.jsx(external_antd_.Button, {
        type: "primary",
        size: "large",
        className: "action-btn",
        onClick: () => rerun({
          auctionViews,
          auctionManagersByAuction,
          usersEngaged,
          auctionDataExtended,
          bidderPotsByAuctionAndBidder,
          metadata,
          setByType,
          setAverageBids,
          setUsersPublished,
          setAverageSale,
          setHighestSale,
          setSortedSales,
          setUsersWithMetadata,
          setUsersBid,
          setUsersEngaged
        }),
        children: "RERUN CALCULATION"
      }), /*#__PURE__*/jsx_runtime_.jsx("h1", {
        children: "Overview"
      }), /*#__PURE__*/(0,jsx_runtime_.jsxs)("h3", {
        children: ["Total NFTs: ", totalNFTs]
      }), /*#__PURE__*/jsx_runtime_.jsx("h1", {
        children: "User Breakdown"
      }), /*#__PURE__*/(0,jsx_runtime_.jsxs)("h3", {
        children: ["Any Engagement: ", Object.values(usersEngaged).length]
      }), /*#__PURE__*/(0,jsx_runtime_.jsxs)("h3", {
        children: ["That bid: ", Object.values(usersBid).length]
      }), /*#__PURE__*/(0,jsx_runtime_.jsxs)("h3", {
        children: ["That sold items: ", Object.values(usersPublished).length]
      }), /*#__PURE__*/(0,jsx_runtime_.jsxs)("h3", {
        children: ["That minted NFTs: ", Object.values(usersWithMetadata).length]
      }), /*#__PURE__*/jsx_runtime_.jsx("h1", {
        children: "Sale Info"
      }), /*#__PURE__*/(0,jsx_runtime_.jsxs)("h3", {
        children: ["Total Sales: \u25CE", (0,lib.fromLamports)(sortedSales.reduce((acc, r) => acc += r, 0), mint)]
      }), /*#__PURE__*/jsx_runtime_.jsx(MemoizedBar, {
        sortedSales: sortedSales,
        mint: mint
      }), /*#__PURE__*/(0,jsx_runtime_.jsxs)("h3", {
        children: ["Highest Sale: \u25CE ", (0,lib.fromLamports)(highestSale, mint)]
      }), /*#__PURE__*/(0,jsx_runtime_.jsxs)("h3", {
        children: ["Average Sale: \u25CE ", (0,lib.fromLamports)(averageSale, mint)]
      }), /*#__PURE__*/jsx_runtime_.jsx("h1", {
        children: "Auction Info"
      }), /*#__PURE__*/(0,jsx_runtime_.jsxs)("h3", {
        children: ["Average Bids per Auction: ", averageBids]
      }), /*#__PURE__*/jsx_runtime_.jsx(MemoizedPie, {
        byType: byType
      })]
    })
  });
}
;// CONCATENATED MODULE: ./src/components/StaticPage/index.tsx












//https://stackoverflow.com/questions/1480133/how-can-i-get-an-objects-absolute-position-on-the-page-in-javascript
const cumulativeOffset = element => {
  let top = 0,
      left = 0;
  let cumulativeElement = element;

  do {
    // @ts-ignore
    top += cumulativeElement.offsetTop || 0; // @ts-ignore

    left += cumulativeElement.offsetLeft || 0; // @ts-ignore

    cumulativeElement = cumulativeElement.offsetParent;
  } while (cumulativeElement);

  return {
    top: top,
    left: left
  };
};

const StaticPage = props => {
  var _props$leftContent, _props$leftContent2, _props$leftContent3, _props$leftContent4, _props$leftContent4$a, _props$leftContent5, _props$leftContent5$a;

  const {
    0: dimensions,
    1: setDimensions
  } = (0,external_react_.useState)({
    height: window.innerHeight,
    width: window.innerWidth
  });
  (0,external_react_.useEffect)(() => {
    function handleResize() {
      setDimensions({
        height: window.innerHeight,
        width: window.innerWidth
      });
    }

    window.addEventListener('resize', handleResize);
    return () => window.removeEventListener('resize', handleResize);
  });
  const auctions = useAuctions(AuctionViewState.Live);
  const {
    isLoading
  } = (0,meta.useMeta)();
  const breakpointColumnsObj = {
    default: 4,
    1100: 3,
    700: 2,
    500: 1
  };
  const liveAuctions = auctions.sort((a, b) => {
    var _a$auction$info$ended;

    return ((_a$auction$info$ended = a.auction.info.endedAt) === null || _a$auction$info$ended === void 0 ? void 0 : _a$auction$info$ended.sub(b.auction.info.endedAt || new (external_bn_js_default())(0)).toNumber()) || 0;
  });

  const liveAuctionsView = /*#__PURE__*/jsx_runtime_.jsx((external_react_masonry_css_default()), {
    breakpointCols: breakpointColumnsObj,
    className: "my-masonry-grid",
    columnClassName: "my-masonry-grid_column",
    children: !isLoading ? liveAuctions.map((m, idx) => {
      const id = m.auction.pubkey;
      return /*#__PURE__*/jsx_runtime_.jsx(external_react_router_dom_.Link, {
        to: `/auction/${id}`,
        children: /*#__PURE__*/jsx_runtime_.jsx(AuctionRenderCard, {
          auctionView: m
        }, id)
      }, idx);
    }) : [...Array(10)].map((_, idx) => /*#__PURE__*/jsx_runtime_.jsx(CardLoader, {}, idx))
  });

  const addGradients = () => {
    const headerGradient = document.getElementById('static-header-gradient');
    const endGradient = document.getElementById('static-end-gradient');
    const upper = document.getElementById('header-container');
    const lower = document.getElementById('bottom-container');
    if (headerGradient) headerGradient.style.display = 'inline-block';
    if (endGradient) endGradient.style.display = 'inline-block';

    if (upper && headerGradient) {
      const container = cumulativeOffset(upper);
      headerGradient.style.top = `${container.top + upper.offsetHeight - headerGradient.offsetHeight}px`;
    }

    if (lower && endGradient) {
      const container = cumulativeOffset(lower);
      endGradient.style.top = `${container.top}px`;
    }
  };

  (0,external_react_.useEffect)(() => {
    addGradients();
    return () => {
      const headerGradient = document.getElementById('static-header-gradient');
      const endGradient = document.getElementById('static-end-gradient');
      if (headerGradient) headerGradient.style.display = 'none';
      if (endGradient) endGradient.style.display = 'none';
    };
  }, [dimensions]);
  (0,external_react_.useEffect)(() => {
    setTimeout(() => addGradients(), 500);
  }, []);

  const headerSection = /*#__PURE__*/jsx_runtime_.jsx("section", {
    id: "header-container",
    children: /*#__PURE__*/(0,jsx_runtime_.jsxs)(external_antd_.Row, {
      children: [/*#__PURE__*/(0,jsx_runtime_.jsxs)(external_antd_.Col, {
        span: 24,
        xl: 8,
        className: "header-left",
        children: [/*#__PURE__*/jsx_runtime_.jsx("p", {
          className: "header-subtitle",
          children: props.headContent.subtitle
        }), /*#__PURE__*/jsx_runtime_.jsx(external_antd_.Divider, {}), /*#__PURE__*/jsx_runtime_.jsx("p", {
          className: "header-title",
          children: props.headContent.title
        }), props.headContent.author && /*#__PURE__*/(0,jsx_runtime_.jsxs)("div", {
          className: "author-container",
          children: [/*#__PURE__*/jsx_runtime_.jsx("img", {
            src: props.headContent.author.avatar,
            className: "author-avatar",
            width: "32px",
            height: "32px",
            alt: "author image"
          }), /*#__PURE__*/jsx_runtime_.jsx("p", {
            className: "author-name",
            children: props.headContent.author.name
          })]
        })]
      }), /*#__PURE__*/jsx_runtime_.jsx(external_antd_.Col, {
        xl: 16,
        span: 24,
        className: "header-right",
        children: /*#__PURE__*/jsx_runtime_.jsx("img", {
          src: props.headContent.bannerImage,
          className: "header-image",
          width: "880px",
          height: "620px",
          alt: `${props.headContent.title} image`
        })
      })]
    })
  });

  const leftSection = props.leftContent && /*#__PURE__*/(0,jsx_runtime_.jsxs)("section", {
    id: "left-container",
    className: "author-container",
    children: [/*#__PURE__*/jsx_runtime_.jsx("img", {
      src: (_props$leftContent = props.leftContent) === null || _props$leftContent === void 0 ? void 0 : _props$leftContent.author.avatar,
      className: "author-avatar",
      alt: "author image"
    }), /*#__PURE__*/jsx_runtime_.jsx("p", {
      className: "author-name",
      children: (_props$leftContent2 = props.leftContent) === null || _props$leftContent2 === void 0 ? void 0 : _props$leftContent2.author.name
    }), /*#__PURE__*/(0,jsx_runtime_.jsxs)("div", {
      className: "author-details",
      children: [/*#__PURE__*/jsx_runtime_.jsx("p", {
        className: "author-subtitle",
        children: "Details"
      }), /*#__PURE__*/jsx_runtime_.jsx("p", {
        children: (_props$leftContent3 = props.leftContent) === null || _props$leftContent3 === void 0 ? void 0 : _props$leftContent3.author.details
      })]
    }), /*#__PURE__*/(0,jsx_runtime_.jsxs)("div", {
      className: "author-stats",
      children: [/*#__PURE__*/jsx_runtime_.jsx("p", {
        className: "author-subtitle",
        children: "Stats"
      }), (_props$leftContent4 = props.leftContent) === null || _props$leftContent4 === void 0 ? void 0 : (_props$leftContent4$a = _props$leftContent4.author.stats) === null || _props$leftContent4$a === void 0 ? void 0 : _props$leftContent4$a.map((e, i) => /*#__PURE__*/jsx_runtime_.jsx("p", {
        children: e
      }, i))]
    }), /*#__PURE__*/(0,jsx_runtime_.jsxs)("div", {
      className: "author-connect",
      children: [/*#__PURE__*/jsx_runtime_.jsx("p", {
        className: "author-subtitle",
        children: "Connect with the artist"
      }), (_props$leftContent5 = props.leftContent) === null || _props$leftContent5 === void 0 ? void 0 : (_props$leftContent5$a = _props$leftContent5.author.connectWith) === null || _props$leftContent5$a === void 0 ? void 0 : _props$leftContent5$a.map((e, ii) => /*#__PURE__*/jsx_runtime_.jsx("p", {
        children: /*#__PURE__*/jsx_runtime_.jsx("a", {
          href: e.url,
          children: e.label
        })
      }, ii))]
    })]
  });

  const middleSection = /*#__PURE__*/jsx_runtime_.jsx("section", {
    id: "middle-container",
    children: props.midContent.sections.map((section, i) => {
      var _section$paragraphs;

      return /*#__PURE__*/(0,jsx_runtime_.jsxs)("div", {
        className: "mid-section-item",
        children: [section.title && /*#__PURE__*/jsx_runtime_.jsx("span", {
          className: "mid-title",
          children: section.title
        }), (_section$paragraphs = section.paragraphs) === null || _section$paragraphs === void 0 ? void 0 : _section$paragraphs.map((paragraph, ii) => /*#__PURE__*/jsx_runtime_.jsx("p", {
          className: "paragraph-text",
          children: paragraph
        }, ii)), section.image && /*#__PURE__*/jsx_runtime_.jsx("img", {
          src: section.image,
          className: "image",
          width: "720px",
          height: "450px",
          alt: `${section.title} image`
        }), section.caption && /*#__PURE__*/(0,jsx_runtime_.jsxs)("p", {
          className: "image-caption",
          children: [section.caption.text, /*#__PURE__*/jsx_runtime_.jsx("a", {
            href: section.caption.linkUrl,
            rel: "noreferrer",
            target: "_blank",
            children: section.caption.linkText
          })]
        })]
      }, i);
    })
  });

  const rightSection = /*#__PURE__*/jsx_runtime_.jsx("section", {
    id: "right-container"
  });

  const finalSection = /*#__PURE__*/(0,jsx_runtime_.jsxs)("section", {
    id: "bottom-container",
    children: [/*#__PURE__*/jsx_runtime_.jsx("p", {
      className: "bottom-title",
      children: "Shop the Collection"
    }), liveAuctionsView]
  });

  return /*#__PURE__*/(0,jsx_runtime_.jsxs)(external_react_.Fragment, {
    children: [headerSection, /*#__PURE__*/(0,jsx_runtime_.jsxs)(external_antd_.Row, {
      className: "static-page-container",
      children: [/*#__PURE__*/jsx_runtime_.jsx(external_antd_.Col, {
        xs: 24,
        md: 4,
        children: leftSection
      }), /*#__PURE__*/jsx_runtime_.jsx(external_antd_.Col, {
        xs: 24,
        md: 16,
        children: middleSection
      }), /*#__PURE__*/jsx_runtime_.jsx(external_antd_.Col, {
        xs: 24,
        md: 4,
        children: rightSection
      })]
    }), props.bottomContent && finalSection]
  });
};
;// CONCATENATED MODULE: ./src/views/staticPage/staticData.js
const data = {
  headContent: {
    title: 'We are Metaplex',
    subtitle: 'About Us',
    bannerImage: '/main-banner.png'
  },
  leftContent: undefined,
  midContent: {
    sections: [{
      title: 'Metaplex is a protocol built on top of Solana that allows:',
      paragraphs: ['• Creating/Minting non-fungible tokens;', '• Starting a variety of auctions for primary/secondary sales;', '• and Visualizing NFTs in a standard way across wallets and applications.'],
      image: '/main-banner.png'
    }]
  },
  bottomContent: true
};
;// CONCATENATED MODULE: ./src/views/staticPage/index.tsx





const StaticPageView = () => {
  return /*#__PURE__*/jsx_runtime_.jsx(external_antd_.Layout, {
    style: {
      margin: 0,
      alignItems: 'center'
    },
    children: /*#__PURE__*/jsx_runtime_.jsx(StaticPage, {
      leftContent: data.leftContent,
      headContent: data.headContent,
      midContent: data.midContent,
      bottomContent: data.bottomContent
    })
  });
};
;// CONCATENATED MODULE: ./src/views/index.tsx










;// CONCATENATED MODULE: ./src/actions/convertMasterEditions.ts



const convertMasterEditions_BATCH_SIZE = 10;
const CONVERT_TRANSACTION_SIZE = 10;
async function filterMetadata(connection, metadata, masterEditions, accountsByMint) {
  const available = [];
  const unavailable = [];
  let batchWaitCounter = 0;

  for (let i = 0; i < metadata.length; i++) {
    const md = metadata[i];
    const masterEdition = masterEditions[md.info.masterEdition || ''];

    if (masterEdition && (masterEdition === null || masterEdition === void 0 ? void 0 : masterEdition.info.key) == lib.MetadataKey.MasterEditionV1) {
      if (batchWaitCounter == 10) {
        console.log('Waiting 10s before continuing to avoid rate limits');
        await new Promise(resolve => setTimeout(resolve, 10000));
        batchWaitCounter = 0;
      }

      console.log('Reviewing', masterEdition.pubkey);
      let printingBal = 0;

      try {
        const printingBalResp = await connection.getTokenSupply((0,lib.toPublicKey)(masterEdition.info.printingMint));
        printingBal = printingBalResp.value.uiAmount || 0;
      } catch (e) {
        console.error(e);
      }

      const myAcct = accountsByMint.get(masterEdition.info.printingMint);

      if (myAcct) {
        console.log('Existing print account subtracts', myAcct.info.amount.toNumber(), 'from', printingBal);
        printingBal -= myAcct.info.amount.toNumber();
      }

      if (printingBal > 0) {
        console.log('Reject', masterEdition.pubkey, 'due to printing bal of', printingBal);
        unavailable.push(masterEdition);
      } else {
        let oneTimeBal = 0;

        try {
          const oneTimeBalResp = await connection.getTokenSupply((0,lib.toPublicKey)(masterEdition.info.oneTimePrintingAuthorizationMint));
          oneTimeBal = oneTimeBalResp.value.uiAmount || 0;
        } catch (e) {
          console.error(e);
        }

        const myAcct = accountsByMint.get(masterEdition.info.oneTimePrintingAuthorizationMint);

        if (myAcct) {
          console.log('Existing one time account subtracts', myAcct.info.amount.toNumber(), 'from', oneTimeBal);
          oneTimeBal -= myAcct.info.amount.toNumber();
        }

        if (oneTimeBal > 0) {
          console.log('Reject', masterEdition.pubkey, 'due to one time auth bal of', oneTimeBal);
          unavailable.push(masterEdition);
        } else {
          available.push(masterEdition);
        }
      }

      batchWaitCounter++;
    }
  }

  return {
    available,
    unavailable
  };
} // Given a vault you own, unwind all the tokens out of it.

async function convertMasterEditions(connection, wallet, masterEditions, accountsByMint) {
  if (!wallet.publicKey) throw new wallet_adapter_base_.WalletNotConnectedError();
  const PROGRAM_IDS = (0,lib.programIds)();
  const signers = [];
  const instructions = [];
  let currSignerBatch = [];
  let currInstrBatch = [];
  let convertSigners = [];
  let convertInstructions = []; // TODO replace all this with payer account so user doesnt need to click approve several times.

  for (let i = 0; i < masterEditions.length; i++) {
    const masterEdition = masterEditions[i];
    console.log('Converting', masterEdition.pubkey);
    const printingMintAcct = accountsByMint.get(masterEdition.info.printingMint);
    const oneTimeAuthMintAcct = accountsByMint.get(masterEdition.info.oneTimePrintingAuthorizationMint);

    if (printingMintAcct) {
      if (printingMintAcct.info.amount.toNumber() > 0) {
        convertInstructions.push(spl_token_.Token.createBurnInstruction(PROGRAM_IDS.token, (0,lib.toPublicKey)(masterEdition.info.printingMint), (0,lib.toPublicKey)(printingMintAcct.pubkey), wallet.publicKey, [], printingMintAcct.info.amount));
      }

      convertInstructions.push(spl_token_.Token.createCloseAccountInstruction(PROGRAM_IDS.token, (0,lib.toPublicKey)(printingMintAcct.pubkey), wallet.publicKey, wallet.publicKey, []));
    }

    if (oneTimeAuthMintAcct) {
      if (oneTimeAuthMintAcct.info.amount.toNumber() > 0) {
        convertInstructions.push(spl_token_.Token.createBurnInstruction(PROGRAM_IDS.token, (0,lib.toPublicKey)(masterEdition.info.oneTimePrintingAuthorizationMint), (0,lib.toPublicKey)(oneTimeAuthMintAcct.pubkey), wallet.publicKey, [], oneTimeAuthMintAcct.info.amount));
      }

      convertInstructions.push(spl_token_.Token.createCloseAccountInstruction(PROGRAM_IDS.token, (0,lib.toPublicKey)(oneTimeAuthMintAcct.pubkey), wallet.publicKey, wallet.publicKey, []));
    }

    await (0,lib.convertMasterEditionV1ToV2)(masterEdition.pubkey, masterEdition.info.oneTimePrintingAuthorizationMint, masterEdition.info.printingMint, convertInstructions);

    if (convertInstructions.length === CONVERT_TRANSACTION_SIZE) {
      currSignerBatch.push(convertSigners);
      currInstrBatch.push(convertInstructions);
      convertSigners = [];
      convertInstructions = [];
    }

    if (currInstrBatch.length === convertMasterEditions_BATCH_SIZE) {
      signers.push(currSignerBatch);
      instructions.push(currInstrBatch);
      currSignerBatch = [];
      currInstrBatch = [];
    }
  }

  if (convertInstructions.length < CONVERT_TRANSACTION_SIZE && convertInstructions.length > 0) {
    currSignerBatch.push(convertSigners);
    currInstrBatch.push(convertInstructions);
  }

  if (currInstrBatch.length <= convertMasterEditions_BATCH_SIZE && currInstrBatch.length > 0) {
    // add the last one on
    signers.push(currSignerBatch);
    instructions.push(currInstrBatch);
  }

  console.log('Instructions', instructions);

  for (let i = 0; i < instructions.length; i++) {
    const instructionBatch = instructions[i];
    const signerBatch = signers[i];
    console.log('Running batch', i);
    if (instructionBatch.length >= 2) // Pump em through!
      await (0,lib.sendTransactions)(connection, wallet, instructionBatch, signerBatch, lib.SequenceType.StopOnFailure, 'single');else await (0,lib.sendTransactionWithRetry)(connection, wallet, instructionBatch[0], signerBatch[0], 'single');
    console.log('Done');
  }
}
;// CONCATENATED MODULE: ./src/actions/cacheAllAuctions.ts



 // This command caches an auction at position 0, page 0, and moves everything up

async function cacheAllAuctions(wallet, connection, tempCache) {
  var _programIds$store;

  if (!(0,lib.programIds)().store) {
    return false;
  }

  const store = (_programIds$store = (0,lib.programIds)().store) === null || _programIds$store === void 0 ? void 0 : _programIds$store.toBase58();

  if (tempCache.storeIndexer.length) {
    console.log('----> Previously indexed. Pulling all.'); // well now we need to pull first.

    tempCache = await (0,lib.loadAccounts)(connection);
  }

  let auctionManagersToCache = Object.values(tempCache.auctionManagersByAuction).filter(a => a.info.store == store).sort((a, b) => (tempCache.auctions[b.info.auction].info.endedAt || new external_bn_js_.BN(Date.now() / 1000)).sub(tempCache.auctions[a.info.auction].info.endedAt || new external_bn_js_.BN(Date.now() / 1000)).toNumber());
  const indexedInStoreIndexer = {};
  tempCache.storeIndexer.forEach(s => {
    s.info.auctionCaches.forEach(a => indexedInStoreIndexer[a] = true);
  });
  const alreadyIndexed = Object.values(tempCache.auctionCaches).reduce((hash, val) => {
    hash[val.info.auctionManager] = indexedInStoreIndexer[val.pubkey];
    return hash;
  }, {});
  auctionManagersToCache = auctionManagersToCache.filter(a => !alreadyIndexed[a.pubkey]);
  console.log('----> Found ', auctionManagersToCache.length, 'auctions to cache.');
  let storeIndex = tempCache.storeIndexer;

  for (let i = 0; i < auctionManagersToCache.length; i++) {
    const auctionManager = auctionManagersToCache[i];
    const boxes = buildListWhileNonZero(tempCache.safetyDepositBoxesByVaultAndIndex, auctionManager.info.vault);

    if (auctionManager.info.key === lib.MetaplexKey.AuctionManagerV2) {
      const {
        instructions,
        signers
      } = await cacheAuctionIndexer(wallet, auctionManager.info.vault, auctionManager.info.auction, auctionManager.pubkey, boxes.map(a => a.info.tokenMint), storeIndex, !!tempCache.auctionCaches[await (0,lib.getAuctionCache)(auctionManager.info.auction)]);
      await (0,lib.sendTransactions)(connection, wallet, instructions, signers, lib.SequenceType.StopOnFailure, 'max');
      storeIndex = await (0,lib.pullPages)(connection);
    }
  }
}
;// CONCATENATED MODULE: ./src/views/admin/index.tsx
function admin_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

function admin_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { admin_ownKeys(Object(source), true).forEach(function (key) { admin_defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { admin_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function admin_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }















const {
  Content: admin_Content
} = external_antd_.Layout;
const AdminView = () => {
  var _wallet$publicKey;

  const {
    store,
    whitelistedCreatorsByCreator,
    isLoading
  } = (0,meta.useMeta)();
  const connection = (0,lib.useConnection)();
  const wallet = (0,wallet_adapter_react_.useWallet)();
  const {
    setVisible
  } = (0,lib.useWalletModal)();
  const connect = (0,external_react_.useCallback)(() => wallet.wallet ? wallet.connect().catch() : setVisible(true), [wallet.wallet, wallet.connect, setVisible]);
  const {
    storeAddress,
    setStoreForOwner,
    isConfigured
  } = (0,lib.useStore)();
  (0,external_react_.useEffect)(() => {
    if (!store && !storeAddress && wallet.publicKey && !"7i9UEXJJEvy6gSE7DF7pEvbeA2MfrknkZiFtEmpNm14G") {
      setStoreForOwner(wallet.publicKey.toBase58());
    }
  }, [store, storeAddress, wallet.publicKey]);
  console.log('@admin', wallet.connected, storeAddress, isLoading, store);
  return /*#__PURE__*/jsx_runtime_.jsx(jsx_runtime_.Fragment, {
    children: !wallet.connected ? /*#__PURE__*/(0,jsx_runtime_.jsxs)("p", {
      children: [/*#__PURE__*/jsx_runtime_.jsx(external_antd_.Button, {
        type: "primary",
        className: "app-btn",
        onClick: connect,
        children: "Connect"
      }), ' ', "to admin store."]
    }) : !storeAddress || isLoading ? /*#__PURE__*/jsx_runtime_.jsx(external_antd_.Spin, {}) : store && wallet ? /*#__PURE__*/(0,jsx_runtime_.jsxs)(jsx_runtime_.Fragment, {
      children: [/*#__PURE__*/jsx_runtime_.jsx(InnerAdminView, {
        store: store,
        whitelistedCreatorsByCreator: whitelistedCreatorsByCreator,
        connection: connection,
        wallet: wallet,
        connected: wallet.connected
      }), !isConfigured && /*#__PURE__*/(0,jsx_runtime_.jsxs)(jsx_runtime_.Fragment, {
        children: [/*#__PURE__*/jsx_runtime_.jsx(external_antd_.Divider, {}), /*#__PURE__*/jsx_runtime_.jsx(external_antd_.Divider, {}), /*#__PURE__*/(0,jsx_runtime_.jsxs)("p", {
          children: ["To finish initialization please copy config below into", ' ', /*#__PURE__*/jsx_runtime_.jsx("b", {
            children: "packages/web/.env"
          }), " and restart yarn or redeploy"]
        }), /*#__PURE__*/jsx_runtime_.jsx(SetupVariables, {
          storeAddress: storeAddress,
          storeOwnerAddress: (_wallet$publicKey = wallet.publicKey) === null || _wallet$publicKey === void 0 ? void 0 : _wallet$publicKey.toBase58()
        })]
      })]
    }) : /*#__PURE__*/(0,jsx_runtime_.jsxs)(jsx_runtime_.Fragment, {
      children: [/*#__PURE__*/jsx_runtime_.jsx("p", {
        children: "Store is not initialized"
      }), /*#__PURE__*/jsx_runtime_.jsx(external_react_router_dom_.Link, {
        to: `/`,
        children: "Go to initialize"
      })]
    })
  });
};

function ArtistModal({
  setUpdatedCreators,
  uniqueCreatorsWithUpdates
}) {
  const {
    0: modalOpen,
    1: setModalOpen
  } = (0,external_react_.useState)(false);
  const {
    0: modalAddress,
    1: setModalAddress
  } = (0,external_react_.useState)('');
  return /*#__PURE__*/(0,jsx_runtime_.jsxs)(jsx_runtime_.Fragment, {
    children: [/*#__PURE__*/jsx_runtime_.jsx(external_antd_.Modal, {
      className: 'modal-box',
      title: "Add New Artist Address",
      visible: modalOpen,
      onOk: () => {
        const addressToAdd = modalAddress;
        setModalAddress('');
        setModalOpen(false);

        if (uniqueCreatorsWithUpdates[addressToAdd]) {
          (0,lib.notify)({
            message: 'Artist already added!',
            type: 'error'
          });
          return;
        }

        let address;

        try {
          address = addressToAdd;
          setUpdatedCreators(u => admin_objectSpread(admin_objectSpread({}, u), {}, {
            [modalAddress]: new metaplex.WhitelistedCreator({
              address,
              activated: true
            })
          }));
        } catch {
          (0,lib.notify)({
            message: 'Only valid Solana addresses are supported',
            type: 'error'
          });
        }
      },
      onCancel: () => {
        setModalAddress('');
        setModalOpen(false);
      },
      children: /*#__PURE__*/jsx_runtime_.jsx(external_antd_.Input, {
        value: modalAddress,
        onChange: e => setModalAddress(e.target.value)
      })
    }), /*#__PURE__*/jsx_runtime_.jsx(external_antd_.Button, {
      onClick: () => setModalOpen(true),
      children: "Add Creator"
    })]
  });
}

function InnerAdminView({
  store,
  whitelistedCreatorsByCreator,
  connection,
  wallet,
  connected
}) {
  const {
    0: newStore,
    1: setNewStore
  } = (0,external_react_.useState)(store && store.info && new metaplex.Store(store.info));
  const {
    0: updatedCreators,
    1: setUpdatedCreators
  } = (0,external_react_.useState)({});
  const {
    0: filteredMetadata,
    1: setFilteredMetadata
  } = (0,external_react_.useState)();
  const {
    0: loading,
    1: setLoading
  } = (0,external_react_.useState)();
  const {
    metadata,
    masterEditions
  } = (0,meta.useMeta)();
  const state = (0,meta.useMeta)();
  const {
    accountByMint
  } = (0,lib.useUserAccounts)();
  (0,external_react_.useMemo)(() => {
    const fn = async () => {
      setFilteredMetadata(await filterMetadata(connection, metadata, masterEditions, accountByMint));
    };

    fn();
  }, [connected]);
  const uniqueCreators = Object.values(whitelistedCreatorsByCreator).reduce((acc, e) => {
    acc[e.info.address] = e.info;
    return acc;
  }, {});

  const uniqueCreatorsWithUpdates = admin_objectSpread(admin_objectSpread({}, uniqueCreators), updatedCreators);

  const columns = [{
    title: 'Name',
    dataIndex: 'name',
    key: 'name'
  }, {
    title: 'Address',
    dataIndex: 'address',
    render: val => /*#__PURE__*/jsx_runtime_.jsx("span", {
      children: val
    }),
    key: 'address'
  }, {
    title: 'Activated',
    dataIndex: 'activated',
    key: 'activated',
    render: (value, record) => /*#__PURE__*/jsx_runtime_.jsx(external_antd_.Switch, {
      checkedChildren: "Active",
      unCheckedChildren: "Inactive",
      checked: value,
      onChange: val => setUpdatedCreators(u => admin_objectSpread(admin_objectSpread({}, u), {}, {
        [record.key]: new metaplex.WhitelistedCreator({
          activated: val,
          address: record.address
        })
      }))
    })
  }];
  return /*#__PURE__*/(0,jsx_runtime_.jsxs)(admin_Content, {
    className: 'admin-content',
    children: [/*#__PURE__*/(0,jsx_runtime_.jsxs)(external_antd_.Col, {
      style: {
        marginTop: 10
      },
      children: [/*#__PURE__*/(0,jsx_runtime_.jsxs)(external_antd_.Row, {
        children: [/*#__PURE__*/(0,jsx_runtime_.jsxs)(external_antd_.Col, {
          span: 21,
          children: [/*#__PURE__*/jsx_runtime_.jsx(ArtistModal, {
            setUpdatedCreators: setUpdatedCreators,
            uniqueCreatorsWithUpdates: uniqueCreatorsWithUpdates
          }), /*#__PURE__*/jsx_runtime_.jsx(external_antd_.Button, {
            onClick: async () => {
              (0,lib.notify)({
                message: 'Saving...',
                type: 'info'
              });
              await saveAdmin(connection, wallet, newStore.public, Object.values(updatedCreators));
              (0,lib.notify)({
                message: 'Saved',
                type: 'success'
              });
            },
            type: "primary",
            children: "Submit"
          })]
        }), /*#__PURE__*/jsx_runtime_.jsx(external_antd_.Col, {
          span: 3,
          children: /*#__PURE__*/jsx_runtime_.jsx(external_antd_.Switch, {
            checkedChildren: "Public",
            unCheckedChildren: "Whitelist Only",
            checked: newStore.public,
            onChange: val => {
              setNewStore(() => {
                const newS = new metaplex.Store(store.info);
                newS.public = val;
                return newS;
              });
            }
          })
        })]
      }), /*#__PURE__*/jsx_runtime_.jsx(external_antd_.Row, {
        children: /*#__PURE__*/jsx_runtime_.jsx(external_antd_.Table, {
          className: "artist-whitelist-table",
          columns: columns,
          dataSource: Object.keys(uniqueCreatorsWithUpdates).map(key => ({
            key,
            address: uniqueCreatorsWithUpdates[key].address,
            activated: uniqueCreatorsWithUpdates[key].activated,
            name: uniqueCreatorsWithUpdates[key].name || (0,lib.shortenAddress)(uniqueCreatorsWithUpdates[key].address),
            image: uniqueCreatorsWithUpdates[key].image
          }))
        })
      })]
    }), !store.info.public && /*#__PURE__*/(0,jsx_runtime_.jsxs)(jsx_runtime_.Fragment, {
      children: [/*#__PURE__*/(0,jsx_runtime_.jsxs)("h1", {
        children: ["You have ", filteredMetadata === null || filteredMetadata === void 0 ? void 0 : filteredMetadata.available.length, " MasterEditionV1s that can be converted right now and", ' ', filteredMetadata === null || filteredMetadata === void 0 ? void 0 : filteredMetadata.unavailable.length, " still in unfinished auctions that cannot be converted yet."]
      }), /*#__PURE__*/jsx_runtime_.jsx(external_antd_.Col, {
        children: /*#__PURE__*/jsx_runtime_.jsx(external_antd_.Row, {
          children: /*#__PURE__*/jsx_runtime_.jsx(external_antd_.Button, {
            disabled: loading,
            onClick: async () => {
              setLoading(true);
              await convertMasterEditions(connection, wallet, (filteredMetadata === null || filteredMetadata === void 0 ? void 0 : filteredMetadata.available) || [], accountByMint);
              setLoading(false);
            },
            children: loading ? /*#__PURE__*/jsx_runtime_.jsx(external_antd_.Spin, {}) : /*#__PURE__*/jsx_runtime_.jsx("span", {
              children: "Convert Eligible Master Editions"
            })
          })
        })
      }), ' ']
    }), /*#__PURE__*/(0,jsx_runtime_.jsxs)(external_antd_.Col, {
      children: [/*#__PURE__*/jsx_runtime_.jsx("p", {
        style: {
          'marginTop': '30px'
        },
        children: "Upgrade the performance of your existing auctions."
      }), /*#__PURE__*/jsx_runtime_.jsx(external_antd_.Row, {
        children: /*#__PURE__*/jsx_runtime_.jsx(external_antd_.Button, {
          disabled: loading,
          onClick: async () => {
            setLoading(true);
            await cacheAllAuctions(wallet, connection, state);
            setLoading(false);
          },
          children: loading ? /*#__PURE__*/jsx_runtime_.jsx(external_antd_.Spin, {}) : /*#__PURE__*/jsx_runtime_.jsx("span", {
            children: "Upgrade Auction Performance"
          })
        })
      })]
    })]
  });
}
;// CONCATENATED MODULE: ./src/views/pack/components/RedeemModal/components/RedeemCard/index.tsx








const RedeemCard = ({
  item: {
    info,
    pubkey
  },
  probability
}) => {
  const {
    creators
  } = useArt(pubkey);
  return /*#__PURE__*/(0,jsx_runtime_.jsxs)("div", {
    className: "card-redeem",
    children: [/*#__PURE__*/(0,jsx_runtime_.jsxs)("div", {
      className: "info",
      children: [/*#__PURE__*/jsx_runtime_.jsx("div", {
        className: "card-redeem__image",
        children: /*#__PURE__*/jsx_runtime_.jsx(ArtContent, {
          pubkey: pubkey,
          uri: info.data.uri,
          preview: false
        })
      }), /*#__PURE__*/(0,jsx_runtime_.jsxs)("div", {
        className: "info__text",
        children: [/*#__PURE__*/jsx_runtime_.jsx(external_antd_.Tooltip, {
          title: info.data.name,
          children: /*#__PURE__*/jsx_runtime_.jsx("p", {
            className: "info__title",
            children: info.data.name
          })
        }), /*#__PURE__*/jsx_runtime_.jsx(external_antd_.Tooltip, {
          title: creators === null || creators === void 0 ? void 0 : creators.map(creator => ' ' + (creator.name || (0,lib.shortenAddress)(creator.address || ''))),
          children: /*#__PURE__*/jsx_runtime_.jsx("p", {
            className: "info__creators",
            children: creators === null || creators === void 0 ? void 0 : creators.map(creator => ' ' + (creator.name || (0,lib.shortenAddress)(creator.address || '')))
          })
        })]
      })]
    }), /*#__PURE__*/(0,jsx_runtime_.jsxs)("div", {
      className: "card-redeem__percentage",
      children: [/*#__PURE__*/jsx_runtime_.jsx("p", {
        className: "percentage-desktop",
        children: `${probability}% chance`
      }), /*#__PURE__*/jsx_runtime_.jsx("p", {
        className: "percentage-mobile",
        children: `${probability}%`
      })]
    })]
  });
};

/* harmony default export */ const components_RedeemCard = (RedeemCard);
;// CONCATENATED MODULE: ./src/components/SmallLoader/index.tsx




const SmallLoader = () => {
  return /*#__PURE__*/jsx_runtime_.jsx("div", {
    className: "small-loader",
    children: /*#__PURE__*/(0,jsx_runtime_.jsxs)("svg", {
      width: "24",
      height: "24",
      viewBox: "0 0 24 24",
      fill: "none",
      xmlns: "http://www.w3.org/2000/svg",
      children: [/*#__PURE__*/jsx_runtime_.jsx("path", {
        fillRule: "evenodd",
        clipRule: "evenodd",
        d: "M24 12C24 18.6274 18.6274 24 12 24C5.37258 24 0 18.6274 0 12C0 5.37258 5.37258 0 12 0V2.63719C11.9547 2.63655 11.9093 2.63623 11.8638 2.63623C6.61706 2.63623 2.36377 6.88952 2.36377 12.1362C2.36377 17.3829 6.61706 21.6362 11.8638 21.6362C17.1105 21.6362 21.3638 17.3829 21.3638 12.1362C21.3638 12.0907 21.3634 12.0453 21.3628 12H24Z",
        fill: "url(#paint0_angular_379_3911)"
      }), /*#__PURE__*/jsx_runtime_.jsx("defs", {
        children: /*#__PURE__*/(0,jsx_runtime_.jsxs)("radialGradient", {
          id: "paint0_angular_379_3911",
          cx: "0",
          cy: "0",
          r: "1",
          gradientUnits: "userSpaceOnUse",
          gradientTransform: "translate(12 12) rotate(-90) scale(12)",
          children: [/*#__PURE__*/jsx_runtime_.jsx("stop", {
            offset: "0.237284",
            stopColor: "white",
            stopOpacity: "0"
          }), /*#__PURE__*/jsx_runtime_.jsx("stop", {
            offset: "0.5",
            stopColor: "white"
          }), /*#__PURE__*/jsx_runtime_.jsx("stop", {
            offset: "1",
            stopColor: "white"
          })]
        })
      })]
    })
  });
};

/* harmony default export */ const components_SmallLoader = (SmallLoader);
;// CONCATENATED MODULE: ./src/views/pack/components/RedeemModal/components/InitialStep/index.tsx







const InitialStep = ({
  numberOfNFTs,
  numberOfAttempts,
  metadataByPackCard,
  creators,
  isLoadingMetadata,
  onClose
}) => /*#__PURE__*/(0,jsx_runtime_.jsxs)("div", {
  children: [/*#__PURE__*/(0,jsx_runtime_.jsxs)("div", {
    className: "modal-redeem__title-container",
    children: [/*#__PURE__*/jsx_runtime_.jsx("p", {
      className: "title",
      children: "Claiming Pack Cards"
    }), /*#__PURE__*/(0,jsx_runtime_.jsxs)("p", {
      className: "title",
      children: [/*#__PURE__*/jsx_runtime_.jsx(icons_.ArrowLeftOutlined, {
        onClick: onClose,
        className: "arrow-back"
      }), "Claim Pack Cards"]
    })]
  }), /*#__PURE__*/(0,jsx_runtime_.jsxs)("div", {
    className: "modal-redeem__body",
    children: [/*#__PURE__*/(0,jsx_runtime_.jsxs)("p", {
      className: "body-title",
      children: ["Pack of ", numberOfNFTs]
    }), /*#__PURE__*/(0,jsx_runtime_.jsxs)("p", {
      className: "body-desc",
      children: ["Your Pack from ", creators.join(', '), " grants you ", numberOfAttempts, ' ', "chances to own any of the following Cards."]
    }), /*#__PURE__*/(0,jsx_runtime_.jsxs)("div", {
      className: "modal-redeem__cards",
      children: [/*#__PURE__*/jsx_runtime_.jsx("p", {
        children: "POTENTIAL NFTs"
      }), isLoadingMetadata && /*#__PURE__*/jsx_runtime_.jsx(components_SmallLoader, {}), !isLoadingMetadata && metadataByPackCard && Object.values(metadataByPackCard).map(item => item && /*#__PURE__*/jsx_runtime_.jsx(components_RedeemCard, {
        item: item,
        probability: item.probability
      }, item.pubkey))]
    })]
  })]
});

/* harmony default export */ const components_InitialStep = (InitialStep);
;// CONCATENATED MODULE: ./src/views/pack/components/RedeemModal/components/TransactionApprovalStep/index.tsx




const transactions = ['Opening your Pack.', 'Begin adding new Cards to your wallet.'];

const TransactionApprovalStep = ({
  goBack
}) => /*#__PURE__*/(0,jsx_runtime_.jsxs)("div", {
  children: [/*#__PURE__*/(0,jsx_runtime_.jsxs)("div", {
    className: "modal-redeem__title-container",
    children: [/*#__PURE__*/jsx_runtime_.jsx(icons_.ArrowLeftOutlined, {
      onClick: goBack,
      className: "arrow-back"
    }), /*#__PURE__*/jsx_runtime_.jsx("span", {
      className: "text",
      children: "Wallet Transaction Approvals"
    })]
  }), /*#__PURE__*/(0,jsx_runtime_.jsxs)("div", {
    className: "modal-redeem__body",
    children: [/*#__PURE__*/jsx_runtime_.jsx("span", {
      className: "body-big-title",
      children: "Safe and secure."
    }), /*#__PURE__*/jsx_runtime_.jsx("span", {
      className: "body-big-desc",
      children: "Your wallet will ask you to approve two transactions."
    }), /*#__PURE__*/jsx_runtime_.jsx("div", {
      className: "transaction-cards",
      children: transactions.map((item, idx) => /*#__PURE__*/(0,jsx_runtime_.jsxs)("div", {
        className: "transaction-card",
        children: [/*#__PURE__*/jsx_runtime_.jsx("div", {
          className: "number-frame",
          children: idx + 1
        }), /*#__PURE__*/jsx_runtime_.jsx("div", {
          className: "transaction-desc",
          children: item
        })]
      }, item))
    })]
  })]
});

/* harmony default export */ const components_TransactionApprovalStep = (TransactionApprovalStep);
// EXTERNAL MODULE: external "react-router"
var external_react_router_ = __webpack_require__(8374);
;// CONCATENATED MODULE: ./src/views/pack/transactions/getNewMint.ts
function getNewMint_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

function getNewMint_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { getNewMint_ownKeys(Object(source), true).forEach(function (key) { getNewMint_defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { getNewMint_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function getNewMint_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }



async function getNewMint(wallet, connection) {
  const instructions = [];
  const signers = [];

  if (!wallet.publicKey) {
    throw new Error('Wallet pubKey is not provided');
  }

  const mintRentExempt = await connection.getMinimumBalanceForRentExemption(spl_token_.MintLayout.span);
  const newMint = await createMintAndAccountWithOne(wallet, wallet.publicKey.toString(), mintRentExempt, instructions, signers);
  return getNewMint_objectSpread(getNewMint_objectSpread({}, newMint), {}, {
    instructions,
    signers
  });
}
;// CONCATENATED MODULE: ./src/views/pack/transactions/claimPackCards.ts
const claimPackCards_excluded = ["connection", "wallet"],
      _excluded2 = ["cardsToRedeem"];

function claimPackCards_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

function claimPackCards_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { claimPackCards_ownKeys(Object(source), true).forEach(function (key) { claimPackCards_defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { claimPackCards_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function claimPackCards_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function claimPackCards_objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = claimPackCards_objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }

function claimPackCards_objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }





const claimPackCards = async _ref => {
  let {
    connection,
    wallet
  } = _ref,
      params = claimPackCards_objectWithoutProperties(_ref, claimPackCards_excluded);

  const instructions = await getClaimPackCardsInstructions(claimPackCards_objectSpread({
    connection,
    wallet
  }, params));
  const flatInstructions = instructions.flat();
  await (0,lib.sendTransactionsInChunks)(connection, wallet, flatInstructions.map(({
    instructions
  }) => instructions), flatInstructions.map(({
    signers
  }) => signers), lib.SequenceType.Sequential, 'singleGossip', 120000, 20);
};

const getClaimPackCardsInstructions = async _ref2 => {
  let {
    cardsToRedeem
  } = _ref2,
      params = claimPackCards_objectWithoutProperties(_ref2, _excluded2);

  return Promise.all(Array.from(cardsToRedeem.entries(), ([index, numberOfCards]) => claimSeveralCardsByIndex(claimPackCards_objectSpread({
    numberOfCards,
    index
  }, params))));
};

const claimSeveralCardsByIndex = async ({
  wallet,
  connection,
  pack,
  numberOfCards,
  voucherMint,
  index,
  metadataByPackCard,
  packCards,
  masterEditions
}) => {
  var _packCards$packCardTo, _packCards$packCardTo2, _packCardMetadata$inf;

  const packSetKey = pack.pubkey;
  const randomOracle = pack.info.randomOracle;
  const packCardToRedeem = await (0,lib.findPackCardProgramAddress)((0,lib.toPublicKey)(packSetKey), index);
  const packCardMetadata = metadataByPackCard[packCardToRedeem];
  const userToken = (_packCards$packCardTo = packCards[packCardToRedeem]) === null || _packCards$packCardTo === void 0 ? void 0 : (_packCards$packCardTo2 = _packCards$packCardTo.info) === null || _packCards$packCardTo2 === void 0 ? void 0 : _packCards$packCardTo2.tokenAccount;

  if (!(packCardMetadata !== null && packCardMetadata !== void 0 && (_packCardMetadata$inf = packCardMetadata.info) !== null && _packCardMetadata$inf !== void 0 && _packCardMetadata$inf.masterEdition)) {
    throw new Error('Missing master edition');
  }

  if (!userToken) {
    throw new Error('Missing user token');
  }

  const packCardEdition = masterEditions[packCardMetadata.info.masterEdition];
  return Promise.all(Array.from({
    length: numberOfCards
  }).map((_, i) => {
    const packCardEditionIndex = packCardEdition.info.supply.toNumber() + i + 1;
    return generateClaimPackInstructions({
      wallet,
      connection,
      index,
      packSetKey,
      randomOracle,
      userToken,
      voucherMint,
      metadataMint: packCardMetadata.info.mint,
      edition: new external_bn_js_.BN(packCardEditionIndex)
    });
  }));
};

const generateClaimPackInstructions = async ({
  wallet,
  connection,
  index,
  packSetKey,
  randomOracle,
  userToken,
  voucherMint,
  metadataMint,
  edition
}) => {
  if (!wallet.publicKey) throw new wallet_adapter_base_.WalletNotConnectedError();
  const walletPublicKey = wallet.publicKey;
  const {
    mint: newMint,
    instructions: newMintInstructions,
    signers: newMintSigners
  } = await getNewMint(wallet, connection);
  const claimPackInstruction = await (0,lib.claimPack)({
    index,
    packSetKey,
    wallet: walletPublicKey,
    userToken,
    voucherMint,
    newMint,
    metadataMint,
    edition,
    randomOracle
  });
  return {
    instructions: [...newMintInstructions, claimPackInstruction],
    signers: newMintSigners
  };
};
;// CONCATENATED MODULE: ./src/views/pack/transactions/requestCards.ts
const requestCards_excluded = ["cardsLeftToOpen", "tokenAccount"],
      requestCards_excluded2 = ["index", "packSetKey", "wallet"];

function requestCards_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

function requestCards_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { requestCards_ownKeys(Object(source), true).forEach(function (key) { requestCards_defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { requestCards_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function requestCards_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function requestCards_objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = requestCards_objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }

function requestCards_objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }



const REQUEST_CARDS_CHUNK_SIZE = 46;
const requestCards = async ({
  pack,
  tokenAccount,
  connection,
  wallet,
  cardsLeftToOpen,
  voucherKey,
  editionKey,
  editionMint
}) => {
  if (!wallet.publicKey) throw new wallet_adapter_base_.WalletNotConnectedError();
  const requestCardsInstructions = await getRequestCardsInstructions({
    cardsLeftToOpen,
    editionKey,
    editionMint,
    tokenAccount,
    voucherKey,
    wallet,
    packSetKey: pack.pubkey,
    randomOracle: pack.info.randomOracle
  });
  const requestCardsInstructionsChunks = (0,lib.chunks)(requestCardsInstructions.flat(), REQUEST_CARDS_CHUNK_SIZE);
  const requestCardsInstructionsSigners = requestCardsInstructionsChunks.map(() => []);
  return (0,lib.sendTransactionsWithRecentBlock)(connection, wallet, requestCardsInstructionsChunks, requestCardsInstructionsSigners);
};

const getRequestCardsInstructions = async _ref => {
  let {
    cardsLeftToOpen,
    tokenAccount
  } = _ref,
      params = requestCards_objectWithoutProperties(_ref, requestCards_excluded);

  const addCardsToPack = Array.from({
    length: cardsLeftToOpen
  }).map((_, index) => generateRequestCardInstructions(requestCards_objectSpread(requestCards_objectSpread({
    index: 1
  }, params), index === 0 ? {
    tokenAccount
  } : {})));
  return Promise.all(addCardsToPack);
};

const generateRequestCardInstructions = async _ref2 => {
  let {
    index,
    packSetKey,
    wallet
  } = _ref2,
      params = requestCards_objectWithoutProperties(_ref2, requestCards_excluded2);

  if (!wallet.publicKey) throw new wallet_adapter_base_.WalletNotConnectedError();
  const cleanUpInstruction = await (0,lib.cleanUp)((0,lib.toPublicKey)(packSetKey));
  const claimPackInstruction = await (0,lib.requestCardToRedeem)(requestCards_objectSpread({
    index,
    packSetKey: (0,lib.toPublicKey)(packSetKey),
    wallet: wallet.publicKey
  }, params));
  return [cleanUpInstruction, claimPackInstruction];
};
// EXTERNAL MODULE: ../common/dist/lib/models/packs/accounts/ProvingProcess.js
var ProvingProcess = __webpack_require__(9437);
;// CONCATENATED MODULE: ./src/views/pack/contexts/utils/fetchProvingProcessWithRetry.ts


const SLEEP_TIMEOUT = 300;
const REQUEST_TIMEOUT = 15000;
const fetchProvingProcessWithRetry = async ({
  provingProcessKey,
  connection
}) => {
  let provingProcess;
  const startTime = (0,lib.getUnixTs)();

  while (!provingProcess && (0,lib.getUnixTs)() - startTime < REQUEST_TIMEOUT) {
    try {
      provingProcess = await (0,ProvingProcess.getProvingProcessByPubkey)(connection, provingProcessKey);
    } catch {// skip
    }

    await (0,lib.sleep)(SLEEP_TIMEOUT);
  }

  return provingProcess;
};
;// CONCATENATED MODULE: ./src/views/pack/contexts/utils/getProvingProcess.ts




const getProvingProcess = async ({
  pack,
  provingProcess,
  voucherMint,
  vouchers,
  accountByMint,
  connection,
  wallet
}) => {
  let editionMint;

  if (provingProcess) {
    editionMint = provingProcess.info.voucherMint;
  } else if (voucherMint) {
    editionMint = voucherMint;
  } else {
    throw new Error('No voucher and proving process');
  }

  const editionKey = await (0,lib.getEdition)(editionMint);
  const editionData = await connection.getAccountInfo((0,lib.toPublicKey)(editionKey));

  if (!editionData) {
    throw new Error('No edition for voucher mint');
  }

  const edition = (0,lib.decodeEdition)(editionData.data);
  const voucher = Object.values(vouchers).find(({
    info
  }) => info.master === edition.parent);

  if (!voucher) {
    throw new Error('Voucher is missing');
  }

  const voucherKey = voucher.pubkey;
  const voucherTokenAccount = accountByMint.get(editionMint); // Calculate already requested but not redeemed cards by summing values in cardsToRedeem

  const alreadyRequestedCards = provingProcess !== null && provingProcess !== void 0 && provingProcess.info.cardsToRedeem ? Object.values(Object.fromEntries(provingProcess.info.cardsToRedeem)).reduce((a, b) => a + b) : 0;
  const redeemedCards = (provingProcess === null || provingProcess === void 0 ? void 0 : provingProcess.info.cardsRedeemed) || 0;
  const cardsLeftToOpen = pack.info.allowedAmountToRedeem - redeemedCards - alreadyRequestedCards;

  if (cardsLeftToOpen === 0 && provingProcess) {
    return provingProcess;
  }

  return requestCardsUsingVoucher({
    pack,
    cardsLeftToOpen,
    voucherTokenAccount,
    voucherKey,
    editionKey,
    editionMint,
    connection,
    wallet
  });
};

const requestCardsUsingVoucher = async ({
  pack,
  cardsLeftToOpen,
  voucherTokenAccount,
  voucherKey,
  editionKey,
  editionMint,
  connection,
  wallet
}) => {
  if (!wallet.publicKey) {
    throw new wallet_adapter_base_.WalletNotConnectedError();
  }

  await requestCards({
    pack,
    voucherKey,
    editionKey,
    editionMint,
    connection,
    wallet,
    cardsLeftToOpen,
    tokenAccount: voucherTokenAccount === null || voucherTokenAccount === void 0 ? void 0 : voucherTokenAccount.pubkey
  });
  const provingProcessKey = await (0,lib.findProvingProcessProgramAddress)((0,lib.toPublicKey)(pack.pubkey), (0,lib.toPublicKey)(wallet.publicKey), (0,lib.toPublicKey)(editionMint));
  return fetchProvingProcessWithRetry({
    provingProcessKey,
    connection
  });
};
;// CONCATENATED MODULE: ./src/views/pack/contexts/utils/getMetadataUserToReceive.ts

// Returns metadata that user should receive as a result of pack opening
const getMetadataUserToReceive = async ({
  cardsToRedeem,
  metadataByPackCard,
  packPubKey
}) => {
  const metadataUserToReceive = [];

  for (const [index, numberToRedeem] of cardsToRedeem.entries()) {
    const packCard = await (0,lib.findPackCardProgramAddress)((0,lib.toPublicKey)(packPubKey), index);
    const metadataByCard = metadataByPackCard[packCard];

    for (let i = 0; i < numberToRedeem; i++) {
      metadataUserToReceive.push(metadataByCard.pubkey);
    }
  }

  return metadataUserToReceive;
};
;// CONCATENATED MODULE: ./src/views/pack/contexts/utils/getInitialProvingProcess.ts
// Returns proving process depending on which parameter from URL to use: provingProcessKey or voucherMetadataKey
const getInitialProvingProcess = ({
  provingProcesses,
  provingProcessKey,
  voucherMetadata
}) => {
  if (provingProcessKey) {
    return provingProcesses[provingProcessKey];
  }

  const provingProcessByVoucher = Object.values(provingProcesses).find(({
    info
  }) => info.voucherMint === (voucherMetadata === null || voucherMetadata === void 0 ? void 0 : voucherMetadata.info.mint));

  if (provingProcessByVoucher) {
    return provingProcessByVoucher;
  }

  return null;
};
;// CONCATENATED MODULE: ./src/views/pack/contexts/hooks/useMetadataByPackCard.ts
function useMetadataByPackCard_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

function useMetadataByPackCard_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { useMetadataByPackCard_ownKeys(Object(source), true).forEach(function (key) { useMetadataByPackCard_defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { useMetadataByPackCard_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function useMetadataByPackCard_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }



const useMetadataByPackCard = packId => {
  var _packs$packId;

  const {
    packCardsByPackSet,
    metadataByMasterEdition,
    packs
  } = (0,lib.useMeta)();
  const {
    distributionType = lib.PackDistributionType.MaxSupply,
    totalEditions = new external_bn_js_.BN(0),
    totalWeight = new external_bn_js_.BN(0)
  } = ((_packs$packId = packs[packId]) === null || _packs$packId === void 0 ? void 0 : _packs$packId.info) || {};
  const isMaxSupplyDistribution = distributionType === lib.PackDistributionType.MaxSupply;
  const total = isMaxSupplyDistribution ? totalEditions : totalWeight;
  const cards = packCardsByPackSet[packId];
  const metadata = cards === null || cards === void 0 ? void 0 : cards.reduce((packMetadata, {
    info,
    pubkey
  }) => {
    const probCount = isMaxSupplyDistribution ? info.maxSupply : info.weight;
    const probability = calculateProbability(probCount, total.toNumber()).toFixed(1);

    if (!metadataByMasterEdition[info.master]) {
      return packMetadata;
    }

    packMetadata[pubkey] = useMetadataByPackCard_objectSpread(useMetadataByPackCard_objectSpread({}, metadataByMasterEdition[info.master]), {}, {
      probability
    });
    return packMetadata;
  }, {});
  return metadata;
};

function calculateProbability(count, total) {
  if (total === 0) {
    return 0;
  }

  return count * 100 / total;
}
;// CONCATENATED MODULE: ./src/views/pack/contexts/hooks/useOpenedMetadata.ts

 // Here we check if user has NFTs that could be received from pack opening
// Opened cards may shuffle between user's packs that have the same PackSet key,
// Since we don't store a ProvingProcess from what an NFT was received

const useOpenedMetadata = (packKey, maxLength) => {
  const {
    packCardsByPackSet
  } = (0,lib.useMeta)();
  const ownedMetadata = useUserArts();
  const packCards = packCardsByPackSet[packKey];
  const metadata = ownedMetadata.reduce((acc, value) => {
    var _value$edition;

    const parent = (_value$edition = value.edition) === null || _value$edition === void 0 ? void 0 : _value$edition.info.parent;

    if (parent && acc.length < maxLength) {
      const metadataExistsInPack = packCards === null || packCards === void 0 ? void 0 : packCards.some(({
        info
      }) => info.master === parent);

      if (metadataExistsInPack) {
        acc.push(value);
      }
    }

    return acc;
  }, []);
  return metadata;
};
;// CONCATENATED MODULE: ./src/hooks/useInterval.ts


function useInterval(callback, delay) {
  const savedCallback = (0,external_react_.useRef)(callback); // Remember the latest callback if it changes.

  (0,external_react_.useLayoutEffect)(() => {
    savedCallback.current = callback;
  }, [callback]); // Set up the interval.

  (0,external_react_.useEffect)(() => {
    // Don't schedule if no delay is specified.
    // Note: 0 is a valid value for delay.
    if (!delay && delay !== 0) {
      return;
    }

    const id = setInterval(() => savedCallback.current(), delay);
    return () => clearInterval(id);
  }, [delay]);
}

/* harmony default export */ const hooks_useInterval = (useInterval);
;// CONCATENATED MODULE: ./src/views/pack/contexts/hooks/useListenForProvingProcess.ts




const INTERVAL = 2000;
const useListenForProvingProcess = (shouldListen, provingProcessKey) => {
  const {
    0: provingProcess,
    1: setProvingProcess
  } = (0,external_react_.useState)();
  const {
    0: isLoadingProvingProcess,
    1: setIsLoadingProvingProcess
  } = (0,external_react_.useState)(false);
  const connection = (0,lib.useConnection)();

  const fetchProvingProcess = async () => {
    if (isLoadingProvingProcess || !provingProcessKey) {
      return;
    }

    setIsLoadingProvingProcess(true);
    const newProvingProcess = await fetchProvingProcessWithRetry({
      provingProcessKey: provingProcessKey,
      connection
    });
    setProvingProcess(newProvingProcess);
    setIsLoadingProvingProcess(false);
  };

  hooks_useInterval(() => {
    fetchProvingProcess();
  }, shouldListen ? INTERVAL : null);
  return provingProcess;
};
;// CONCATENATED MODULE: ./src/views/pack/contexts/PackContext.tsx













const PackContext = /*#__PURE__*/external_react_default().createContext({
  isLoading: false,
  packKey: '',
  voucherMint: '',
  openedMetadata: [],
  metadataByPackCard: {},
  handleOpenPack: () => Promise.resolve(),
  redeemModalMetadata: []
});
const PackProvider = ({
  children
}) => {
  var _provingProcess$info, _voucher$info2;

  const wallet = (0,wallet_adapter_react_.useWallet)();
  const connection = (0,lib.useConnection)();
  const {
    packKey
  } = (0,external_react_router_.useParams)();
  const {
    search
  } = (0,external_react_router_.useLocation)();
  const {
    voucherMint,
    provingProcessKey
  } = (0,lib.getSearchParams)(search);
  const {
    packs,
    packCards,
    masterEditions,
    metadata,
    pullPackPage,
    provingProcesses,
    vouchers,
    isFetching
  } = (0,lib.useMeta)();
  const {
    accountByMint,
    userAccounts
  } = (0,lib.useUserAccounts)();
  const metadataByPackCard = useMetadataByPackCard(packKey);
  const {
    0: isLoading,
    1: setIsLoading
  } = (0,external_react_.useState)(false);
  const {
    0: isPollingProvingProcess,
    1: setIsPollingProvingProcess
  } = (0,external_react_.useState)(false);
  const {
    0: provingProcess,
    1: setProvingProcess
  } = (0,external_react_.useState)();
  const {
    0: redeemModalMetadata,
    1: setRedeemModalMetadata
  } = (0,external_react_.useState)([]);
  const voucherMetadata = metadata.find(meta => {
    var _meta$info;

    return (meta === null || meta === void 0 ? void 0 : (_meta$info = meta.info) === null || _meta$info === void 0 ? void 0 : _meta$info.mint) === voucherMint;
  });
  const voucher = Object.values(vouchers).find(voucher => {
    var _voucher$info;

    return (voucher === null || voucher === void 0 ? void 0 : (_voucher$info = voucher.info) === null || _voucher$info === void 0 ? void 0 : _voucher$info.packSet) === packKey;
  });
  const cardsRedeemed = (provingProcess === null || provingProcess === void 0 ? void 0 : (_provingProcess$info = provingProcess.info) === null || _provingProcess$info === void 0 ? void 0 : _provingProcess$info.cardsRedeemed) || 0;
  const pack = packs[packKey];
  const voucherMetadataKey = (voucherMetadata === null || voucherMetadata === void 0 ? void 0 : voucherMetadata.pubkey) || (voucher === null || voucher === void 0 ? void 0 : (_voucher$info2 = voucher.info) === null || _voucher$info2 === void 0 ? void 0 : _voucher$info2.metadata);
  const openedMetadata = useOpenedMetadata(packKey, cardsRedeemed); // Listens for updates on proving process while pack is being opened

  const updatedProvingProcess = useListenForProvingProcess(isPollingProvingProcess, provingProcess === null || provingProcess === void 0 ? void 0 : provingProcess.pubkey);

  const handleOpenPack = async () => {
    const newProvingProcess = await getProvingProcess({
      pack,
      provingProcess,
      voucherMint,
      vouchers,
      accountByMint,
      connection,
      wallet
    });
    setProvingProcess(newProvingProcess);
    const {
      info: {
        cardsToRedeem
      },
      pubkey
    } = newProvingProcess;
    const metadataUserToReceive = await getMetadataUserToReceive({
      cardsToRedeem,
      metadataByPackCard,
      packPubKey: pack.pubkey
    });
    setRedeemModalMetadata(metadataUserToReceive); // Starts proving process polling

    setIsPollingProvingProcess(true);
    await claimPackCards({
      wallet,
      connection,
      voucherMint: newProvingProcess.info.voucherMint,
      cardsToRedeem,
      metadataByPackCard,
      packCards,
      masterEditions,
      pack
    });
    setIsPollingProvingProcess(false); // Fetch final proving process state
    // Because polling can be terminated too soon

    const resultingProvingProcess = await fetchProvingProcessWithRetry({
      provingProcessKey: pubkey,
      connection
    });
    setProvingProcess(resultingProvingProcess);
  };

  const handleFetch = async () => {
    setIsLoading(true);
    setRedeemModalMetadata([]);
    await pullPackPage(userAccounts, packKey);
    const initialProvingProcess = getInitialProvingProcess({
      provingProcesses,
      provingProcessKey,
      voucherMetadata
    });

    if (initialProvingProcess) {
      setProvingProcess(initialProvingProcess);
    } else {
      setProvingProcess(undefined);
    }

    setIsLoading(false);
  };

  (0,external_react_.useEffect)(() => {
    setProvingProcess(updatedProvingProcess);
  }, [updatedProvingProcess]);
  (0,external_react_.useEffect)(() => {
    if (!isFetching) {
      handleFetch();
    }
  }, [isFetching]);
  return /*#__PURE__*/jsx_runtime_.jsx(PackContext.Provider, {
    value: {
      isLoading,
      packKey,
      voucherMint,
      voucherMetadataKey,
      openedMetadata,
      pack,
      metadataByPackCard,
      handleOpenPack,
      redeemModalMetadata,
      provingProcess
    },
    children: children
  });
};
const usePack = () => {
  const context = (0,external_react_.useContext)(PackContext);

  if (context === undefined) {
    throw new Error('usePack must be used within a PackProvider');
  }

  return context;
};
// EXTERNAL MODULE: external "react-transition-group"
var external_react_transition_group_ = __webpack_require__(3810);
;// CONCATENATED MODULE: ./src/views/pack/components/RedeemModal/components/ClaimingStep/constants.ts
const CARDS_DISTANCE = 16;
const INFO_MESSAGES = ['You may also have to approve the purchase in your wallet if you don’t have “auto-approve” turned on.', 'Cards are randomly distributed to ensure an equal chance to receive any card. It may take up to a few seconds to fetch each Card.'];
;// CONCATENATED MODULE: ./src/views/pack/components/RedeemModal/components/ClaimingStep/components/GhostCard/index.tsx



const GHOST_CARD_WIDTH = 308;
const WIDTH_DIFF = 46;

const GhostCard = ({
  index
}) => {
  const stylesGhostCard = (0,external_react_.useMemo)(() => {
    return {
      height: `${GHOST_CARD_WIDTH - index * WIDTH_DIFF}px`,
      width: `${GHOST_CARD_WIDTH - index * WIDTH_DIFF}px`,
      top: `calc(100% - ${(index + 1) * CARDS_DISTANCE}px)`
    };
  }, [index]);
  return /*#__PURE__*/jsx_runtime_.jsx("div", {
    className: "claiming-step__card",
    style: stylesGhostCard
  });
};

/* harmony default export */ const components_GhostCard = (GhostCard);
;// CONCATENATED MODULE: ./src/views/pack/components/RedeemModal/components/ClaimingStep/hooks/useGhostCards.ts


const DEFAULT_GHOST_CARDS_NUMBER = 3;
const useGhostCards = currentCardIndex => {
  const {
    pack
  } = usePack();
  const {
    allowedAmountToRedeem = 0
  } = (pack === null || pack === void 0 ? void 0 : pack.info) || {};
  const cardsLeftToOpen = Math.max(allowedAmountToRedeem - currentCardIndex - 1, 0);
  const arraySize = Math.min(cardsLeftToOpen, DEFAULT_GHOST_CARDS_NUMBER);
  return (0,external_react_.useMemo)(() => Array.from({
    length: arraySize
  }), [arraySize]);
};
;// CONCATENATED MODULE: ./src/views/pack/components/RedeemModal/components/ClaimingStep/index.tsx














// Delay between switching cards on the slider
const DELAY_BETWEEN_CARDS_CHANGE = 4000;

const ClaimingStep = ({
  onClose
}) => {
  const {
    0: currentCardIndex,
    1: setCurrentCardIndex
  } = (0,external_react_.useState)(-1);
  const {
    pack,
    voucherMetadataKey,
    provingProcess,
    redeemModalMetadata
  } = usePack();
  const {
    whitelistedCreatorsByCreator
  } = (0,lib.useMeta)();
  const ghostCards = useGhostCards(currentCardIndex);
  const {
    name = '',
    authority = ''
  } = (pack === null || pack === void 0 ? void 0 : pack.info) || {};
  const {
    cardsRedeemed = 0,
    isExhausted = false
  } = (provingProcess === null || provingProcess === void 0 ? void 0 : provingProcess.info) || {};
  const creator = (0,external_react_.useMemo)(() => getCreator(whitelistedCreatorsByCreator, authority), [whitelistedCreatorsByCreator, authority]);
  const isClaiming = currentCardIndex < cardsRedeemed - 1 || !isExhausted;
  const currentMetadataToShow = currentCardIndex >= 0 ? redeemModalMetadata[currentCardIndex] : voucherMetadataKey;
  const titleText = isClaiming ? name : 'You Opened the Pack!';
  const subtitleText = isClaiming ? `From ${creator.name || (0,lib.shortenAddress)(creator.address || '')}` : `${cardsRedeemed} new Cards were added to your wallet`;
  const footerText = isClaiming ? `Retrieving ${currentCardIndex === -1 ? 'first' : 'next'} Card...` : 'Pack Opening Succesful!';
  const infoMessageText = currentCardIndex === -1 ? INFO_MESSAGES[0] : INFO_MESSAGES[1];
  hooks_useInterval(() => {
    // Checking if can proceed with showing the next card
    if (currentCardIndex + 1 < cardsRedeemed) {
      // Select the next card to show
      setCurrentCardIndex(currentCardIndex + 1);
    }
  }, // Delay in milliseconds or null to stop it
  isClaiming ? DELAY_BETWEEN_CARDS_CHANGE : null);
  return /*#__PURE__*/(0,jsx_runtime_.jsxs)("div", {
    className: "claiming-step",
    children: [/*#__PURE__*/jsx_runtime_.jsx("span", {
      className: "claiming-step__title",
      children: titleText
    }), /*#__PURE__*/jsx_runtime_.jsx("span", {
      className: "claiming-step__subtitle",
      children: subtitleText
    }), /*#__PURE__*/(0,jsx_runtime_.jsxs)("div", {
      className: "claiming-step__cards-container",
      children: [/*#__PURE__*/jsx_runtime_.jsx("div", {
        style: {
          height: `${CARDS_DISTANCE * ghostCards.length}px`
        },
        className: "claiming-step__ghost-cards",
        children: ghostCards.map((_, index) => /*#__PURE__*/jsx_runtime_.jsx(components_GhostCard, {
          index: index
        }, index))
      }), /*#__PURE__*/jsx_runtime_.jsx("div", {
        className: "current-card-container",
        children: /*#__PURE__*/jsx_runtime_.jsx(external_react_transition_group_.SwitchTransition, {
          children: /*#__PURE__*/jsx_runtime_.jsx(external_react_transition_group_.CSSTransition, {
            classNames: "fade",
            addEndListener: (node, done) => node.addEventListener('transitionend', done, false),
            children: /*#__PURE__*/jsx_runtime_.jsx(ArtContent, {
              pubkey: currentMetadataToShow,
              preview: false
            }, currentCardIndex)
          }, currentCardIndex)
        })
      })]
    }), isClaiming && /*#__PURE__*/(0,jsx_runtime_.jsxs)("div", {
      className: "claiming-step__notes",
      children: [/*#__PURE__*/jsx_runtime_.jsx("img", {
        src: "wallet.svg"
      }), /*#__PURE__*/jsx_runtime_.jsx("span", {
        children: infoMessageText
      })]
    }), !isClaiming && /*#__PURE__*/jsx_runtime_.jsx("button", {
      className: "claiming-step__btn",
      onClick: onClose,
      children: /*#__PURE__*/jsx_runtime_.jsx("span", {
        children: "Close and view cards"
      })
    }), /*#__PURE__*/(0,jsx_runtime_.jsxs)("div", {
      className: "claiming-step__footer",
      children: [isClaiming && /*#__PURE__*/jsx_runtime_.jsx(components_SmallLoader, {}), !isClaiming && /*#__PURE__*/jsx_runtime_.jsx(icons_.CheckOutlined, {
        className: "claiming-step__check"
      }), footerText]
    })]
  });
};

/* harmony default export */ const components_ClaimingStep = (ClaimingStep);
;// CONCATENATED MODULE: ./src/views/pack/components/RedeemModal/components/ClaimingStep/ClaimingError/index.tsx






const ClaimingError = ({
  error = '',
  onDismiss
}) => {
  return /*#__PURE__*/jsx_runtime_.jsx("div", {
    className: "claim-error-modal",
    children: /*#__PURE__*/(0,jsx_runtime_.jsxs)("div", {
      className: "claim-error-modal-content",
      children: [/*#__PURE__*/jsx_runtime_.jsx("div", {
        className: "warning-icon",
        children: /*#__PURE__*/jsx_runtime_.jsx(icons_.ExclamationCircleOutlined, {
          width: "20px",
          height: "20px"
        })
      }), /*#__PURE__*/jsx_runtime_.jsx("h4", {
        children: "Transaction error"
      }), /*#__PURE__*/(0,jsx_runtime_.jsxs)("div", {
        className: "error-text",
        children: ["Your transaction was not completed for", ' ', error ? error : 'an unknown reason. Please try again.']
      }), /*#__PURE__*/jsx_runtime_.jsx(external_antd_.Button, {
        onClick: onDismiss,
        children: "Dismiss"
      })]
    })
  });
};

/* harmony default export */ const ClaimingStep_ClaimingError = (ClaimingError);
;// CONCATENATED MODULE: ./src/views/pack/components/RedeemModal/index.tsx












var openState;

(function (openState) {
  openState[openState["Initial"] = 0] = "Initial";
  openState[openState["TransactionApproval"] = 1] = "TransactionApproval";
  openState[openState["Claiming"] = 2] = "Claiming";
  openState[openState["Error"] = 3] = "Error";
})(openState || (openState = {}));

const RedeemModal = ({
  isModalVisible,
  onClose
}) => {
  var _pack$info, _pack$info2;

  const {
    handleOpenPack,
    pack,
    metadataByPackCard,
    voucherMetadataKey,
    provingProcess,
    isLoading
  } = usePack();
  const {
    0: modalState,
    1: setModalState
  } = (0,external_react_.useState)(openState.Initial);
  const {
    0: error,
    1: setError
  } = (0,external_react_.useState)('');
  const numberOfNFTs = (pack === null || pack === void 0 ? void 0 : (_pack$info = pack.info) === null || _pack$info === void 0 ? void 0 : _pack$info.packCards) || 0;
  const numberOfAttempts = (pack === null || pack === void 0 ? void 0 : (_pack$info2 = pack.info) === null || _pack$info2 === void 0 ? void 0 : _pack$info2.allowedAmountToRedeem) || 0;
  const shouldEnableRedeem = process.env.NEXT_ENABLE_NFT_PACKS_REDEEM === 'true';
  const art = useArt(voucherMetadataKey);
  const creators = (art.creators || []).map(creator => creator.name || (0,lib.shortenAddress)(creator.address || ''));

  const handleOpen = async () => {
    setModalState(openState.Claiming);

    try {
      await handleOpenPack();
    } catch (e) {
      setModalState(openState.Error);
      setError((e === null || e === void 0 ? void 0 : e.message) || '');
    }
  };

  const handleClose = (0,external_react_.useCallback)(() => {
    onClose();
    setModalState(openState.Initial);
  }, [modalState, onClose, setModalState]);
  const onClickOpen = (0,external_react_.useCallback)(() => {
    if (modalState === openState.Initial) {
      return setModalState(openState.TransactionApproval);
    }

    handleOpen();
  }, [modalState]);
  const isModalClosable = modalState === openState.Initial;
  const isClaiming = modalState === openState.Claiming;
  const isClaimingError = modalState === openState.Error;
  const isLoadingMetadata = isLoading || Object.values(metadataByPackCard || {}).length !== ((pack === null || pack === void 0 ? void 0 : pack.info.packCards) || 0);
  return /*#__PURE__*/jsx_runtime_.jsx(external_antd_.Modal, {
    className: "modal-redeem-wr",
    centered: true,
    width: 575,
    mask: false,
    visible: isModalVisible,
    onCancel: handleClose,
    footer: null,
    closable: isModalClosable,
    maskClosable: false,
    children: /*#__PURE__*/(0,jsx_runtime_.jsxs)("div", {
      className: "modal-redeem",
      children: [isClaiming && /*#__PURE__*/jsx_runtime_.jsx(components_ClaimingStep, {
        onClose: handleClose
      }), !isClaiming && /*#__PURE__*/(0,jsx_runtime_.jsxs)(jsx_runtime_.Fragment, {
        children: [modalState === openState.Initial && /*#__PURE__*/jsx_runtime_.jsx(components_InitialStep, {
          onClose: onClose,
          metadataByPackCard: metadataByPackCard,
          numberOfAttempts: numberOfAttempts,
          numberOfNFTs: numberOfNFTs,
          creators: creators,
          isLoadingMetadata: isLoadingMetadata
        }), modalState === openState.TransactionApproval && /*#__PURE__*/jsx_runtime_.jsx(components_TransactionApprovalStep, {
          goBack: () => setModalState(openState.Initial)
        }), isClaimingError && /*#__PURE__*/jsx_runtime_.jsx(ClaimingStep_ClaimingError, {
          onDismiss: () => setModalState(openState.Initial),
          error: error
        }), shouldEnableRedeem && !isClaimingError && /*#__PURE__*/(0,jsx_runtime_.jsxs)("div", {
          className: "modal-redeem__footer",
          children: [/*#__PURE__*/jsx_runtime_.jsx("p", {
            className: "general-desc",
            children: "Once opened, a Pack cannot be resealed."
          }), /*#__PURE__*/jsx_runtime_.jsx("button", {
            className: "modal-redeem__open-nft",
            disabled: isLoadingMetadata,
            onClick: onClickOpen,
            children: /*#__PURE__*/jsx_runtime_.jsx("span", {
              children: provingProcess ? 'Resume Opening Pack' : 'Open Pack'
            })
          })]
        })]
      })]
    })
  });
};

/* harmony default export */ const components_RedeemModal = (RedeemModal);
;// CONCATENATED MODULE: ./src/views/pack/components/OpenPackButton/index.tsx






const OpenPackButton = ({
  onClick
}) => {
  const {
    provingProcess
  } = usePack();
  return /*#__PURE__*/(0,jsx_runtime_.jsxs)("div", {
    className: "open-pack",
    children: [/*#__PURE__*/jsx_runtime_.jsx("div", {
      className: "open-pack__title",
      children: "Once opened a Pack cannot be resealed"
    }), /*#__PURE__*/jsx_runtime_.jsx(external_antd_.Button, {
      onClick: onClick,
      children: provingProcess ? 'Resume Opening Pack' : 'Open Pack'
    })]
  });
};

/* harmony default export */ const components_OpenPackButton = (OpenPackButton);
;// CONCATENATED MODULE: ./src/views/pack/components/PackSidebar/index.tsx













const PackSidebar = ({
  onOpenPack
}) => {
  var _pack$info, _pack$info2, _pack$info3;

  const {
    pack,
    voucherMetadataKey,
    provingProcess
  } = usePack();
  const metadataPubkey = voucherMetadataKey || '';
  const art = useArt(metadataPubkey);
  const uri = pack === null || pack === void 0 ? void 0 : pack.info.uri;
  const {
    publicKey
  } = (0,wallet_adapter_react_.useWallet)();
  const userWallet = (0,lib.pubkeyToString)(publicKey);
  const isExhausted = provingProcess === null || provingProcess === void 0 ? void 0 : provingProcess.info.isExhausted;
  const shouldEnableRedeem = process.env.NEXT_ENABLE_NFT_PACKS_REDEEM === 'true';
  return /*#__PURE__*/(0,jsx_runtime_.jsxs)("div", {
    className: "pack-view__sidebar",
    children: [/*#__PURE__*/(0,jsx_runtime_.jsxs)("div", {
      className: "pack-view__owner",
      children: [/*#__PURE__*/jsx_runtime_.jsx("div", {
        className: "item-title",
        children: "Owner"
      }), (art.creators || []).map(creator => /*#__PURE__*/(0,jsx_runtime_.jsxs)("div", {
        children: [/*#__PURE__*/jsx_runtime_.jsx(MetaAvatar, {
          creators: [creator],
          size: 32
        }), /*#__PURE__*/jsx_runtime_.jsx("span", {
          className: "item-name",
          children: creator.name || (0,lib.shortenAddress)((creator === null || creator === void 0 ? void 0 : creator.address) || '')
        }), userWallet === creator.address && /*#__PURE__*/jsx_runtime_.jsx("div", {
          className: "you-label",
          children: "You"
        })]
      }, creator.address))]
    }), /*#__PURE__*/jsx_runtime_.jsx(external_antd_.Divider, {
      className: "divider"
    }), /*#__PURE__*/(0,jsx_runtime_.jsxs)("div", {
      className: "pack-view__art-preview",
      children: [uri && /*#__PURE__*/jsx_runtime_.jsx(ArtContent, {
        uri: uri,
        active: true,
        allowMeshRender: true,
        artView: true
      }), !uri && /*#__PURE__*/jsx_runtime_.jsx(external_antd_.Skeleton.Image, {})]
    }), /*#__PURE__*/jsx_runtime_.jsx("h4", {
      className: "pack-view__name",
      children: (pack === null || pack === void 0 ? void 0 : (_pack$info = pack.info) === null || _pack$info === void 0 ? void 0 : _pack$info.name) || /*#__PURE__*/jsx_runtime_.jsx(external_antd_.Skeleton, {
        paragraph: {
          rows: 1
        }
      })
    }), /*#__PURE__*/(0,jsx_runtime_.jsxs)("div", {
      className: "pack-view__info",
      children: [/*#__PURE__*/(0,jsx_runtime_.jsxs)("div", {
        className: "info-item",
        children: [/*#__PURE__*/jsx_runtime_.jsx("div", {
          className: "info-item__title",
          children: "PACK OF"
        }), /*#__PURE__*/(0,jsx_runtime_.jsxs)("div", {
          className: "info-item__value",
          children: [(pack === null || pack === void 0 ? void 0 : (_pack$info2 = pack.info) === null || _pack$info2 === void 0 ? void 0 : _pack$info2.packCards) || 0, " NFTs"]
        })]
      }), /*#__PURE__*/(0,jsx_runtime_.jsxs)("div", {
        className: "info-item",
        children: [/*#__PURE__*/jsx_runtime_.jsx("div", {
          className: "info-item__title",
          children: "Royalties"
        }), /*#__PURE__*/jsx_runtime_.jsx("div", {
          className: "info-item__value",
          children: (0,lib.royalty)(art.seller_fee_basis_points)
        })]
      }), /*#__PURE__*/jsx_runtime_.jsx("div", {
        className: "info-item",
        children: /*#__PURE__*/jsx_runtime_.jsx(ViewOn, {
          id: metadataPubkey
        })
      })]
    }), /*#__PURE__*/jsx_runtime_.jsx(external_antd_.Divider, {
      className: "divider"
    }), shouldEnableRedeem && !isExhausted && /*#__PURE__*/jsx_runtime_.jsx(components_OpenPackButton, {
      onClick: onOpenPack
    }), /*#__PURE__*/jsx_runtime_.jsx(external_antd_.Divider, {
      className: "divider"
    }), /*#__PURE__*/(0,jsx_runtime_.jsxs)("div", {
      className: "pack-view__description-block",
      children: [/*#__PURE__*/jsx_runtime_.jsx("p", {
        className: "pack-view__title",
        children: "DETAILS"
      }), /*#__PURE__*/jsx_runtime_.jsx("p", {
        className: "pack-view__text",
        children: (pack === null || pack === void 0 ? void 0 : (_pack$info3 = pack.info) === null || _pack$info3 === void 0 ? void 0 : _pack$info3.description) || /*#__PURE__*/jsx_runtime_.jsx(external_antd_.Skeleton, {
          paragraph: {
            rows: 3
          }
        })
      })]
    }), /*#__PURE__*/(0,jsx_runtime_.jsxs)("div", {
      className: "pack-view__info-mobile",
      children: [/*#__PURE__*/jsx_runtime_.jsx("div", {
        className: "info-item",
        children: /*#__PURE__*/jsx_runtime_.jsx(ViewOn, {
          id: metadataPubkey
        })
      }), /*#__PURE__*/jsx_runtime_.jsx(external_antd_.Divider, {
        className: "divider"
      })]
    })]
  });
};

/* harmony default export */ const components_PackSidebar = (PackSidebar);
;// CONCATENATED MODULE: ./src/views/pack/components/ArtCard/index.tsx








const ArtCard_ArtCard = ({
  index,
  isModalOpened
}) => {
  const {
    openedMetadata,
    provingProcess
  } = usePack();
  const cardsRedeemed = (provingProcess === null || provingProcess === void 0 ? void 0 : provingProcess.info.cardsRedeemed) || 0;
  const isOpenedCard = index < cardsRedeemed;
  const metadata = openedMetadata[index];
  const pubkey = (metadata === null || metadata === void 0 ? void 0 : metadata.metadata.pubkey) || '';
  const {
    ref,
    data
  } = useExtendedArt(pubkey);
  const style = {
    backgroundImage: `url(${data === null || data === void 0 ? void 0 : data.image})`
  };
  const shouldRenderImage = !isModalOpened && isOpenedCard && pubkey;
  return /*#__PURE__*/(0,jsx_runtime_.jsxs)("div", {
    className: "pack-card",
    ref: ref,
    children: [shouldRenderImage && /*#__PURE__*/jsx_runtime_.jsx(external_react_router_dom_.Link, {
      to: `/art/${pubkey}`,
      children: /*#__PURE__*/jsx_runtime_.jsx("div", {
        className: "pack-card__image",
        style: style
      })
    }), !shouldRenderImage && /*#__PURE__*/jsx_runtime_.jsx("div", {
      className: "pack-card__square",
      children: /*#__PURE__*/(0,jsx_runtime_.jsxs)("div", {
        className: "pack-card__square__front",
        children: [isOpenedCard && /*#__PURE__*/jsx_runtime_.jsx(components_SmallLoader, {}), !isOpenedCard && /*#__PURE__*/jsx_runtime_.jsx("span", {
          children: index + 1
        })]
      })
    })]
  });
};

/* harmony default export */ const components_ArtCard = (ArtCard_ArtCard);
;// CONCATENATED MODULE: ./src/views/pack/index.tsx









const PackView = () => {
  const {
    0: openModal,
    1: setOpenModal
  } = (0,external_react_.useState)(false);
  const {
    provingProcess,
    pack
  } = usePack();
  const cardsRedeemed = (provingProcess === null || provingProcess === void 0 ? void 0 : provingProcess.info.cardsRedeemed) || 0;
  const packSize = (pack === null || pack === void 0 ? void 0 : pack.info.allowedAmountToRedeem) || 0;
  const cards = (0,external_react_.useMemo)(() => Array.from({
    length: packSize
  }, (_, i) => i), [packSize, cardsRedeemed]);
  const handleToggleModal = (0,external_react_.useCallback)(async () => {
    setOpenModal(!openModal);
  }, [openModal]);
  return /*#__PURE__*/(0,jsx_runtime_.jsxs)("div", {
    className: "pack-view",
    children: [/*#__PURE__*/(0,jsx_runtime_.jsxs)(external_antd_.Row, {
      children: [/*#__PURE__*/jsx_runtime_.jsx(external_antd_.Col, {
        md: 16,
        children: /*#__PURE__*/jsx_runtime_.jsx("div", {
          className: "pack-view__list",
          children: cards.map(index => /*#__PURE__*/jsx_runtime_.jsx(components_ArtCard, {
            index: index,
            isModalOpened: openModal
          }, index))
        })
      }), /*#__PURE__*/jsx_runtime_.jsx(external_antd_.Col, {
        md: 8,
        className: "pack-view__sidebar-container",
        children: /*#__PURE__*/jsx_runtime_.jsx(components_PackSidebar, {
          onOpenPack: handleToggleModal
        })
      })]
    }), /*#__PURE__*/jsx_runtime_.jsx(components_RedeemModal, {
      isModalVisible: openModal,
      onClose: handleToggleModal
    })]
  });
};

const PackViewWithContext = () => /*#__PURE__*/jsx_runtime_.jsx(PackProvider, {
  children: /*#__PURE__*/jsx_runtime_.jsx(PackView, {})
});

/* harmony default export */ const pack = (PackViewWithContext);
;// CONCATENATED MODULE: ./src/views/packCreate/data.ts

const INITIAL_PACK_STATE = {
  selectedItems: {},
  selectedVouchers: {},
  allowedAmountToRedeem: 0,
  name: '',
  description: '',
  uri: '',
  distributionType: lib.PackDistributionType.Fixed,
  weightByMetadataKey: {},
  supplyByMetadataKey: {},
  isUnlimitedSupply: false,
  mutable: true
};
;// CONCATENATED MODULE: ./src/views/packCreate/types.ts
let CreatePackSteps;

(function (CreatePackSteps) {
  CreatePackSteps[CreatePackSteps["SelectItems"] = 0] = "SelectItems";
  CreatePackSteps[CreatePackSteps["SelectVoucher"] = 1] = "SelectVoucher";
  CreatePackSteps[CreatePackSteps["AdjustQuantities"] = 2] = "AdjustQuantities";
  CreatePackSteps[CreatePackSteps["ReviewAndMint"] = 3] = "ReviewAndMint";
})(CreatePackSteps || (CreatePackSteps = {}));
;// CONCATENATED MODULE: ./src/views/packCreate/utils.ts





const isItemInPackFilter = (selectedItems, item) => selectedItems[item.metadata.pubkey];
const masterEditionFilter = ({
  edition
}) => !edition;
const limitedSupplyFilter = ({
  masterEdition
}) => {
  var _masterEdition$info$m;

  return !!(masterEdition !== null && masterEdition !== void 0 && (_masterEdition$info$m = masterEdition.info.maxSupply) !== null && _masterEdition$info$m !== void 0 && _masterEdition$info$m.toNumber());
};
const unlimitedSupplyFilter = ({
  masterEdition
}) => (masterEdition === null || masterEdition === void 0 ? void 0 : masterEdition.info.maxSupply) === undefined;
const hasSupplyFilter = ({
  masterEdition
}) => {
  var _masterEdition$info$s;

  return !!(masterEdition !== null && masterEdition !== void 0 && (_masterEdition$info$s = masterEdition.info.supply) !== null && _masterEdition$info$s !== void 0 && _masterEdition$info$s.toNumber());
};
const nonUniqueItemFilter = item => unlimitedSupplyFilter(item) || limitedSupplyFilter(item);
const packItemsFilter = (selectedItems, isUnlimited) => item => {
  if (Object.values(selectedItems).length === 0) {
    return nonUniqueItemFilter(item) && masterEditionFilter(item);
  }

  const shouldShowItemBasedOnSupply = isUnlimited ? unlimitedSupplyFilter(item) : limitedSupplyFilter(item);
  return shouldShowItemBasedOnSupply && masterEditionFilter(item);
};
const vouchersFilter = selectedItems => item => !isItemInPackFilter(selectedItems, item) && nonUniqueItemFilter(item) && masterEditionFilter(item) && hasSupplyFilter(item);
const mapSelectedItems = ({
  selectedItems,
  supplyByMetadataKey,
  weightByMetadataKey,
  accountByMint,
  distributionType
}) => Object.keys(selectedItems).map((pubKey, index) => {
  const {
    mint
  } = selectedItems[pubKey].metadata.info;
  const tokenAccount = accountByMint.get(mint);
  if (!tokenAccount) throw new Error(`No token account for the metadata: ${pubKey}`);
  const maxSupply = distributionType !== lib.PackDistributionType.Unlimited && supplyByMetadataKey[pubKey] ? new external_bn_js_.BN(supplyByMetadataKey[pubKey]) : new external_bn_js_.BN(0);
  const weight = distributionType !== lib.PackDistributionType.MaxSupply && weightByMetadataKey[pubKey] ? new external_bn_js_.BN(weightByMetadataKey[pubKey]) : new external_bn_js_.BN(0);
  const toAccount = web3_js_.Keypair.generate();
  return {
    index: index + 1,
    // Packs indexing starts from 1
    mint,
    maxSupply,
    weight,
    tokenAccount,
    toAccount
  };
});
const mapSelectedVouchers = ({
  selectedVouchers,
  accountByMint
}) => Object.keys(selectedVouchers).map((pubKey, index) => {
  const {
    mint
  } = selectedVouchers[pubKey].metadata.info;
  const tokenAccount = accountByMint.get(mint);
  if (!tokenAccount) throw new Error(`No token account for the metadata: ${pubKey}`);
  return {
    index: index + 1,
    // Packs indexing starts from 1
    mint,
    tokenAccount
  };
});
const exceededPacksCountNotification = () => {
  external_antd_.notification.warning({
    message: 'Exceeded Max Selected Count!',
    description: `Maximum ${MAX_PACKS_CREATION_COUNT} items can be selected.`,
    className: 'notification-container'
  });
};
;// CONCATENATED MODULE: ./src/views/packCreate/hooks/useStep.ts




const useStep = () => {
  const {
    0: step,
    1: setStep
  } = (0,external_react_.useState)(CreatePackSteps.SelectItems);
  const history = (0,external_react_router_dom_.useHistory)();
  const {
    stepParam
  } = (0,external_react_router_dom_.useParams)();
  const goToNextStep = (0,external_react_.useCallback)(nextStep => {
    const historyNextStep = nextStep === undefined ? step + 1 : nextStep;
    history.push(`/admin/pack/create/${historyNextStep.toString()}`);
  }, [step, history]);
  const resetStep = (0,external_react_.useCallback)(() => {
    setStep(CreatePackSteps.SelectItems);
  }, [setStep]);
  (0,external_react_.useEffect)(() => {
    if (stepParam) {
      return setStep(parseInt(stepParam));
    }

    goToNextStep(CreatePackSteps.SelectItems);
  }, [stepParam]);
  return {
    step,
    goToNextStep,
    resetStep
  };
};

/* harmony default export */ const hooks_useStep = (useStep);
;// CONCATENATED MODULE: ./src/views/packCreate/components/Header/data.ts

const HEADER_CONTENT = {
  [CreatePackSteps.SelectItems]: {
    title: 'Select items for your Pack Listing'
  },
  [CreatePackSteps.SelectVoucher]: {
    title: 'Select voucher for your Pack Opening'
  },
  [CreatePackSteps.AdjustQuantities]: {
    title: 'Adjust Quantities'
  },
  [CreatePackSteps.ReviewAndMint]: {
    title: 'Review and mint your pack'
  }
};
;// CONCATENATED MODULE: ./src/views/packCreate/components/Header/index.tsx





const Header_Header = ({
  step,
  children
}) => {
  const {
    title
  } = HEADER_CONTENT[step];
  return /*#__PURE__*/(0,jsx_runtime_.jsxs)("div", {
    className: "create-pack-header",
    children: [/*#__PURE__*/jsx_runtime_.jsx("p", {
      className: "create-pack-header__title",
      children: title
    }), children]
  });
};

/* harmony default export */ const components_Header = (Header_Header);
// EXTERNAL MODULE: external "react-dom"
var external_react_dom_ = __webpack_require__(2268);
;// CONCATENATED MODULE: ./src/views/packCreate/components/Sidebar/data.ts

const STEPS_TITLES = {
  [CreatePackSteps.SelectItems]: 'Select Items',
  [CreatePackSteps.SelectVoucher]: 'Select Voucher',
  [CreatePackSteps.AdjustQuantities]: 'Adjust Quantities',
  [CreatePackSteps.ReviewAndMint]: 'Review & Mint'
};
const CONTINUE_TITLES = {
  [CreatePackSteps.SelectItems]: 'Continue to Voucher',
  [CreatePackSteps.SelectVoucher]: 'Continue to Quantities',
  [CreatePackSteps.AdjustQuantities]: 'Continue to Mint',
  [CreatePackSteps.ReviewAndMint]: 'Confirm & Mint'
};
;// CONCATENATED MODULE: ./src/views/packCreate/components/Sidebar/index.tsx










const {
  Step: Sidebar_Step
} = external_antd_.Steps;

const Sidebar = ({
  step,
  setStep,
  submit,
  isValidStep,
  buttonLoading
}) => {
  const {
    connected
  } = (0,wallet_adapter_react_.useWallet)();
  const {
    isLoading
  } = (0,lib.useMeta)();
  const {
    width
  } = useWindowDimensions();
  const isFinalStep = step === CreatePackSteps.ReviewAndMint;
  const shouldDisable = !isValidStep || !connected || isLoading || buttonLoading;

  const handleContinue = () => {
    if (isFinalStep) {
      return submit();
    }

    setStep(step + 1);
  };

  return /*#__PURE__*/(0,jsx_runtime_.jsxs)("div", {
    className: "sidebar-wrapper",
    children: [/*#__PURE__*/jsx_runtime_.jsx(external_antd_.Steps, {
      className: "sidebar-steps",
      direction: width < 768 ? 'horizontal' : 'vertical',
      current: step,
      children: Object.entries(STEPS_TITLES).map(([step, title]) => /*#__PURE__*/jsx_runtime_.jsx(Sidebar_Step, {
        title: title
      }, step))
    }), /*#__PURE__*/jsx_runtime_.jsx(external_antd_.Button, {
      className: "sidebar-btn secondary-btn",
      onClick: handleContinue,
      disabled: shouldDisable,
      children: buttonLoading ? /*#__PURE__*/jsx_runtime_.jsx(external_antd_.Spin, {}) : CONTINUE_TITLES[step]
    }), step !== CreatePackSteps.SelectItems && /*#__PURE__*/jsx_runtime_.jsx(external_antd_.Button, {
      type: "text",
      className: "sidebar-btn",
      onClick: () => setStep(step - 1),
      children: "Back"
    })]
  });
};

/* harmony default export */ const components_Sidebar = (/*#__PURE__*/(0,external_react_.memo)(Sidebar));
// EXTERNAL MODULE: external "classnames"
var external_classnames_ = __webpack_require__(4058);
var external_classnames_default = /*#__PURE__*/__webpack_require__.n(external_classnames_);
;// CONCATENATED MODULE: ./src/views/packCreate/components/ItemRow/index.tsx







const ItemRow = ({
  item,
  isSelected,
  onClick,
  showSupply,
  children
}) => {
  var _metadata$info, _masterEdition$info$m, _masterEdition$info$s;

  const {
    metadata,
    masterEdition
  } = item;
  const {
    pubkey
  } = metadata;
  const {
    name
  } = metadata === null || metadata === void 0 ? void 0 : (_metadata$info = metadata.info) === null || _metadata$info === void 0 ? void 0 : _metadata$info.data;
  const {
    ref,
    data
  } = useExtendedArt(pubkey);
  const maximumSupply = (masterEdition === null || masterEdition === void 0 ? void 0 : (_masterEdition$info$m = masterEdition.info.maxSupply) === null || _masterEdition$info$m === void 0 ? void 0 : _masterEdition$info$m.toString()) || 'Unlimited';
  const supply = (masterEdition === null || masterEdition === void 0 ? void 0 : (_masterEdition$info$s = masterEdition.info.supply) === null || _masterEdition$info$s === void 0 ? void 0 : _masterEdition$info$s.toString()) || '0';
  const itemRowCls = external_classnames_default()({
    'pack-item-row': true,
    'pack-item-row--selected': isSelected
  });
  return /*#__PURE__*/(0,jsx_runtime_.jsxs)("div", {
    className: itemRowCls,
    onClick: onClick,
    ref: ref,
    children: [children, /*#__PURE__*/jsx_runtime_.jsx("div", {
      className: "preview-column",
      children: /*#__PURE__*/jsx_runtime_.jsx(ArtContent, {
        uri: data === null || data === void 0 ? void 0 : data.image,
        preview: false
      })
    }), /*#__PURE__*/(0,jsx_runtime_.jsxs)("div", {
      className: "name-column",
      children: [/*#__PURE__*/jsx_runtime_.jsx("p", {
        className: "name-column__name",
        children: name
      }), /*#__PURE__*/jsx_runtime_.jsx("p", {
        className: "name-column__subtitle",
        children: "Master"
      })]
    }), /*#__PURE__*/(0,jsx_runtime_.jsxs)("div", {
      className: "info-column",
      children: [/*#__PURE__*/jsx_runtime_.jsx("p", {
        className: "info-column__subtitle",
        children: "Maximum Supply"
      }), /*#__PURE__*/jsx_runtime_.jsx("p", {
        className: "info-column__value",
        children: maximumSupply
      })]
    }), showSupply && /*#__PURE__*/(0,jsx_runtime_.jsxs)("div", {
      className: "info-column",
      children: [/*#__PURE__*/jsx_runtime_.jsx("p", {
        className: "info-column__subtitle",
        children: "Supply"
      }), /*#__PURE__*/jsx_runtime_.jsx("p", {
        className: "info-column__value",
        children: supply
      })]
    })]
  });
};

/* harmony default export */ const components_ItemRow = (/*#__PURE__*/(0,external_react_.memo)(ItemRow));
;// CONCATENATED MODULE: ./src/views/packCreate/components/SelectItemsStep/utils.ts
const isSelected = ({
  selectedItems,
  pubkey
}) => !!(pubkey && selectedItems[pubkey]);
;// CONCATENATED MODULE: ./src/views/packCreate/components/SelectItemsStep/index.tsx







const SelectItemsStep = ({
  handleSelectItem,
  selectedItems,
  items,
  showSupply,
  emptyMessage,
  isLoading
}) => {
  const shouldShowEmptyMessage = !(items !== null && items !== void 0 && items.length) && emptyMessage;

  if (isLoading) {
    return /*#__PURE__*/jsx_runtime_.jsx(components_SmallLoader, {});
  }

  return /*#__PURE__*/(0,jsx_runtime_.jsxs)("div", {
    children: [items.map(item => /*#__PURE__*/jsx_runtime_.jsx(components_ItemRow, {
      isSelected: isSelected({
        selectedItems,
        pubkey: item.metadata.pubkey
      }),
      onClick: () => handleSelectItem(item),
      item: item,
      showSupply: showSupply
    }, item.metadata.pubkey)), shouldShowEmptyMessage && /*#__PURE__*/jsx_runtime_.jsx("p", {
      children: emptyMessage
    })]
  });
};

/* harmony default export */ const components_SelectItemsStep = (SelectItemsStep);
;// CONCATENATED MODULE: ./src/views/packCreate/components/SelectCard/index.tsx





const SelectCard = ({
  title,
  subtitle,
  isSelected,
  onClick
}) => {
  const wrapperCls = external_classnames_default()({
    'select-card-wrapper': true,
    'select-card-wrapper--selected': isSelected
  });
  return /*#__PURE__*/(0,jsx_runtime_.jsxs)("div", {
    className: wrapperCls,
    onClick: onClick,
    children: [/*#__PURE__*/jsx_runtime_.jsx("p", {
      className: "select-card-wrapper__title",
      children: title
    }), /*#__PURE__*/jsx_runtime_.jsx("p", {
      className: "select-card-wrapper__subtitle",
      children: subtitle
    })]
  });
};

/* harmony default export */ const components_SelectCard = (/*#__PURE__*/(0,external_react_.memo)(SelectCard));
;// CONCATENATED MODULE: ./src/views/packCreate/components/AdjustQuantitiesStep/interface.ts
let InputType;

(function (InputType) {
  InputType["weight"] = "weight";
  InputType["maxSupply"] = "maxSupply";
})(InputType || (InputType = {}));
;// CONCATENATED MODULE: ./src/views/packCreate/components/AdjustQuantitiesStep/data.ts

const DISTRIBUTION_TYPES_DATA = {
  [lib.PackDistributionType.MaxSupply]: {
    title: 'Supply',
    subtitle: "The chance of getting a card will be based on the card's supply that is left"
  },
  [lib.PackDistributionType.Fixed]: {
    title: 'Weighted Supply',
    subtitle: 'Weighted chance of getting each card with limited card supply'
  },
  [lib.PackDistributionType.Unlimited]: {
    title: 'Weighted',
    subtitle: 'Weighted chance of getting each card'
  }
};
;// CONCATENATED MODULE: ./src/views/packCreate/components/AdjustQuantitiesStep/index.tsx
function AdjustQuantitiesStep_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

function AdjustQuantitiesStep_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { AdjustQuantitiesStep_ownKeys(Object(source), true).forEach(function (key) { AdjustQuantitiesStep_defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { AdjustQuantitiesStep_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function AdjustQuantitiesStep_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }














const AdjustQuantitiesStep = ({
  allowedAmountToRedeem,
  distributionType,
  weightByMetadataKey,
  supplyByMetadataKey,
  selectedItems,
  setPackState,
  isUnlimited
}) => {
  const availableDistributionTypes = [...(isUnlimited ? [lib.PackDistributionType.Unlimited] : []), lib.PackDistributionType.MaxSupply, lib.PackDistributionType.Fixed];
  const shouldRenderSupplyInput = distributionType !== lib.PackDistributionType.Unlimited;
  const shouldRenderWeightInput = distributionType !== lib.PackDistributionType.MaxSupply;

  const handleRedeemAmountChange = value => {
    setPackState({
      allowedAmountToRedeem: parseInt(value)
    });
  };

  const handleDistributionChange = (item, value, inputType) => {
    var _item$masterEdition, _item$masterEdition$i;

    const number = Number(value);
    const pubKey = item.metadata.pubkey;

    if (inputType === InputType.weight && number > 100) {
      return;
    }

    if (inputType === InputType.weight) {
      return setPackState({
        weightByMetadataKey: AdjustQuantitiesStep_objectSpread(AdjustQuantitiesStep_objectSpread({}, weightByMetadataKey), {}, {
          [pubKey]: number
        })
      });
    }

    const maxSupply = (_item$masterEdition = item.masterEdition) === null || _item$masterEdition === void 0 ? void 0 : (_item$masterEdition$i = _item$masterEdition.info.maxSupply) === null || _item$masterEdition$i === void 0 ? void 0 : _item$masterEdition$i.toNumber();
    setPackState({
      supplyByMetadataKey: AdjustQuantitiesStep_objectSpread(AdjustQuantitiesStep_objectSpread({}, supplyByMetadataKey), {}, {
        [pubKey]: maxSupply !== undefined && number > maxSupply ? maxSupply : number
      })
    });
  };

  const handleDistributionTypeChange = type => {
    setPackState({
      distributionType: type
    });
  };

  return /*#__PURE__*/(0,jsx_runtime_.jsxs)("div", {
    className: "quantities-step-wrapper",
    children: [/*#__PURE__*/jsx_runtime_.jsx("p", {
      className: "quantities-step-wrapper__title",
      children: "Set number of cards in pack"
    }), /*#__PURE__*/jsx_runtime_.jsx("p", {
      className: "quantities-step-wrapper__subtitle",
      children: "Number of times user can redeem a card using a single voucher."
    }), /*#__PURE__*/jsx_runtime_.jsx(external_antd_.Input, {
      className: "quantities-step-wrapper__input",
      type: "number",
      value: allowedAmountToRedeem,
      onChange: ({
        target: {
          value
        }
      }) => handleRedeemAmountChange(value)
    }), /*#__PURE__*/jsx_runtime_.jsx("p", {
      className: "quantities-step-wrapper__title",
      children: "Select distribution type"
    }), /*#__PURE__*/jsx_runtime_.jsx("div", {
      className: "cards-select",
      children: availableDistributionTypes.map(type => /*#__PURE__*/jsx_runtime_.jsx(components_SelectCard, {
        title: DISTRIBUTION_TYPES_DATA[type].title,
        subtitle: DISTRIBUTION_TYPES_DATA[type].subtitle,
        isSelected: distributionType === type,
        onClick: () => handleDistributionTypeChange(type)
      }, type))
    }), /*#__PURE__*/(0,jsx_runtime_.jsxs)("div", {
      className: "quantities-step-wrapper__table-titles",
      children: [shouldRenderSupplyInput && /*#__PURE__*/jsx_runtime_.jsx("p", {
        children: "NUMBER OF NFTs"
      }), shouldRenderWeightInput && /*#__PURE__*/(0,jsx_runtime_.jsxs)("p", {
        className: "redeem-weight",
        children: ["REDEEM WEIGHT", ' ', /*#__PURE__*/jsx_runtime_.jsx("span", {
          children: "\u2014 Weights must be between 1-100. 1 is least likely, 100 is most likely."
        })]
      })]
    }), Object.values(selectedItems).map(item => {
      var _item$masterEdition2, _item$masterEdition2$;

      return /*#__PURE__*/jsx_runtime_.jsx(components_ItemRow, {
        item: item,
        children: /*#__PURE__*/(0,jsx_runtime_.jsxs)(jsx_runtime_.Fragment, {
          children: [shouldRenderSupplyInput && /*#__PURE__*/jsx_runtime_.jsx("div", {
            className: "input-column",
            children: /*#__PURE__*/jsx_runtime_.jsx(external_antd_.Input, {
              type: "number",
              min: 0,
              max: (_item$masterEdition2 = item.masterEdition) === null || _item$masterEdition2 === void 0 ? void 0 : (_item$masterEdition2$ = _item$masterEdition2.info.maxSupply) === null || _item$masterEdition2$ === void 0 ? void 0 : _item$masterEdition2$.toNumber(),
              className: external_classnames_default()({
                'ant-error-input': !supplyByMetadataKey[item.metadata.pubkey]
              }),
              value: supplyByMetadataKey[item.metadata.pubkey],
              onChange: ({
                target: {
                  value
                }
              }) => handleDistributionChange(item, value, InputType.maxSupply)
            })
          }), shouldRenderWeightInput && /*#__PURE__*/(0,jsx_runtime_.jsxs)("div", {
            className: "input-column",
            children: [/*#__PURE__*/jsx_runtime_.jsx(external_antd_.Input, {
              type: "number",
              min: 0,
              max: 100,
              value: weightByMetadataKey[item.metadata.pubkey],
              onChange: ({
                target: {
                  value
                }
              }) => handleDistributionChange(item, value, InputType.weight),
              className: external_classnames_default()({
                'ant-error-input error-redeem': !weightByMetadataKey[item.metadata.pubkey]
              })
            }), !weightByMetadataKey[item.metadata.pubkey] && /*#__PURE__*/jsx_runtime_.jsx("div", {
              className: "error-tooltip-container",
              children: /*#__PURE__*/jsx_runtime_.jsx(external_antd_.Tooltip, {
                overlayClassName: "creat-pack-redeem-tooltip",
                placement: "top",
                title: "Weight must be between 1-100",
                children: /*#__PURE__*/jsx_runtime_.jsx(icons_.ExclamationCircleOutlined, {
                  className: "input-info"
                })
              })
            })]
          })]
        })
      }, item.metadata.pubkey);
    })]
  });
};

/* harmony default export */ const components_AdjustQuantitiesStep = (/*#__PURE__*/(0,external_react_.memo)(AdjustQuantitiesStep));
;// CONCATENATED MODULE: ./src/views/packCreate/components/ReviewAndMintStep/utils.ts
const getTotalNFTsCount = distributions => Object.values(distributions).reduce((itemSupply, sum) => sum + itemSupply, 0);
;// CONCATENATED MODULE: ./src/views/packCreate/components/ReviewAndMintStep/index.tsx







const ReviewAndMintStep = ({
  uri,
  name,
  description,
  supplyByMetadataKey,
  allowedAmountToRedeem,
  distributionType
}) => {
  const totalNFTs = getTotalNFTsCount(supplyByMetadataKey);
  const numberOfPacks = Math.floor(totalNFTs / allowedAmountToRedeem) || 0;
  const isUnlimited = distributionType === lib.PackDistributionType.Unlimited;
  return /*#__PURE__*/(0,jsx_runtime_.jsxs)("div", {
    className: "review-step-wrapper",
    children: [/*#__PURE__*/jsx_runtime_.jsx(external_antd_.Image, {
      wrapperClassName: "review-step-wrapper__image-wrapper",
      className: "review-step-wrapper__image",
      src: uri,
      preview: true,
      loading: "lazy"
    }), /*#__PURE__*/jsx_runtime_.jsx("p", {
      className: "review-step-wrapper__title",
      children: name
    }), /*#__PURE__*/jsx_runtime_.jsx("p", {
      className: "review-step-wrapper__text",
      children: description
    }), /*#__PURE__*/jsx_runtime_.jsx("p", {
      className: "review-step-wrapper__subtitle",
      children: "Number of packs"
    }), /*#__PURE__*/jsx_runtime_.jsx("p", {
      className: "review-step-wrapper__text",
      children: isUnlimited ? 'Unlimited' : numberOfPacks
    }), /*#__PURE__*/jsx_runtime_.jsx("p", {
      className: "review-step-wrapper__subtitle",
      children: "Total NFTs"
    }), /*#__PURE__*/jsx_runtime_.jsx("p", {
      className: "review-step-wrapper__text",
      children: isUnlimited ? 'Unlimited' : totalNFTs
    })]
  });
};

/* harmony default export */ const components_ReviewAndMintStep = (/*#__PURE__*/(0,external_react_.memo)(ReviewAndMintStep));
;// CONCATENATED MODULE: ./src/components/TransactionErrorModal/index.tsx






const TransactionErrorModal = ({
  error = '',
  onDismiss,
  open,
  modalView = true
}) => {
  const modalBody = /*#__PURE__*/(0,jsx_runtime_.jsxs)("div", {
    className: "error-modal-content",
    children: [/*#__PURE__*/jsx_runtime_.jsx("div", {
      className: "warning-icon",
      children: /*#__PURE__*/jsx_runtime_.jsx(icons_.ExclamationCircleOutlined, {
        width: 20,
        height: 20
      })
    }), /*#__PURE__*/jsx_runtime_.jsx("h4", {
      children: "Transaction error"
    }), /*#__PURE__*/(0,jsx_runtime_.jsxs)("div", {
      className: "error-text",
      children: ["Your transaction was not completed for ", error ? error : 'an unknown reason. Please try again.']
    }), /*#__PURE__*/jsx_runtime_.jsx(external_antd_.Button, {
      onClick: onDismiss,
      children: "Dismiss"
    })]
  });

  if (modalView) {
    return /*#__PURE__*/jsx_runtime_.jsx(external_antd_.Modal, {
      className: "transaction-error-modal",
      centered: true,
      width: 500,
      mask: false,
      visible: open,
      onCancel: onDismiss,
      footer: null,
      closable: true,
      children: modalBody
    });
  }

  return /*#__PURE__*/jsx_runtime_.jsx("div", {
    className: "create-error-modal",
    children: modalBody
  });
};

/* harmony default export */ const components_TransactionErrorModal = (TransactionErrorModal);
;// CONCATENATED MODULE: ./src/views/packCreate/transactions/getInitPackSet.ts



const stringToUint8Array = (str, size) => {
  const array = new Uint8Array(size);
  [...str].forEach((char, index) => array[index] = char.charCodeAt(0));
  return array;
};

const getInitPackSet = async ({
  data,
  packSetKey,
  walletPublicKey
}) => {
  const {
    name,
    uri,
    description,
    mutable,
    allowedAmountToRedeem: allowedAmountToRedeemNumber,
    redeemStartDate: momentRedeemStartDate,
    redeemEndDate: momentRedeemEndDate,
    distributionType
  } = data;
  const allowedAmountToRedeem = new external_bn_js_.BN(allowedAmountToRedeemNumber);
  const redeemStartDate = momentRedeemStartDate ? new external_bn_js_.BN(momentRedeemStartDate.valueOf()) : null;
  const redeemEndDate = momentRedeemEndDate ? new external_bn_js_.BN(momentRedeemEndDate.valueOf()) : null;
  return (0,lib.initPackSet)({
    name: stringToUint8Array(name, 32),
    description,
    uri,
    mutable,
    distributionType,
    allowedAmountToRedeem,
    redeemStartDate,
    redeemEndDate,
    packSetKey,
    authority: walletPublicKey.toBase58()
  });
};
;// CONCATENATED MODULE: ./src/views/packCreate/transactions/getCreateAccount.ts

const getCreateAccount = async ({
  connection,
  newAccountPubkey,
  walletPublicKey,
  space,
  programId
}) => {
  const packSetRentExempt = await connection.getMinimumBalanceForRentExemption(space);
  return web3_js_.SystemProgram.createAccount({
    fromPubkey: walletPublicKey,
    newAccountPubkey,
    lamports: packSetRentExempt,
    space,
    programId
  });
};
;// CONCATENATED MODULE: ./src/views/packCreate/transactions/getAddCardToPack.ts
function getAddCardToPack_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

function getAddCardToPack_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { getAddCardToPack_ownKeys(Object(source), true).forEach(function (key) { getAddCardToPack_defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { getAddCardToPack_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function getAddCardToPack_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }


const getAddCardToPack = async ({
  selectedItems,
  packSetKey,
  walletPublicKey
}) => {
  const addCardsToPack = selectedItems.map(selectedItem => {
    return (0,lib.addCardToPack)(getAddCardToPack_objectSpread(getAddCardToPack_objectSpread({}, selectedItem), {}, {
      packSetKey,
      authority: walletPublicKey.toBase58()
    }));
  });
  return Promise.all(addCardsToPack);
};
;// CONCATENATED MODULE: ./src/views/packCreate/transactions/getAddVoucherToPack.ts
function getAddVoucherToPack_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

function getAddVoucherToPack_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { getAddVoucherToPack_ownKeys(Object(source), true).forEach(function (key) { getAddVoucherToPack_defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { getAddVoucherToPack_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function getAddVoucherToPack_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }


const getAddVoucherToPack = async ({
  selectedVouchers,
  packSetKey,
  walletPublicKey
}) => {
  const addVouchersToPack = selectedVouchers.map(voucher => {
    return (0,lib.addVoucherToPack)(getAddVoucherToPack_objectSpread(getAddVoucherToPack_objectSpread({}, voucher), {}, {
      packSetKey,
      authority: walletPublicKey.toBase58()
    }));
  });
  return Promise.all(addVouchersToPack);
};
;// CONCATENATED MODULE: ./src/views/packCreate/transactions/getActivate.ts

const getActivate = async ({
  packSetKey,
  walletPublicKey
}) => {
  return (0,lib.activate)({
    packSetKey,
    authority: walletPublicKey.toBase58()
  });
};
;// CONCATENATED MODULE: ./src/views/packCreate/transactions/getCreateTokenAccounts.ts



const getCreateTokenAccounts = ({
  cardsToAdd,
  connection,
  walletPublicKey
}) => Promise.all(cardsToAdd.map(({
  toAccount
}) => getCreateAccount({
  connection,
  walletPublicKey,
  newAccountPubkey: toAccount.publicKey,
  space: spl_token_.AccountLayout.span,
  programId: (0,lib.programIds)().token
})));
;// CONCATENATED MODULE: ./src/views/packCreate/transactions/createPack.ts











const CREATE_ACCOUNT_CHUNK_SIZE = 5;
const ADD_CARD_TO_PACK_CHUNK_SIZE = 3;

const chunk = (arr, chunkSize) => {
  const R = [];

  for (let i = 0, len = arr.length; i < len; i += chunkSize) {
    R.push(arr.slice(i, i + chunkSize));
  }

  return R;
};

const generateCreatePackInstructions = async ({
  wallet,
  connection,
  accountByMint,
  data
}) => {
  if (!wallet.publicKey) throw new wallet_adapter_base_.WalletNotConnectedError();
  const packSet = web3_js_.Keypair.generate();
  if (!packSet.publicKey) new Error('No packSet key');
  const walletPublicKey = wallet.publicKey;
  const packSetKey = packSet.publicKey;
  const createAccountInstruction = await getCreateAccount({
    connection,
    walletPublicKey,
    newAccountPubkey: packSetKey,
    space: lib.MAX_PACK_SET_SIZE,
    programId: (0,lib.programIds)().pack_create
  });
  const initPackSetInstruction = await getInitPackSet({
    data,
    walletPublicKey,
    packSetKey
  });
  const {
    selectedVouchers,
    selectedItems,
    supplyByMetadataKey,
    weightByMetadataKey,
    distributionType
  } = data;
  const cardsToAdd = mapSelectedItems({
    selectedItems,
    supplyByMetadataKey,
    weightByMetadataKey,
    accountByMint,
    distributionType
  }); // Create accounts for token transfer

  const createTokenAccountsInstructions = await getCreateTokenAccounts({
    cardsToAdd,
    connection,
    walletPublicKey
  });
  const addCardToPackInstructions = await getAddCardToPack({
    selectedItems: cardsToAdd,
    walletPublicKey,
    packSetKey
  });
  const vouchersToAdd = mapSelectedVouchers({
    selectedVouchers,
    accountByMint
  });
  const addVoucherToPackInstructions = await getAddVoucherToPack({
    selectedVouchers: vouchersToAdd,
    walletPublicKey,
    packSetKey
  });
  const activateInstruction = await getActivate({
    walletPublicKey,
    packSetKey
  });
  const addCardsChunks = chunk(addCardToPackInstructions, ADD_CARD_TO_PACK_CHUNK_SIZE);
  const addCardsSignersChunks = addCardsChunks.map(() => []);
  const createTokenAccountsChunks = chunk(createTokenAccountsInstructions, CREATE_ACCOUNT_CHUNK_SIZE);
  const createTokenSignersChunks = chunk(cardsToAdd.map(({
    toAccount
  }) => toAccount), CREATE_ACCOUNT_CHUNK_SIZE);
  return {
    instructions: [[createAccountInstruction, initPackSetInstruction], ...createTokenAccountsChunks, ...addCardsChunks, addVoucherToPackInstructions, [activateInstruction]],
    signers: [[packSet], ...createTokenSignersChunks, ...addCardsSignersChunks, [], []]
  };
};

const sendCreatePack = async ({
  wallet,
  connection,
  accountByMint,
  data
}) => {
  const {
    instructions,
    signers
  } = await generateCreatePackInstructions({
    wallet,
    connection,
    accountByMint,
    data
  });
  return (0,lib.sendTransactionsInChunks)(connection, wallet, instructions, signers, lib.SequenceType.Sequential, 'singleGossip', 120000, 10);
};
;// CONCATENATED MODULE: ./src/views/packCreate/components/SuccessModal/index.tsx







const SuccessModal = ({
  shouldShow,
  hide
}) => {
  return /*#__PURE__*/(0,jsx_runtime_.jsxs)(lib.MetaplexOverlay, {
    visible: shouldShow,
    children: [/*#__PURE__*/jsx_runtime_.jsx(Confetti, {}), /*#__PURE__*/jsx_runtime_.jsx("h1", {
      className: "title",
      style: {
        fontSize: '3rem',
        marginBottom: 20
      },
      children: "Congratulations"
    }), /*#__PURE__*/jsx_runtime_.jsx("p", {
      style: {
        color: 'white',
        textAlign: 'center',
        fontSize: '2rem'
      },
      children: "Your pack has been created."
    }), /*#__PURE__*/jsx_runtime_.jsx(external_antd_.Button, {
      className: "sidebar-btn secondary-btn",
      onClick: hide,
      children: "Continue"
    })]
  });
};

/* harmony default export */ const components_SuccessModal = (SuccessModal);
;// CONCATENATED MODULE: ./src/views/packCreate/hooks/useValidation.ts



const hasMappedPubkeys = (pubkeys, mappedPubkeys) => pubkeys.every(element => mappedPubkeys.includes(element));

const isValidQuantities = attributes => {
  const {
    allowedAmountToRedeem,
    distributionType,
    selectedItems,
    weightByMetadataKey,
    supplyByMetadataKey
  } = attributes;
  const isValidAmountOfCardsInPack = allowedAmountToRedeem > 0;
  const selectedItemsPubkeys = Object.keys(selectedItems);

  const hasMappedSupply = () => hasMappedPubkeys(selectedItemsPubkeys, Object.keys(supplyByMetadataKey));

  const hasMappedWeight = () => hasMappedPubkeys(selectedItemsPubkeys, Object.keys(weightByMetadataKey));

  switch (distributionType) {
    case lib.PackDistributionType.Unlimited:
      return isValidAmountOfCardsInPack && hasMappedWeight();

    case lib.PackDistributionType.MaxSupply:
      return isValidAmountOfCardsInPack && hasMappedSupply();

    case lib.PackDistributionType.Fixed:
      return isValidAmountOfCardsInPack && hasMappedSupply() && hasMappedWeight();
  }
};

const useValidation = ({
  attributes,
  step
}) => {
  const {
    selectedItems,
    selectedVouchers
  } = attributes;

  switch (step) {
    case CreatePackSteps.SelectItems:
      return Object.values(selectedItems).length > 0;

    case CreatePackSteps.SelectVoucher:
      return Object.values(selectedVouchers).length > 0;

    case CreatePackSteps.AdjustQuantities:
      return isValidQuantities(attributes);

    default:
      return true;
  }
};
;// CONCATENATED MODULE: ./src/views/packCreate/index.tsx
function packCreate_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

function packCreate_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { packCreate_ownKeys(Object(source), true).forEach(function (key) { packCreate_defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { packCreate_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function packCreate_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }




















 // ToDo: Refactor state to a react context



const PackCreateView = () => {
  const history = (0,external_react_router_dom_.useHistory)();
  const {
    0: attributes,
    1: setAttributes
  } = (0,external_react_.useState)(INITIAL_PACK_STATE);
  const {
    0: shouldShowSuccessModal,
    1: setShouldShowSuccessModal
  } = (0,external_react_.useState)(false);
  const {
    0: errorModal,
    1: setErrorModal
  } = (0,external_react_.useState)({
    error: '',
    display: false
  });
  const {
    0: isCreating,
    1: setIsCreating
  } = (0,external_react_.useState)(false);
  const {
    pullUserMetadata
  } = (0,lib.useMeta)();
  const items = useUserArts();
  const {
    step,
    goToNextStep,
    resetStep
  } = hooks_useStep();
  const wallet = (0,wallet_adapter_react_.useWallet)();
  const connection = (0,lib.useConnection)();
  const {
    isFetching
  } = (0,lib.useMeta)();
  const {
    accountByMint,
    userAccounts
  } = (0,lib.useUserAccounts)();
  const isValidStep = useValidation({
    attributes,
    step
  });
  const isLoading = isCreating || isFetching;
  const {
    selectedItems,
    selectedVouchers,
    distributionType,
    weightByMetadataKey,
    supplyByMetadataKey,
    allowedAmountToRedeem,
    name,
    description,
    uri,
    isUnlimitedSupply
  } = attributes;
  const itemsToSelect = items.filter(packItemsFilter(selectedItems, isUnlimitedSupply));
  const vouchersToSelect = items.filter(vouchersFilter(selectedItems));
  const [selectedVoucherId] = Object.keys(selectedVouchers);
  const {
    ref,
    data
  } = useExtendedArt(selectedVoucherId);
  const setPackState = (0,external_react_.useCallback)(value => {
    setAttributes(packCreate_objectSpread(packCreate_objectSpread({}, attributes), value));
  }, [attributes, setAttributes]);
  const handleSelectItem = (0,external_react_.useCallback)(item => {
    const {
      metadata,
      masterEdition
    } = item;

    if (!(metadata !== null && metadata !== void 0 && metadata.pubkey)) {
      return;
    }

    const updatedSelectedItems = packCreate_objectSpread({}, selectedItems);

    if (updatedSelectedItems[metadata.pubkey]) {
      delete updatedSelectedItems[metadata.pubkey];
    } else {
      updatedSelectedItems[metadata.pubkey] = item;

      if (Object.keys(updatedSelectedItems).length > MAX_PACKS_CREATION_COUNT) {
        exceededPacksCountNotification();
        return;
      }
    }

    const isUnlimitedSupply = (masterEdition === null || masterEdition === void 0 ? void 0 : masterEdition.info.maxSupply) === undefined;
    setPackState({
      selectedItems: updatedSelectedItems,
      distributionType: isUnlimitedSupply ? lib.PackDistributionType.Unlimited : lib.PackDistributionType.Fixed,
      isUnlimitedSupply
    });
  }, [setPackState, selectedItems]);
  const handleSelectVoucher = (0,external_react_.useCallback)(item => {
    const {
      metadata
    } = item;

    if (!(metadata !== null && metadata !== void 0 && metadata.pubkey)) {
      return;
    }

    let updatedSelectedVouchers = packCreate_objectSpread({}, selectedVouchers);

    if (updatedSelectedVouchers[metadata.pubkey]) {
      delete updatedSelectedVouchers[metadata.pubkey];
    } else {
      updatedSelectedVouchers = {
        [metadata.pubkey]: item
      };
    }

    setPackState({
      selectedVouchers: updatedSelectedVouchers
    });
  }, [setPackState, selectedVouchers]);
  const handleSubmit = (0,external_react_.useCallback)(async () => {
    const canSubmit = wallet && !!Object.values(selectedItems).length && !!Object.values(selectedVouchers).length;

    if (canSubmit) {
      setIsCreating(true);

      try {
        await sendCreatePack({
          wallet,
          connection,
          accountByMint,
          data: attributes
        });
        setShouldShowSuccessModal(true);
      } catch (e) {
        setErrorModal({
          error: e === null || e === void 0 ? void 0 : e.message,
          display: true
        });
      }
    }

    setIsCreating(false);
  }, [wallet, connection, accountByMint, attributes]);
  const handleFinish = (0,external_react_.useCallback)(() => {
    setAttributes(INITIAL_PACK_STATE);
    resetStep();
    setShouldShowSuccessModal(false);
    history.push('/artworks');
  }, []);
  (0,external_react_.useEffect)(() => {
    if (!data) return;
    setPackState({
      uri: data.image,
      name: data.name,
      description: data.description
    });
  }, [data]);
  const shouldRenderSuccessModal = shouldShowSuccessModal && !errorModal.display;
  const shouldRenderRefresh = step === CreatePackSteps.SelectItems || step === CreatePackSteps.SelectVoucher;
  return /*#__PURE__*/(0,jsx_runtime_.jsxs)("div", {
    className: "pack-create-wrapper",
    ref: ref,
    children: [/*#__PURE__*/jsx_runtime_.jsx(components_Sidebar, {
      step: step,
      setStep: goToNextStep,
      isValidStep: isValidStep,
      submit: handleSubmit,
      buttonLoading: isLoading
    }), /*#__PURE__*/(0,jsx_runtime_.jsxs)("div", {
      className: "content-wrapper",
      children: [/*#__PURE__*/jsx_runtime_.jsx(components_Header, {
        step: step,
        children: shouldRenderRefresh && /*#__PURE__*/jsx_runtime_.jsx(external_antd_.Button, {
          onClick: () => pullUserMetadata(userAccounts),
          children: "Refresh"
        })
      }), step === CreatePackSteps.SelectItems && /*#__PURE__*/jsx_runtime_.jsx(components_SelectItemsStep, {
        items: itemsToSelect,
        selectedItems: selectedItems,
        handleSelectItem: handleSelectItem,
        isLoading: isLoading
      }), step === CreatePackSteps.SelectVoucher && /*#__PURE__*/jsx_runtime_.jsx(components_SelectItemsStep, {
        items: vouchersToSelect,
        selectedItems: selectedVouchers,
        handleSelectItem: handleSelectVoucher,
        showSupply: true,
        emptyMessage: "You need to have minted supply of NFT to use it as a voucher."
      }), step === CreatePackSteps.AdjustQuantities && /*#__PURE__*/jsx_runtime_.jsx(components_AdjustQuantitiesStep, {
        allowedAmountToRedeem: allowedAmountToRedeem,
        selectedItems: selectedItems,
        distributionType: distributionType,
        weightByMetadataKey: weightByMetadataKey,
        supplyByMetadataKey: supplyByMetadataKey,
        isUnlimited: isUnlimitedSupply,
        setPackState: setPackState
      }), step === CreatePackSteps.ReviewAndMint && /*#__PURE__*/jsx_runtime_.jsx(components_ReviewAndMintStep, {
        uri: uri,
        name: name,
        description: description,
        distributionType: distributionType,
        allowedAmountToRedeem: allowedAmountToRedeem,
        supplyByMetadataKey: supplyByMetadataKey
      })]
    }), /*#__PURE__*/jsx_runtime_.jsx(components_TransactionErrorModal, {
      open: errorModal.display,
      onDismiss: () => setErrorModal({
        error: '',
        display: false
      }),
      error: errorModal.error
    }), /*#__PURE__*/jsx_runtime_.jsx(components_SuccessModal, {
      shouldShow: shouldRenderSuccessModal,
      hide: handleFinish
    })]
  });
};
;// CONCATENATED MODULE: ./src/views/auction/billing.tsx
function billing_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

function billing_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { billing_ownKeys(Object(source), true).forEach(function (key) { billing_defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { billing_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function billing_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }














const {
  Content: billing_Content
} = external_antd_.Layout;
const BillingView = () => {
  const {
    id
  } = (0,external_react_router_dom_.useParams)();
  const auctionView = useAuction(id);
  const connection = (0,lib.useConnection)();
  const wallet = (0,wallet_adapter_react_.useWallet)();
  const mint = (0,lib.useMint)(auctionView === null || auctionView === void 0 ? void 0 : auctionView.auction.info.tokenMint);
  return auctionView && wallet && connection && mint ? /*#__PURE__*/jsx_runtime_.jsx(InnerBillingView, {
    auctionView: auctionView,
    connection: connection,
    wallet: wallet,
    mint: mint
  }) : /*#__PURE__*/jsx_runtime_.jsx(external_antd_.Spin, {});
};

function getLosingParticipationPrice(el, auctionView) {
  var _auctionView$auctionM, _auctionView$auctionM2, _auctionView$auctionM3;

  const nonWinnerConstraint = (_auctionView$auctionM = auctionView.auctionManager.participationConfig) === null || _auctionView$auctionM === void 0 ? void 0 : _auctionView$auctionM.nonWinningConstraint;
  if (nonWinnerConstraint === metaplex.NonWinningConstraint.GivenForFixedPrice) return ((_auctionView$auctionM2 = auctionView.auctionManager.participationConfig) === null || _auctionView$auctionM2 === void 0 ? void 0 : (_auctionView$auctionM3 = _auctionView$auctionM2.fixedPrice) === null || _auctionView$auctionM3 === void 0 ? void 0 : _auctionView$auctionM3.toNumber()) || 0;else if (nonWinnerConstraint === metaplex.NonWinningConstraint.GivenForBidPrice) return el.info.lastBid.toNumber() || 0;else return 0;
}

function useWinnerPotsByBidderKey(auctionView) {
  const {
    0: pots,
    1: setPots
  } = (0,external_react_.useState)({});
  const PROGRAM_IDS = (0,lib.programIds)();
  const winnersLength = auctionView.auctionManager.numWinners.toNumber();
  const auction = auctionView.auction;
  const winners = auction.info.bidState.bids;
  const truWinners = (0,external_react_.useMemo)(() => {
    return [...winners].reverse().slice(0, winnersLength);
  }, [winners, winnersLength]);
  (0,external_react_.useEffect)(() => {
    (async () => {
      const promises = truWinners.map(winner => (0,lib.getBidderPotKey)({
        auctionProgramId: PROGRAM_IDS.auction,
        auctionKey: auction.pubkey,
        bidderPubkey: winner.key
      }).then(key => ({
        key,
        winner
      })));
      const values = await Promise.all(promises);
      const newPots = values.reduce((agg, value) => {
        const el = lib.cache.get(value.key);

        if (el) {
          agg[value.winner.key] = el;
        }

        return agg;
      }, {});
      setPots(newPots);
    })();
  }, [truWinners, setPots]);
  return pots;
}

function usePayoutTickets(auctionView) {
  const {
    payoutTickets
  } = (0,meta.useMeta)();
  const {
    0: foundPayoutTickets,
    1: setFoundPayoutTickets
  } = (0,external_react_.useState)({});
  (0,external_react_.useEffect)(() => {
    if (auctionView.items.flat().map(i => i.metadata).filter(i => !i).length) {
      return;
    }

    const currFound = billing_objectSpread({}, foundPayoutTickets); // items are in exact order of winningConfigs + order of bid winners
    // when we moved to tiered auctions items will be array of arrays, remember this...
    // this becomes triple loop


    const prizeArrays = [...auctionView.items, ...(auctionView.participationItem ? [[auctionView.participationItem]] : [])];
    const payoutPromises = [];

    for (let i = 0; i < prizeArrays.length; i++) {
      const items = prizeArrays[i];

      for (let j = 0; j < items.length; j++) {
        var _item$metadata, _item$metadata$info, _item$metadata$info$d;

        const item = items[j];
        const creators = ((_item$metadata = item.metadata) === null || _item$metadata === void 0 ? void 0 : (_item$metadata$info = _item$metadata.info) === null || _item$metadata$info === void 0 ? void 0 : (_item$metadata$info$d = _item$metadata$info.data) === null || _item$metadata$info$d === void 0 ? void 0 : _item$metadata$info$d.creators) || [];
        const recipientAddresses = creators ? creators.map(c => c.address).concat([auctionView.auctionManager.authority]) : [auctionView.auctionManager.authority];

        for (let k = 0; k < recipientAddresses.length; k++) {
          // Ensure no clashes with tickets from other safety deposits in other winning configs even if from same creator by making long keys
          const key = `${auctionView.auctionManager.pubkey}-${i}-${j}-${item.safetyDeposit.pubkey}-${recipientAddresses[k]}-${k}`;

          if (!currFound[key]) {
            payoutPromises.push({
              key,
              promise: (0,metaplex.getPayoutTicket)(auctionView.auctionManager.pubkey, item === auctionView.participationItem ? null : i, item === auctionView.participationItem ? null : j, k < recipientAddresses.length - 1 ? k : null, item.safetyDeposit.pubkey, recipientAddresses[k])
            });
          }
        }
      }
    }

    Promise.all(payoutPromises.map(p => p.promise)).then(payoutKeys => {
      payoutKeys.forEach((payoutKey, i) => {
        if (payoutTickets[payoutKey]) currFound[payoutPromises[i].key] = payoutTickets[payoutKey];
      });
      setFoundPayoutTickets(pt => billing_objectSpread(billing_objectSpread({}, pt), currFound));
    });
  }, [Object.values(payoutTickets).length, auctionView.items.flat().map(i => i.metadata).filter(i => !!i).length]);
  return Object.values(foundPayoutTickets).reduce((acc, el) => {
    if (!acc[el.info.recipient]) {
      acc[el.info.recipient] = {
        sum: 0,
        tickets: []
      };
    }

    acc[el.info.recipient].tickets.push(el);
    acc[el.info.recipient].sum += el.info.amountPaid.toNumber();
    return acc;
  }, {});
}

function useBillingInfo({
  auctionView
}) {
  var _auctionView$auctionM4, _auctionView$auctionM5;

  const {
    bidRedemptions,
    bidderMetadataByAuctionAndBidder
  } = (0,meta.useMeta)();
  const auctionKey = auctionView.auction.pubkey;
  const {
    0: participationBidRedemptionKeys,
    1: setParticipationBidRedemptionKeys
  } = (0,external_react_.useState)({});
  const bids = useBidsForAuction(auctionView.auction.pubkey);
  const payoutTickets = usePayoutTickets(auctionView);
  const winners = [...auctionView.auction.info.bidState.bids].reverse().slice(0, auctionView.auctionManager.numWinners.toNumber());
  const winnerPotsByBidderKey = useWinnerPotsByBidderKey(auctionView); // Uncancelled bids or bids that were cancelled for refunds but only after redeemed
  // for participation

  const usableBids = bids.filter(b => {
    var _bidRedemptions$parti, _auctionView$particip;

    return !b.info.cancelled || ((_bidRedemptions$parti = bidRedemptions[participationBidRedemptionKeys[b.pubkey]]) === null || _bidRedemptions$parti === void 0 ? void 0 : _bidRedemptions$parti.info.getBidRedeemed(((_auctionView$particip = auctionView.participationItem) === null || _auctionView$particip === void 0 ? void 0 : _auctionView$particip.safetyDeposit.info.order) || 0));
  });
  const hasParticipation = auctionView.auctionManager.participationConfig !== undefined && auctionView.auctionManager.participationConfig !== null;
  let participationEligible = hasParticipation ? usableBids : [];
  (0,external_react_.useMemo)(async () => {
    const newKeys = {};

    for (let i = 0; i < bids.length; i++) {
      const o = bids[i];

      if (!participationBidRedemptionKeys[o.pubkey]) {
        newKeys[o.pubkey] = (await (0,metaplex.getBidderKeys)(auctionView.auction.pubkey, o.info.bidderPubkey)).bidRedemption;
      }
    }

    setParticipationBidRedemptionKeys(billing_objectSpread(billing_objectSpread({}, participationBidRedemptionKeys), newKeys));
  }, [bids.length]);
  if (((_auctionView$auctionM4 = auctionView.auctionManager.participationConfig) === null || _auctionView$auctionM4 === void 0 ? void 0 : _auctionView$auctionM4.winnerConstraint) === metaplex.WinningConstraint.NoParticipationPrize) // Filter winners out of the open edition eligible
    participationEligible = participationEligible.filter( // winners are stored by pot key, not bidder key, so we translate
    b => !winnerPotsByBidderKey[b.info.bidderPubkey]);
  const nonWinnerConstraint = (_auctionView$auctionM5 = auctionView.auctionManager.participationConfig) === null || _auctionView$auctionM5 === void 0 ? void 0 : _auctionView$auctionM5.nonWinningConstraint;
  const participationEligibleUnredeemable = [];
  participationEligible.forEach(o => {
    const isWinner = winnerPotsByBidderKey[o.info.bidderPubkey]; // Winners automatically pay nothing for open editions, and are getting claimed anyway right now
    // so no need to add them to list

    if (isWinner) {
      return;
    }

    if (nonWinnerConstraint === metaplex.NonWinningConstraint.GivenForFixedPrice || nonWinnerConstraint === metaplex.NonWinningConstraint.GivenForBidPrice) {
      const key = participationBidRedemptionKeys[o.pubkey];

      if (key) {
        var _auctionView$particip2;

        const redemption = bidRedemptions[key];
        if (!redemption || !redemption.info.getBidRedeemed(((_auctionView$particip2 = auctionView.participationItem) === null || _auctionView$particip2 === void 0 ? void 0 : _auctionView$particip2.safetyDeposit.info.order) || 0)) participationEligibleUnredeemable.push(o);
      } else participationEligibleUnredeemable.push(o);
    }
  });
  const participationUnredeemedTotal = participationEligibleUnredeemable.reduce((acc, el) => acc += getLosingParticipationPrice(el, auctionView), 0); // Winners always get it for free so pay zero for them - figure out among all
  // eligible open edition winners what is the total possible for display.

  const participationPossibleTotal = participationEligible.reduce((acc, el) => {
    const isWinner = winnerPotsByBidderKey[el.info.bidderPubkey];
    let price = 0;
    if (!isWinner) price = getLosingParticipationPrice(el, auctionView);
    return acc += price;
  }, 0);
  const totalWinnerPayments = winners.reduce((acc, w) => acc += w.amount.toNumber(), 0);
  const winnersThatCanBeEmptied = Object.values(winnerPotsByBidderKey).filter(p => !p.info.emptied);
  const bidsToClaim = [...winnersThatCanBeEmptied.map(pot => ({
    metadata: bidderMetadataByAuctionAndBidder[`${auctionKey}-${pot.info.bidderAct}`],
    pot
  }))];
  return {
    bidsToClaim,
    totalWinnerPayments,
    payoutTickets,
    participationEligible,
    participationPossibleTotal,
    participationUnredeemedTotal,
    hasParticipation
  };
}
const InnerBillingView = ({
  auctionView,
  wallet,
  connection,
  mint
}) => {
  const id = auctionView.thumbnail.metadata.pubkey;
  const art = useArt(id);
  const balance = useUserBalance(auctionView.auction.info.tokenMint);
  const {
    0: escrowBalance,
    1: setEscrowBalance
  } = (0,external_react_.useState)();
  const {
    whitelistedCreatorsByCreator,
    pullBillingPage
  } = (0,meta.useMeta)();
  (0,external_react_.useEffect)(() => {
    pullBillingPage(id);
  }, []);
  const {
    0: escrowBalanceRefreshCounter,
    1: setEscrowBalanceRefreshCounter
  } = (0,external_react_.useState)(0);
  (0,external_react_.useEffect)(() => {
    connection.getTokenAccountBalance((0,lib.toPublicKey)(auctionView.auctionManager.acceptPayment)).then(resp => {
      if (resp.value.uiAmount !== undefined && resp.value.uiAmount !== null) setEscrowBalance(resp.value.uiAmount);
    });
  }, [escrowBalanceRefreshCounter]);
  const myPayingAccount = balance.accounts[0];
  const {
    accountByMint
  } = (0,lib.useUserAccounts)();
  const {
    bidsToClaim,
    totalWinnerPayments,
    payoutTickets,
    participationPossibleTotal,
    participationUnredeemedTotal,
    hasParticipation
  } = useBillingInfo({
    auctionView
  });
  return /*#__PURE__*/jsx_runtime_.jsx(billing_Content, {
    children: /*#__PURE__*/(0,jsx_runtime_.jsxs)(external_antd_.Col, {
      children: [/*#__PURE__*/(0,jsx_runtime_.jsxs)(external_antd_.Row, {
        style: {
          margin: '0 30px',
          textAlign: 'left',
          fontSize: '1.4rem'
        },
        children: [/*#__PURE__*/jsx_runtime_.jsx(external_antd_.Col, {
          span: 12,
          children: /*#__PURE__*/jsx_runtime_.jsx(ArtContent, {
            pubkey: id,
            className: "artwork-image",
            allowMeshRender: true
          })
        }), /*#__PURE__*/(0,jsx_runtime_.jsxs)(external_antd_.Col, {
          span: 12,
          children: [/*#__PURE__*/jsx_runtime_.jsx("div", {
            style: {
              fontWeight: 700
            },
            children: art.title
          }), /*#__PURE__*/jsx_runtime_.jsx("br", {}), /*#__PURE__*/jsx_runtime_.jsx("div", {
            className: "info-header",
            children: "TOTAL AUCTION VALUE"
          }), /*#__PURE__*/(0,jsx_runtime_.jsxs)("div", {
            className: "escrow",
            children: [auctionView.auctionManager.acceptPayment == lib.WRAPPED_SOL_MINT.toBase58() ? "◎" : "", (0,lib.fromLamports)(totalWinnerPayments + participationPossibleTotal, mint)]
          }), /*#__PURE__*/jsx_runtime_.jsx("br", {}), /*#__PURE__*/jsx_runtime_.jsx("div", {
            className: "info-header",
            children: "TOTAL AUCTION REDEEMED VALUE"
          }), /*#__PURE__*/(0,jsx_runtime_.jsxs)("div", {
            className: "escrow",
            children: [auctionView.auctionManager.acceptPayment == lib.WRAPPED_SOL_MINT.toBase58() ? "◎" : "", (0,lib.fromLamports)(totalWinnerPayments + participationPossibleTotal - participationUnredeemedTotal, mint)]
          }), /*#__PURE__*/jsx_runtime_.jsx("br", {}), /*#__PURE__*/jsx_runtime_.jsx("div", {
            className: "info-header",
            children: "TOTAL COLLECTED BY ARTISTS AND AUCTIONEER"
          }), /*#__PURE__*/(0,jsx_runtime_.jsxs)("div", {
            className: "escrow",
            children: [auctionView.auctionManager.acceptPayment == lib.WRAPPED_SOL_MINT.toBase58() ? "◎" : "", (0,lib.fromLamports)(Object.values(payoutTickets).reduce((acc, el) => acc += el.sum, 0), mint)]
          }), /*#__PURE__*/jsx_runtime_.jsx("br", {}), /*#__PURE__*/jsx_runtime_.jsx("div", {
            className: "info-header",
            children: "TOTAL UNSETTLED"
          }), /*#__PURE__*/(0,jsx_runtime_.jsxs)("div", {
            className: "escrow",
            children: [auctionView.auctionManager.acceptPayment == lib.WRAPPED_SOL_MINT.toBase58() ? "◎" : "", (0,lib.fromLamports)(bidsToClaim.reduce((acc, el) => acc += el.metadata.info.lastBid.toNumber(), 0), mint)]
          }), /*#__PURE__*/jsx_runtime_.jsx("br", {}), /*#__PURE__*/jsx_runtime_.jsx("div", {
            className: "info-header",
            children: "TOTAL IN ESCROW"
          }), /*#__PURE__*/jsx_runtime_.jsx("div", {
            className: "escrow",
            children: escrowBalance !== undefined ? `${auctionView.auction.info.tokenMint == lib.WRAPPED_SOL_MINT.toBase58() ? "◎" : ""} ${escrowBalance}` : /*#__PURE__*/jsx_runtime_.jsx(external_antd_.Spin, {})
          }), /*#__PURE__*/jsx_runtime_.jsx("br", {}), hasParticipation && /*#__PURE__*/(0,jsx_runtime_.jsxs)(jsx_runtime_.Fragment, {
            children: [/*#__PURE__*/jsx_runtime_.jsx("div", {
              className: "info-header",
              children: "TOTAL UNREDEEMED PARTICIPATION FEES OUTSTANDING"
            }), /*#__PURE__*/(0,jsx_runtime_.jsxs)("div", {
              className: "outstanding-open-editions",
              children: [auctionView.auctionManager.acceptPayment == lib.WRAPPED_SOL_MINT.toBase58() ? "◎" : "", (0,lib.fromLamports)(participationUnredeemedTotal, mint)]
            }), /*#__PURE__*/jsx_runtime_.jsx("br", {})]
          }), /*#__PURE__*/jsx_runtime_.jsx("br", {}), /*#__PURE__*/jsx_runtime_.jsx(external_antd_.Button, {
            type: "primary",
            size: "large",
            className: "action-btn",
            onClick: async () => {
              await settle(connection, wallet, auctionView, bidsToClaim.map(b => b.pot), myPayingAccount.pubkey, accountByMint);
              setEscrowBalanceRefreshCounter(ctr => ctr + 1);
            },
            children: "SETTLE OUTSTANDING"
          })]
        })]
      }), /*#__PURE__*/jsx_runtime_.jsx(external_antd_.Row, {
        children: /*#__PURE__*/jsx_runtime_.jsx(external_antd_.Table, {
          style: {
            width: '100%'
          },
          columns: [{
            title: 'Name',
            dataIndex: 'name',
            key: 'name'
          }, {
            title: 'Address',
            dataIndex: 'address',
            key: 'address'
          }, {
            title: 'Amount Paid',
            dataIndex: 'amountPaid',
            render: val => /*#__PURE__*/(0,jsx_runtime_.jsxs)("span", {
              children: ["\u25CE", (0,lib.fromLamports)(val, mint)]
            }),
            key: 'amountPaid'
          }],
          dataSource: Object.keys(payoutTickets).map(t => {
            var _whitelistedCreatorsB, _whitelistedCreatorsB2;

            return {
              key: t,
              name: ((_whitelistedCreatorsB = whitelistedCreatorsByCreator[t]) === null || _whitelistedCreatorsB === void 0 ? void 0 : (_whitelistedCreatorsB2 = _whitelistedCreatorsB.info) === null || _whitelistedCreatorsB2 === void 0 ? void 0 : _whitelistedCreatorsB2.name) || 'N/A',
              address: t,
              amountPaid: payoutTickets[t].sum
            };
          })
        })
      })]
    })
  });
};
;// CONCATENATED MODULE: ./src/routes.tsx











function Routes() {
  const shouldEnableNftPacks = process.env.NEXT_ENABLE_NFT_PACKS === 'true';
  return /*#__PURE__*/jsx_runtime_.jsx(jsx_runtime_.Fragment, {
    children: /*#__PURE__*/jsx_runtime_.jsx(external_react_router_dom_.HashRouter, {
      basename: '/',
      children: /*#__PURE__*/jsx_runtime_.jsx(Providers, {
        children: /*#__PURE__*/(0,jsx_runtime_.jsxs)(external_react_router_dom_.Switch, {
          children: [shouldEnableNftPacks && /*#__PURE__*/jsx_runtime_.jsx(external_react_router_dom_.Route, {
            exact: true,
            path: "/admin/pack/create/:stepParam?",
            component: () => /*#__PURE__*/jsx_runtime_.jsx(PackCreateView, {})
          }), shouldEnableNftPacks && /*#__PURE__*/jsx_runtime_.jsx(external_react_router_dom_.Route, {
            exact: true,
            path: "/pack/:packKey",
            component: () => /*#__PURE__*/jsx_runtime_.jsx(pack, {})
          }), /*#__PURE__*/jsx_runtime_.jsx(external_react_router_dom_.Route, {
            exact: true,
            path: "/admin",
            component: () => /*#__PURE__*/jsx_runtime_.jsx(AdminView, {})
          }), /*#__PURE__*/jsx_runtime_.jsx(external_react_router_dom_.Route, {
            exact: true,
            path: "/analytics",
            component: () => /*#__PURE__*/jsx_runtime_.jsx(AnalyticsView, {})
          }), /*#__PURE__*/jsx_runtime_.jsx(external_react_router_dom_.Route, {
            exact: true,
            path: "/art/create/:step_param?",
            component: () => /*#__PURE__*/jsx_runtime_.jsx(ArtCreateView, {})
          }), /*#__PURE__*/jsx_runtime_.jsx(external_react_router_dom_.Route, {
            exact: true,
            path: "/artworks/:id?",
            component: () => /*#__PURE__*/jsx_runtime_.jsx(ArtworksView, {})
          }), /*#__PURE__*/jsx_runtime_.jsx(external_react_router_dom_.Route, {
            exact: true,
            path: "/art/:id",
            component: () => /*#__PURE__*/jsx_runtime_.jsx(ArtView, {})
          }), /*#__PURE__*/jsx_runtime_.jsx(external_react_router_dom_.Route, {
            exact: true,
            path: "/artists/:id",
            component: () => /*#__PURE__*/jsx_runtime_.jsx(ArtistView, {})
          }), /*#__PURE__*/jsx_runtime_.jsx(external_react_router_dom_.Route, {
            exact: true,
            path: "/artists",
            component: () => /*#__PURE__*/jsx_runtime_.jsx(ArtistsView, {})
          }), /*#__PURE__*/jsx_runtime_.jsx(external_react_router_dom_.Route, {
            exact: true,
            path: "/auction/create/:step_param?",
            component: () => /*#__PURE__*/jsx_runtime_.jsx(AuctionCreateView, {})
          }), /*#__PURE__*/jsx_runtime_.jsx(external_react_router_dom_.Route, {
            exact: true,
            path: "/auction/:id",
            component: () => /*#__PURE__*/jsx_runtime_.jsx(AuctionView, {})
          }), /*#__PURE__*/jsx_runtime_.jsx(external_react_router_dom_.Route, {
            exact: true,
            path: "/auction/:id/billing",
            component: () => /*#__PURE__*/jsx_runtime_.jsx(BillingView, {})
          }), /*#__PURE__*/jsx_runtime_.jsx(external_react_router_dom_.Route, {
            path: "/about",
            component: () => /*#__PURE__*/jsx_runtime_.jsx(StaticPageView, {})
          }), /*#__PURE__*/jsx_runtime_.jsx(external_react_router_dom_.Route, {
            path: "/",
            component: () => /*#__PURE__*/jsx_runtime_.jsx(HomeView, {})
          })]
        })
      })
    })
  });
}
;// CONCATENATED MODULE: ./src/App.tsx

 // import { Routes } from './views/preLaunch/routes'



function App() {
  return /*#__PURE__*/jsx_runtime_.jsx(Routes, {});
}

/* harmony default export */ const src_App = (App);

/***/ }),

/***/ 8839:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.findOrCreateAccountByMint = exports.ensureWrappedAccount = exports.createTokenAccount = exports.createMint = exports.createAssociatedTokenAccountInstruction = exports.createUninitializedAccount = exports.createUninitializedMint = exports.createTempMemoryAccount = exports.DEFAULT_TEMP_MEM_SPACE = exports.ensureSplAccount = void 0;
const spl_token_1 = __webpack_require__(5653);
const web3_js_1 = __webpack_require__(5681);
const ids_1 = __webpack_require__(9556);
const programIds_1 = __webpack_require__(6120);
const cache_1 = __webpack_require__(8883);
const parsesrs_1 = __webpack_require__(7220);
function ensureSplAccount(instructions, cleanupInstructions, toCheck, payer, amount, signers) {
    if (!toCheck.info.isNative) {
        return toCheck.pubkey;
    }
    const account = createUninitializedAccount(instructions, payer, amount, signers);
    instructions.push(spl_token_1.Token.createInitAccountInstruction(ids_1.TOKEN_PROGRAM_ID, ids_1.WRAPPED_SOL_MINT, account, payer));
    cleanupInstructions.push(spl_token_1.Token.createCloseAccountInstruction(ids_1.TOKEN_PROGRAM_ID, account, payer, payer, []));
    return account;
}
exports.ensureSplAccount = ensureSplAccount;
exports.DEFAULT_TEMP_MEM_SPACE = 65548;
function createTempMemoryAccount(instructions, payer, signers, owner, space = exports.DEFAULT_TEMP_MEM_SPACE) {
    const account = web3_js_1.Keypair.generate();
    instructions.push(web3_js_1.SystemProgram.createAccount({
        fromPubkey: payer,
        newAccountPubkey: account.publicKey,
        // 0 will evict/close account since it cannot pay rent
        lamports: 0,
        space: space,
        programId: owner,
    }));
    signers.push(account);
    return account.publicKey;
}
exports.createTempMemoryAccount = createTempMemoryAccount;
function createUninitializedMint(instructions, payer, amount, signers) {
    const account = web3_js_1.Keypair.generate();
    instructions.push(web3_js_1.SystemProgram.createAccount({
        fromPubkey: payer,
        newAccountPubkey: account.publicKey,
        lamports: amount,
        space: spl_token_1.MintLayout.span,
        programId: ids_1.TOKEN_PROGRAM_ID,
    }));
    signers.push(account);
    return account.publicKey;
}
exports.createUninitializedMint = createUninitializedMint;
function createUninitializedAccount(instructions, payer, amount, signers) {
    const account = web3_js_1.Keypair.generate();
    instructions.push(web3_js_1.SystemProgram.createAccount({
        fromPubkey: payer,
        newAccountPubkey: account.publicKey,
        lamports: amount,
        space: spl_token_1.AccountLayout.span,
        programId: ids_1.TOKEN_PROGRAM_ID,
    }));
    signers.push(account);
    return account.publicKey;
}
exports.createUninitializedAccount = createUninitializedAccount;
function createAssociatedTokenAccountInstruction(instructions, associatedTokenAddress, payer, walletAddress, splTokenMintAddress) {
    const keys = [
        {
            pubkey: payer,
            isSigner: true,
            isWritable: true,
        },
        {
            pubkey: associatedTokenAddress,
            isSigner: false,
            isWritable: true,
        },
        {
            pubkey: walletAddress,
            isSigner: false,
            isWritable: false,
        },
        {
            pubkey: splTokenMintAddress,
            isSigner: false,
            isWritable: false,
        },
        {
            pubkey: web3_js_1.SystemProgram.programId,
            isSigner: false,
            isWritable: false,
        },
        {
            pubkey: ids_1.TOKEN_PROGRAM_ID,
            isSigner: false,
            isWritable: false,
        },
        {
            pubkey: web3_js_1.SYSVAR_RENT_PUBKEY,
            isSigner: false,
            isWritable: false,
        },
    ];
    instructions.push(new web3_js_1.TransactionInstruction({
        keys,
        programId: ids_1.SPL_ASSOCIATED_TOKEN_ACCOUNT_PROGRAM_ID,
        data: Buffer.from([]),
    }));
}
exports.createAssociatedTokenAccountInstruction = createAssociatedTokenAccountInstruction;
function createMint(instructions, payer, mintRentExempt, decimals, owner, freezeAuthority, signers) {
    const account = createUninitializedMint(instructions, payer, mintRentExempt, signers);
    instructions.push(spl_token_1.Token.createInitMintInstruction(ids_1.TOKEN_PROGRAM_ID, account, decimals, owner, freezeAuthority));
    return account;
}
exports.createMint = createMint;
function createTokenAccount(instructions, payer, accountRentExempt, mint, owner, signers) {
    const account = createUninitializedAccount(instructions, payer, accountRentExempt, signers);
    instructions.push(spl_token_1.Token.createInitAccountInstruction(ids_1.TOKEN_PROGRAM_ID, mint, account, owner));
    return account;
}
exports.createTokenAccount = createTokenAccount;
function ensureWrappedAccount(instructions, cleanupInstructions, toCheck, payer, amount, signers) {
    if (toCheck && !toCheck.info.isNative) {
        return toCheck.pubkey;
    }
    const TOKEN_PROGRAM_ID = (0, programIds_1.programIds)().token;
    const account = web3_js_1.Keypair.generate();
    instructions.push(web3_js_1.SystemProgram.createAccount({
        fromPubkey: payer,
        newAccountPubkey: account.publicKey,
        lamports: amount,
        space: spl_token_1.AccountLayout.span,
        programId: TOKEN_PROGRAM_ID,
    }));
    instructions.push(spl_token_1.Token.createInitAccountInstruction(TOKEN_PROGRAM_ID, ids_1.WRAPPED_SOL_MINT, account.publicKey, payer));
    cleanupInstructions.push(spl_token_1.Token.createCloseAccountInstruction(TOKEN_PROGRAM_ID, account.publicKey, payer, payer, []));
    signers.push(account);
    return account.publicKey.toBase58();
}
exports.ensureWrappedAccount = ensureWrappedAccount;
// TODO: check if one of to accounts needs to be native sol ... if yes unwrap it ...
function findOrCreateAccountByMint(payer, owner, instructions, cleanupInstructions, accountRentExempt, mint, // use to identify same type
signers, excluded) {
    const accountToFind = mint.toBase58();
    const ownerKey = owner.toBase58();
    const account = cache_1.cache
        .byParser(parsesrs_1.TokenAccountParser)
        .map(id => cache_1.cache.get(id))
        .find(acc => acc !== undefined &&
        acc.info.mint.toBase58() === accountToFind &&
        acc.info.owner.toBase58() === ownerKey &&
        (excluded === undefined || !excluded.has(acc.pubkey)));
    const isWrappedSol = accountToFind === ids_1.WRAPPED_SOL_MINT.toBase58();
    let toAccount;
    if (account && !isWrappedSol) {
        toAccount = new web3_js_1.PublicKey(account.pubkey);
    }
    else {
        // creating depositor pool account
        toAccount = createTokenAccount(instructions, payer, accountRentExempt, mint, owner, signers);
        if (isWrappedSol) {
            cleanupInstructions.push(spl_token_1.Token.createCloseAccountInstruction(ids_1.TOKEN_PROGRAM_ID, toAccount, payer, payer, []));
        }
    }
    return toAccount;
}
exports.findOrCreateAccountByMint = findOrCreateAccountByMint;
//# sourceMappingURL=account.js.map

/***/ }),

/***/ 4400:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.cancelBid = exports.getAuctionExtended = exports.getBidderPotKey = exports.placeBid = exports.setAuctionAuthority = exports.startAuctionWithResource = exports.createAuction = exports.decodeAuctionData = exports.AUCTION_SCHEMA = exports.CreateAuctionArgs = exports.WinnerLimit = exports.WinnerLimitType = exports.BidderPot = exports.BIDDER_POT_LEN = exports.BidderMetadata = exports.BIDDER_METADATA_LEN = exports.AuctionData = exports.AuctionDataExtended = exports.PriceFloor = exports.PriceFloorType = exports.BASE_AUCTION_DATA_SIZE = exports.decodeBidderMetadata = exports.BidderMetadataParser = exports.decodeAuctionDataExtended = exports.AuctionDataExtendedParser = exports.decodeBidderPot = exports.BidderPotParser = exports.decodeAuction = exports.AuctionParser = exports.BidState = exports.Bid = exports.BidStateType = exports.AuctionState = exports.MAX_AUCTION_DATA_EXTENDED_SIZE = exports.BIDDER_POT_TOKEN = exports.EXTENDED = exports.METADATA = exports.AUCTION_PREFIX = void 0;
const web3_js_1 = __webpack_require__(5681);
const programIds_1 = __webpack_require__(6120);
const borsh_1 = __webpack_require__(7384);
const bn_js_1 = __importDefault(__webpack_require__(4894));
const moment_1 = __importDefault(__webpack_require__(2470));
const utils_1 = __webpack_require__(398);
exports.AUCTION_PREFIX = 'auction';
exports.METADATA = 'metadata';
exports.EXTENDED = 'extended';
exports.BIDDER_POT_TOKEN = 'bidder_pot_token';
exports.MAX_AUCTION_DATA_EXTENDED_SIZE = 8 + 9 + 2 + 9 + 33 + 158;
var AuctionState;
(function (AuctionState) {
    AuctionState[AuctionState["Created"] = 0] = "Created";
    AuctionState[AuctionState["Started"] = 1] = "Started";
    AuctionState[AuctionState["Ended"] = 2] = "Ended";
})(AuctionState = exports.AuctionState || (exports.AuctionState = {}));
var BidStateType;
(function (BidStateType) {
    BidStateType[BidStateType["EnglishAuction"] = 0] = "EnglishAuction";
    BidStateType[BidStateType["OpenEdition"] = 1] = "OpenEdition";
})(BidStateType = exports.BidStateType || (exports.BidStateType = {}));
class Bid {
    constructor(args) {
        this.key = args.key;
        this.amount = args.amount;
    }
}
exports.Bid = Bid;
class BidState {
    constructor(args) {
        this.type = args.type;
        this.bids = args.bids;
        this.max = args.max;
    }
    getWinnerAt(winnerIndex) {
        const convertedIndex = this.bids.length - winnerIndex - 1;
        if (convertedIndex >= 0 && convertedIndex < this.bids.length) {
            return this.bids[convertedIndex].key;
        }
        else {
            return null;
        }
    }
    getAmountAt(winnerIndex) {
        const convertedIndex = this.bids.length - winnerIndex - 1;
        if (convertedIndex >= 0 && convertedIndex < this.bids.length) {
            return this.bids[convertedIndex].amount;
        }
        else {
            return null;
        }
    }
    getWinnerIndex(bidder) {
        if (!this.bids)
            return null;
        const index = this.bids.findIndex(b => b.key === bidder);
        // auction stores data in reverse order
        if (index !== -1) {
            const zeroBased = this.bids.length - index - 1;
            return zeroBased < this.max.toNumber() ? zeroBased : null;
        }
        else
            return null;
    }
}
exports.BidState = BidState;
const AuctionParser = (pubkey, account) => ({
    pubkey,
    account,
    info: (0, exports.decodeAuction)(account.data),
});
exports.AuctionParser = AuctionParser;
const decodeAuction = (buffer) => {
    return (0, borsh_1.deserializeUnchecked)(exports.AUCTION_SCHEMA, AuctionData, buffer);
};
exports.decodeAuction = decodeAuction;
const BidderPotParser = (pubkey, account) => ({
    pubkey,
    account,
    info: (0, exports.decodeBidderPot)(account.data),
});
exports.BidderPotParser = BidderPotParser;
const decodeBidderPot = (buffer) => {
    return (0, borsh_1.deserializeUnchecked)(exports.AUCTION_SCHEMA, BidderPot, buffer);
};
exports.decodeBidderPot = decodeBidderPot;
const AuctionDataExtendedParser = (pubkey, account) => ({
    pubkey,
    account,
    info: (0, exports.decodeAuctionDataExtended)(account.data),
});
exports.AuctionDataExtendedParser = AuctionDataExtendedParser;
const decodeAuctionDataExtended = (buffer) => {
    return (0, borsh_1.deserializeUnchecked)(exports.AUCTION_SCHEMA, AuctionDataExtended, buffer);
};
exports.decodeAuctionDataExtended = decodeAuctionDataExtended;
const BidderMetadataParser = (pubkey, account) => ({
    pubkey,
    account,
    info: (0, exports.decodeBidderMetadata)(account.data),
});
exports.BidderMetadataParser = BidderMetadataParser;
const decodeBidderMetadata = (buffer) => {
    return (0, borsh_1.deserializeUnchecked)(exports.AUCTION_SCHEMA, BidderMetadata, buffer);
};
exports.decodeBidderMetadata = decodeBidderMetadata;
exports.BASE_AUCTION_DATA_SIZE = 32 + 32 + 32 + 9 + 9 + 9 + 9 + 1 + 32 + 1 + 8 + 8;
var PriceFloorType;
(function (PriceFloorType) {
    PriceFloorType[PriceFloorType["None"] = 0] = "None";
    PriceFloorType[PriceFloorType["Minimum"] = 1] = "Minimum";
    PriceFloorType[PriceFloorType["BlindedPrice"] = 2] = "BlindedPrice";
})(PriceFloorType = exports.PriceFloorType || (exports.PriceFloorType = {}));
class PriceFloor {
    constructor(args) {
        this.type = args.type;
        this.hash = args.hash || new Uint8Array(32);
        if (this.type === PriceFloorType.Minimum) {
            if (args.minPrice) {
                this.hash.set(args.minPrice.toArrayLike(Buffer, 'le', 8), 0);
            }
            else {
                this.minPrice = new bn_js_1.default((args.hash || new Uint8Array(0)).slice(0, 8), 'le');
            }
        }
    }
}
exports.PriceFloor = PriceFloor;
class AuctionDataExtended {
    constructor(args) {
        this.totalUncancelledBids = args.totalUncancelledBids;
        this.tickSize = args.tickSize;
        this.gapTickSizePercentage = args.gapTickSizePercentage;
        this.instantSalePrice = args.instantSalePrice;
        this.name = args.name;
    }
}
exports.AuctionDataExtended = AuctionDataExtended;
class AuctionData {
    constructor(args) {
        this.authority = args.authority;
        this.tokenMint = args.tokenMint;
        this.lastBid = args.lastBid;
        this.endedAt = args.endedAt;
        this.endAuctionAt = args.endAuctionAt;
        this.auctionGap = args.auctionGap;
        this.priceFloor = args.priceFloor;
        this.state = args.state;
        this.bidState = args.bidState;
    }
    timeToEnd() {
        var _a;
        const now = (0, moment_1.default)().unix();
        const ended = { days: 0, hours: 0, minutes: 0, seconds: 0 };
        let endAt = ((_a = this.endedAt) === null || _a === void 0 ? void 0 : _a.toNumber()) || 0;
        if (this.auctionGap && this.lastBid) {
            endAt = Math.max(endAt, this.auctionGap.toNumber() + this.lastBid.toNumber());
        }
        let delta = endAt - now;
        if (!endAt || delta <= 0)
            return ended;
        const days = Math.floor(delta / 86400);
        delta -= days * 86400;
        const hours = Math.floor(delta / 3600) % 24;
        delta -= hours * 3600;
        const minutes = Math.floor(delta / 60) % 60;
        delta -= minutes * 60;
        const seconds = Math.floor(delta % 60);
        return { days, hours, minutes, seconds };
    }
    ended() {
        const now = (0, moment_1.default)().unix();
        if (!this.endedAt)
            return false;
        if (this.endedAt.toNumber() > now)
            return false;
        if (this.endedAt.toNumber() < now) {
            if (this.auctionGap && this.lastBid) {
                const newEnding = this.auctionGap.toNumber() + this.lastBid.toNumber();
                return newEnding < now;
            }
            else
                return true;
        }
    }
}
exports.AuctionData = AuctionData;
exports.BIDDER_METADATA_LEN = 32 + 32 + 8 + 8 + 1;
class BidderMetadata {
    constructor(args) {
        this.bidderPubkey = args.bidderPubkey;
        this.auctionPubkey = args.auctionPubkey;
        this.lastBid = args.lastBid;
        this.lastBidTimestamp = args.lastBidTimestamp;
        this.cancelled = args.cancelled;
    }
}
exports.BidderMetadata = BidderMetadata;
exports.BIDDER_POT_LEN = 32 + 32 + 32 + 1;
class BidderPot {
    constructor(args) {
        this.bidderPot = args.bidderPot;
        this.bidderAct = args.bidderAct;
        this.auctionAct = args.auctionAct;
        this.emptied = args.emptied;
    }
}
exports.BidderPot = BidderPot;
var WinnerLimitType;
(function (WinnerLimitType) {
    WinnerLimitType[WinnerLimitType["Unlimited"] = 0] = "Unlimited";
    WinnerLimitType[WinnerLimitType["Capped"] = 1] = "Capped";
})(WinnerLimitType = exports.WinnerLimitType || (exports.WinnerLimitType = {}));
class WinnerLimit {
    constructor(args) {
        this.type = args.type;
        this.usize = args.usize;
    }
}
exports.WinnerLimit = WinnerLimit;
class CreateAuctionArgs {
    constructor(args) {
        this.instruction = 7;
        this.winners = args.winners;
        this.endAuctionAt = args.endAuctionAt;
        this.auctionGap = args.auctionGap;
        this.tokenMint = args.tokenMint;
        this.authority = args.authority;
        this.resource = args.resource;
        this.priceFloor = args.priceFloor;
        this.tickSize = args.tickSize;
        this.gapTickSizePercentage = args.gapTickSizePercentage;
        this.name = args.name;
        this.instantSalePrice = args.instantSalePrice;
    }
}
exports.CreateAuctionArgs = CreateAuctionArgs;
class StartAuctionArgs {
    constructor(args) {
        this.instruction = 4;
        this.resource = args.resource;
    }
}
class PlaceBidArgs {
    constructor(args) {
        this.instruction = 6;
        this.resource = args.resource;
        this.amount = args.amount;
    }
}
class CancelBidArgs {
    constructor(args) {
        this.instruction = 0;
        this.resource = args.resource;
    }
}
class SetAuthorityArgs {
    constructor() {
        this.instruction = 5;
    }
}
exports.AUCTION_SCHEMA = new Map([
    [
        CreateAuctionArgs,
        {
            kind: 'struct',
            fields: [
                ['instruction', 'u8'],
                ['winners', WinnerLimit],
                ['endAuctionAt', { kind: 'option', type: 'u64' }],
                ['auctionGap', { kind: 'option', type: 'u64' }],
                ['tokenMint', 'pubkeyAsString'],
                ['authority', 'pubkeyAsString'],
                ['resource', 'pubkeyAsString'],
                ['priceFloor', PriceFloor],
                ['tickSize', { kind: 'option', type: 'u64' }],
                ['gapTickSizePercentage', { kind: 'option', type: 'u8' }],
                ['instantSalePrice', { kind: 'option', type: 'u64' }],
                ['name', { kind: 'option', type: [32] }],
            ],
        },
    ],
    [
        WinnerLimit,
        {
            kind: 'struct',
            fields: [
                ['type', 'u8'],
                ['usize', 'u64'],
            ],
        },
    ],
    [
        StartAuctionArgs,
        {
            kind: 'struct',
            fields: [
                ['instruction', 'u8'],
                ['resource', 'pubkeyAsString'],
            ],
        },
    ],
    [
        PlaceBidArgs,
        {
            kind: 'struct',
            fields: [
                ['instruction', 'u8'],
                ['amount', 'u64'],
                ['resource', 'pubkeyAsString'],
            ],
        },
    ],
    [
        CancelBidArgs,
        {
            kind: 'struct',
            fields: [
                ['instruction', 'u8'],
                ['resource', 'pubkeyAsString'],
            ],
        },
    ],
    [
        SetAuthorityArgs,
        {
            kind: 'struct',
            fields: [['instruction', 'u8']],
        },
    ],
    [
        AuctionData,
        {
            kind: 'struct',
            fields: [
                ['authority', 'pubkeyAsString'],
                ['tokenMint', 'pubkeyAsString'],
                ['lastBid', { kind: 'option', type: 'u64' }],
                ['endedAt', { kind: 'option', type: 'u64' }],
                ['endAuctionAt', { kind: 'option', type: 'u64' }],
                ['auctionGap', { kind: 'option', type: 'u64' }],
                ['priceFloor', PriceFloor],
                ['state', 'u8'],
                ['bidState', BidState],
            ],
        },
    ],
    [
        AuctionDataExtended,
        {
            kind: 'struct',
            fields: [
                ['totalUncancelledBids', 'u64'],
                ['tickSize', { kind: 'option', type: 'u64' }],
                ['gapTickSizePercentage', { kind: 'option', type: 'u8' }],
                ['instantSalePrice', { kind: 'option', type: 'u64' }],
                ['name', { kind: 'option', type: [32] }],
            ],
        },
    ],
    [
        PriceFloor,
        {
            kind: 'struct',
            fields: [
                ['type', 'u8'],
                ['hash', [32]],
            ],
        },
    ],
    [
        BidState,
        {
            kind: 'struct',
            fields: [
                ['type', 'u8'],
                ['bids', [Bid]],
                ['max', 'u64'],
            ],
        },
    ],
    [
        Bid,
        {
            kind: 'struct',
            fields: [
                ['key', 'pubkeyAsString'],
                ['amount', 'u64'],
            ],
        },
    ],
    [
        BidderMetadata,
        {
            kind: 'struct',
            fields: [
                ['bidderPubkey', 'pubkeyAsString'],
                ['auctionPubkey', 'pubkeyAsString'],
                ['lastBid', 'u64'],
                ['lastBidTimestamp', 'u64'],
                ['cancelled', 'u8'],
            ],
        },
    ],
    [
        BidderPot,
        {
            kind: 'struct',
            fields: [
                ['bidderPot', 'pubkeyAsString'],
                ['bidderAct', 'pubkeyAsString'],
                ['auctionAct', 'pubkeyAsString'],
                ['emptied', 'u8'],
            ],
        },
    ],
]);
const decodeAuctionData = (buffer) => {
    return (0, borsh_1.deserializeUnchecked)(exports.AUCTION_SCHEMA, AuctionData, buffer);
};
exports.decodeAuctionData = decodeAuctionData;
async function createAuction(settings, creator, instructions) {
    const auctionProgramId = (0, programIds_1.programIds)().auction;
    const data = Buffer.from((0, borsh_1.serialize)(exports.AUCTION_SCHEMA, settings));
    const auctionKey = (await (0, utils_1.findProgramAddress)([
        Buffer.from(exports.AUCTION_PREFIX),
        (0, utils_1.toPublicKey)(auctionProgramId).toBuffer(),
        (0, utils_1.toPublicKey)(settings.resource).toBuffer(),
    ], (0, utils_1.toPublicKey)(auctionProgramId)))[0];
    const keys = [
        {
            pubkey: (0, utils_1.toPublicKey)(creator),
            isSigner: true,
            isWritable: true,
        },
        {
            pubkey: (0, utils_1.toPublicKey)(auctionKey),
            isSigner: false,
            isWritable: true,
        },
        {
            pubkey: (0, utils_1.toPublicKey)(await getAuctionExtended({
                auctionProgramId,
                resource: settings.resource,
            })),
            isSigner: false,
            isWritable: true,
        },
        {
            pubkey: web3_js_1.SYSVAR_RENT_PUBKEY,
            isSigner: false,
            isWritable: false,
        },
        {
            pubkey: web3_js_1.SystemProgram.programId,
            isSigner: false,
            isWritable: false,
        },
    ];
    instructions.push(new web3_js_1.TransactionInstruction({
        keys,
        programId: (0, utils_1.toPublicKey)(auctionProgramId),
        data: data,
    }));
}
exports.createAuction = createAuction;
async function startAuctionWithResource(resource, creator, instructions) {
    const auctionProgramId = (0, programIds_1.programIds)().auction;
    const data = Buffer.from((0, borsh_1.serialize)(exports.AUCTION_SCHEMA, new StartAuctionArgs({
        resource,
    })));
    const auctionKey = (await (0, utils_1.findProgramAddress)([
        Buffer.from(exports.AUCTION_PREFIX),
        (0, utils_1.toPublicKey)(auctionProgramId).toBuffer(),
        (0, utils_1.toPublicKey)(resource).toBuffer(),
    ], (0, utils_1.toPublicKey)(auctionProgramId)))[0];
    const keys = [
        {
            pubkey: (0, utils_1.toPublicKey)(creator),
            isSigner: false,
            isWritable: true,
        },
        {
            pubkey: (0, utils_1.toPublicKey)(auctionKey),
            isSigner: false,
            isWritable: true,
        },
        {
            pubkey: web3_js_1.SYSVAR_CLOCK_PUBKEY,
            isSigner: false,
            isWritable: false,
        },
    ];
    instructions.push(new web3_js_1.TransactionInstruction({
        keys,
        programId: (0, utils_1.toPublicKey)(auctionProgramId),
        data: data,
    }));
}
exports.startAuctionWithResource = startAuctionWithResource;
async function setAuctionAuthority(auction, currentAuthority, newAuthority, instructions) {
    const auctionProgramId = (0, programIds_1.programIds)().auction;
    const data = Buffer.from((0, borsh_1.serialize)(exports.AUCTION_SCHEMA, new SetAuthorityArgs()));
    const keys = [
        {
            pubkey: (0, utils_1.toPublicKey)(auction),
            isSigner: false,
            isWritable: true,
        },
        {
            pubkey: (0, utils_1.toPublicKey)(currentAuthority),
            isSigner: true,
            isWritable: false,
        },
        {
            pubkey: (0, utils_1.toPublicKey)(newAuthority),
            isSigner: false,
            isWritable: false,
        },
    ];
    instructions.push(new web3_js_1.TransactionInstruction({
        keys,
        programId: (0, utils_1.toPublicKey)(auctionProgramId),
        data: data,
    }));
}
exports.setAuctionAuthority = setAuctionAuthority;
async function placeBid(bidderPubkey, bidderTokenPubkey, bidderPotTokenPubkey, tokenMintPubkey, transferAuthority, payer, resource, amount, instructions) {
    const auctionProgramId = (0, programIds_1.programIds)().auction;
    const data = Buffer.from((0, borsh_1.serialize)(exports.AUCTION_SCHEMA, new PlaceBidArgs({
        resource,
        amount,
    })));
    const auctionKey = (await (0, utils_1.findProgramAddress)([
        Buffer.from(exports.AUCTION_PREFIX),
        (0, utils_1.toPublicKey)(auctionProgramId).toBuffer(),
        (0, utils_1.toPublicKey)(resource).toBuffer(),
    ], (0, utils_1.toPublicKey)(auctionProgramId)))[0];
    const bidderPotKey = await getBidderPotKey({
        auctionProgramId,
        auctionKey,
        bidderPubkey,
    });
    const bidderMetaKey = (await (0, utils_1.findProgramAddress)([
        Buffer.from(exports.AUCTION_PREFIX),
        (0, utils_1.toPublicKey)(auctionProgramId).toBuffer(),
        (0, utils_1.toPublicKey)(auctionKey).toBuffer(),
        (0, utils_1.toPublicKey)(bidderPubkey).toBuffer(),
        Buffer.from('metadata'),
    ], (0, utils_1.toPublicKey)(auctionProgramId)))[0];
    let bidderPotTokenAccount;
    if (!bidderPotTokenPubkey) {
        bidderPotTokenAccount = (0, utils_1.toPublicKey)((await (0, utils_1.findProgramAddress)([
            Buffer.from(exports.AUCTION_PREFIX),
            (0, utils_1.toPublicKey)(bidderPotKey).toBuffer(),
            Buffer.from(exports.BIDDER_POT_TOKEN),
        ], (0, utils_1.toPublicKey)(auctionProgramId)))[0]);
    }
    else {
        bidderPotTokenAccount = (0, utils_1.toPublicKey)(bidderPotTokenPubkey);
    }
    const keys = [
        {
            pubkey: (0, utils_1.toPublicKey)(bidderPubkey),
            isSigner: true,
            isWritable: false,
        },
        {
            pubkey: (0, utils_1.toPublicKey)(bidderTokenPubkey),
            isSigner: false,
            isWritable: true,
        },
        {
            pubkey: (0, utils_1.toPublicKey)(bidderPotKey),
            isSigner: false,
            isWritable: true,
        },
        {
            pubkey: bidderPotTokenAccount,
            isSigner: false,
            isWritable: true,
        },
        {
            pubkey: (0, utils_1.toPublicKey)(bidderMetaKey),
            isSigner: false,
            isWritable: true,
        },
        {
            pubkey: (0, utils_1.toPublicKey)(auctionKey),
            isSigner: false,
            isWritable: true,
        },
        {
            pubkey: (0, utils_1.toPublicKey)(await getAuctionExtended({ auctionProgramId, resource })),
            isSigner: false,
            isWritable: true,
        },
        {
            pubkey: (0, utils_1.toPublicKey)(tokenMintPubkey),
            isSigner: false,
            isWritable: true,
        },
        {
            pubkey: (0, utils_1.toPublicKey)(transferAuthority),
            isSigner: true,
            isWritable: false,
        },
        {
            pubkey: (0, utils_1.toPublicKey)(payer),
            isSigner: true,
            isWritable: false,
        },
        {
            pubkey: web3_js_1.SYSVAR_CLOCK_PUBKEY,
            isSigner: false,
            isWritable: false,
        },
        {
            pubkey: web3_js_1.SYSVAR_RENT_PUBKEY,
            isSigner: false,
            isWritable: false,
        },
        {
            pubkey: web3_js_1.SystemProgram.programId,
            isSigner: false,
            isWritable: false,
        },
        {
            pubkey: (0, programIds_1.programIds)().token,
            isSigner: false,
            isWritable: false,
        },
    ];
    instructions.push(new web3_js_1.TransactionInstruction({
        keys,
        programId: (0, utils_1.toPublicKey)(auctionProgramId),
        data: data,
    }));
    return {
        amount,
    };
}
exports.placeBid = placeBid;
async function getBidderPotKey({ auctionProgramId, auctionKey, bidderPubkey, }) {
    return (await (0, utils_1.findProgramAddress)([
        Buffer.from(exports.AUCTION_PREFIX),
        (0, utils_1.toPublicKey)(auctionProgramId).toBuffer(),
        (0, utils_1.toPublicKey)(auctionKey).toBuffer(),
        (0, utils_1.toPublicKey)(bidderPubkey).toBuffer(),
    ], (0, utils_1.toPublicKey)(auctionProgramId)))[0];
}
exports.getBidderPotKey = getBidderPotKey;
async function getAuctionExtended({ auctionProgramId, resource, }) {
    return (await (0, utils_1.findProgramAddress)([
        Buffer.from(exports.AUCTION_PREFIX),
        (0, utils_1.toPublicKey)(auctionProgramId).toBuffer(),
        (0, utils_1.toPublicKey)(resource).toBuffer(),
        Buffer.from(exports.EXTENDED),
    ], (0, utils_1.toPublicKey)(auctionProgramId)))[0];
}
exports.getAuctionExtended = getAuctionExtended;
async function cancelBid(bidderPubkey, bidderTokenPubkey, bidderPotTokenPubkey, tokenMintPubkey, resource, instructions) {
    const auctionProgramId = (0, programIds_1.programIds)().auction;
    const data = Buffer.from((0, borsh_1.serialize)(exports.AUCTION_SCHEMA, new CancelBidArgs({
        resource,
    })));
    const auctionKey = (await (0, utils_1.findProgramAddress)([
        Buffer.from(exports.AUCTION_PREFIX),
        (0, utils_1.toPublicKey)(auctionProgramId).toBuffer(),
        (0, utils_1.toPublicKey)(resource).toBuffer(),
    ], (0, utils_1.toPublicKey)(auctionProgramId)))[0];
    const bidderPotKey = await getBidderPotKey({
        auctionProgramId,
        auctionKey,
        bidderPubkey,
    });
    const bidderMetaKey = (await (0, utils_1.findProgramAddress)([
        Buffer.from(exports.AUCTION_PREFIX),
        (0, utils_1.toPublicKey)(auctionProgramId).toBuffer(),
        (0, utils_1.toPublicKey)(auctionKey).toBuffer(),
        (0, utils_1.toPublicKey)(bidderPubkey).toBuffer(),
        Buffer.from('metadata'),
    ], (0, utils_1.toPublicKey)(auctionProgramId)))[0];
    const keys = [
        {
            pubkey: (0, utils_1.toPublicKey)(bidderPubkey),
            isSigner: true,
            isWritable: false,
        },
        {
            pubkey: (0, utils_1.toPublicKey)(bidderTokenPubkey),
            isSigner: false,
            isWritable: true,
        },
        {
            pubkey: (0, utils_1.toPublicKey)(bidderPotKey),
            isSigner: false,
            isWritable: true,
        },
        {
            pubkey: (0, utils_1.toPublicKey)(bidderPotTokenPubkey),
            isSigner: false,
            isWritable: true,
        },
        {
            pubkey: (0, utils_1.toPublicKey)(bidderMetaKey),
            isSigner: false,
            isWritable: true,
        },
        {
            pubkey: (0, utils_1.toPublicKey)(auctionKey),
            isSigner: false,
            isWritable: true,
        },
        {
            pubkey: (0, utils_1.toPublicKey)(await getAuctionExtended({ auctionProgramId, resource })),
            isSigner: false,
            isWritable: true,
        },
        {
            pubkey: (0, utils_1.toPublicKey)(tokenMintPubkey),
            isSigner: false,
            isWritable: true,
        },
        {
            pubkey: web3_js_1.SYSVAR_CLOCK_PUBKEY,
            isSigner: false,
            isWritable: false,
        },
        {
            pubkey: web3_js_1.SYSVAR_RENT_PUBKEY,
            isSigner: false,
            isWritable: false,
        },
        {
            pubkey: web3_js_1.SystemProgram.programId,
            isSigner: false,
            isWritable: false,
        },
        {
            pubkey: (0, programIds_1.programIds)().token,
            isSigner: false,
            isWritable: false,
        },
    ];
    instructions.push(new web3_js_1.TransactionInstruction({
        keys,
        programId: (0, utils_1.toPublicKey)(auctionProgramId),
        data: data,
    }));
}
exports.cancelBid = cancelBid;
//# sourceMappingURL=auction.js.map

/***/ }),

/***/ 6618:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
__exportStar(__webpack_require__(8839), exports);
__exportStar(__webpack_require__(4215), exports);
__exportStar(__webpack_require__(5620), exports);
__exportStar(__webpack_require__(4400), exports);
__exportStar(__webpack_require__(1559), exports);
//# sourceMappingURL=index.js.map

/***/ }),

/***/ 4215:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.getEditionMarkPda = exports.deprecatedGetReservationList = exports.getMetadata = exports.getEdition = exports.convertMasterEditionV1ToV2 = exports.deprecatedMintPrintingTokens = exports.signMetadata = exports.deprecatedCreateReservationList = exports.updatePrimarySaleHappenedViaToken = exports.mintNewEditionFromMasterEditionViaToken = exports.deprecatedMintNewEditionFromMasterEditionViaPrintingToken = exports.createMasterEdition = exports.createMetadata = exports.updateMetadata = exports.decodeMasterEdition = exports.decodeEdition = exports.decodeEditionMarker = exports.decodeMetadata = exports.METADATA_SCHEMA = exports.Metadata = exports.Data = exports.Creator = exports.Edition = exports.EditionMarker = exports.MasterEditionV2 = exports.MasterEditionV1 = exports.MetadataCategory = exports.MetadataKey = exports.EDITION_MARKER_BIT_SIZE = exports.MAX_EDITION_LEN = exports.MAX_METADATA_LEN = exports.MAX_CREATOR_LEN = exports.MAX_CREATOR_LIMIT = exports.MAX_URI_LENGTH = exports.MAX_SYMBOL_LENGTH = exports.MAX_NAME_LENGTH = exports.RESERVATION = exports.EDITION = exports.METADATA_PREFIX = void 0;
const web3_js_1 = __webpack_require__(5681);
const programIds_1 = __webpack_require__(6120);
const borsh_1 = __webpack_require__(7384);
const utils_1 = __webpack_require__(398);
exports.METADATA_PREFIX = 'metadata';
exports.EDITION = 'edition';
exports.RESERVATION = 'reservation';
exports.MAX_NAME_LENGTH = 32;
exports.MAX_SYMBOL_LENGTH = 10;
exports.MAX_URI_LENGTH = 200;
exports.MAX_CREATOR_LIMIT = 5;
exports.MAX_CREATOR_LEN = 32 + 1 + 1;
exports.MAX_METADATA_LEN = 1 +
    32 +
    32 +
    exports.MAX_NAME_LENGTH +
    exports.MAX_SYMBOL_LENGTH +
    exports.MAX_URI_LENGTH +
    exports.MAX_CREATOR_LIMIT * exports.MAX_CREATOR_LEN +
    2 +
    1 +
    1 +
    198;
exports.MAX_EDITION_LEN = 1 + 32 + 8 + 200;
exports.EDITION_MARKER_BIT_SIZE = 248;
var MetadataKey;
(function (MetadataKey) {
    MetadataKey[MetadataKey["Uninitialized"] = 0] = "Uninitialized";
    MetadataKey[MetadataKey["MetadataV1"] = 4] = "MetadataV1";
    MetadataKey[MetadataKey["EditionV1"] = 1] = "EditionV1";
    MetadataKey[MetadataKey["MasterEditionV1"] = 2] = "MasterEditionV1";
    MetadataKey[MetadataKey["MasterEditionV2"] = 6] = "MasterEditionV2";
    MetadataKey[MetadataKey["EditionMarker"] = 7] = "EditionMarker";
})(MetadataKey = exports.MetadataKey || (exports.MetadataKey = {}));
var MetadataCategory;
(function (MetadataCategory) {
    MetadataCategory["Audio"] = "audio";
    MetadataCategory["Video"] = "video";
    MetadataCategory["Image"] = "image";
    MetadataCategory["VR"] = "vr";
    MetadataCategory["HTML"] = "html";
})(MetadataCategory = exports.MetadataCategory || (exports.MetadataCategory = {}));
class MasterEditionV1 {
    constructor(args) {
        this.key = MetadataKey.MasterEditionV1;
        this.supply = args.supply;
        this.maxSupply = args.maxSupply;
        this.printingMint = args.printingMint;
        this.oneTimePrintingAuthorizationMint =
            args.oneTimePrintingAuthorizationMint;
    }
}
exports.MasterEditionV1 = MasterEditionV1;
class MasterEditionV2 {
    constructor(args) {
        this.key = MetadataKey.MasterEditionV2;
        this.supply = args.supply;
        this.maxSupply = args.maxSupply;
    }
}
exports.MasterEditionV2 = MasterEditionV2;
class EditionMarker {
    constructor(args) {
        this.key = MetadataKey.EditionMarker;
        this.ledger = args.ledger;
    }
    editionTaken(edition) {
        const editionOffset = edition % exports.EDITION_MARKER_BIT_SIZE;
        const indexOffset = Math.floor(editionOffset / 8);
        if (indexOffset > 30) {
            throw Error('bad index for edition');
        }
        const positionInBitsetFromRight = 7 - (editionOffset % 8);
        const mask = Math.pow(2, positionInBitsetFromRight);
        const appliedMask = this.ledger[indexOffset] & mask;
        return appliedMask != 0;
    }
}
exports.EditionMarker = EditionMarker;
class Edition {
    constructor(args) {
        this.key = MetadataKey.EditionV1;
        this.parent = args.parent;
        this.edition = args.edition;
    }
}
exports.Edition = Edition;
class Creator {
    constructor(args) {
        this.address = args.address;
        this.verified = args.verified;
        this.share = args.share;
    }
}
exports.Creator = Creator;
class Data {
    constructor(args) {
        this.name = args.name;
        this.symbol = args.symbol;
        this.uri = args.uri;
        this.sellerFeeBasisPoints = args.sellerFeeBasisPoints;
        this.creators = args.creators;
    }
}
exports.Data = Data;
class Metadata {
    constructor(args) {
        var _a;
        this.key = MetadataKey.MetadataV1;
        this.updateAuthority = args.updateAuthority;
        this.mint = args.mint;
        this.data = args.data;
        this.primarySaleHappened = args.primarySaleHappened;
        this.isMutable = args.isMutable;
        this.editionNonce = (_a = args.editionNonce) !== null && _a !== void 0 ? _a : null;
    }
    async init() {
        //const metadata = toPublicKey(programIds().metadata);
        /*
        This nonce stuff doesnt work - we are doing something wrong here. TODO fix.
        if (this.editionNonce !== null) {
          this.edition = (
            await PublicKey.createProgramAddress(
              [
                Buffer.from(METADATA_PREFIX),
                metadata.toBuffer(),
                toPublicKey(this.mint).toBuffer(),
                new Uint8Array([this.editionNonce || 0]),
              ],
              metadata,
            )
          ).toBase58();
        } else {*/
        this.edition = await getEdition(this.mint);
        //}
        this.masterEdition = this.edition;
    }
}
exports.Metadata = Metadata;
class CreateMetadataArgs {
    constructor(args) {
        this.instruction = 0;
        this.data = args.data;
        this.isMutable = args.isMutable;
    }
}
class UpdateMetadataArgs {
    constructor(args) {
        this.instruction = 1;
        this.data = args.data ? args.data : null;
        this.updateAuthority = args.updateAuthority ? args.updateAuthority : null;
        this.primarySaleHappened = args.primarySaleHappened;
    }
}
class CreateMasterEditionArgs {
    constructor(args) {
        this.instruction = 10;
        this.maxSupply = args.maxSupply;
    }
}
class MintPrintingTokensArgs {
    constructor(args) {
        this.instruction = 9;
        this.supply = args.supply;
    }
}
exports.METADATA_SCHEMA = new Map([
    [
        CreateMetadataArgs,
        {
            kind: 'struct',
            fields: [
                ['instruction', 'u8'],
                ['data', Data],
                ['isMutable', 'u8'], // bool
            ],
        },
    ],
    [
        UpdateMetadataArgs,
        {
            kind: 'struct',
            fields: [
                ['instruction', 'u8'],
                ['data', { kind: 'option', type: Data }],
                ['updateAuthority', { kind: 'option', type: 'pubkeyAsString' }],
                ['primarySaleHappened', { kind: 'option', type: 'u8' }],
            ],
        },
    ],
    [
        CreateMasterEditionArgs,
        {
            kind: 'struct',
            fields: [
                ['instruction', 'u8'],
                ['maxSupply', { kind: 'option', type: 'u64' }],
            ],
        },
    ],
    [
        MintPrintingTokensArgs,
        {
            kind: 'struct',
            fields: [
                ['instruction', 'u8'],
                ['supply', 'u64'],
            ],
        },
    ],
    [
        MasterEditionV1,
        {
            kind: 'struct',
            fields: [
                ['key', 'u8'],
                ['supply', 'u64'],
                ['maxSupply', { kind: 'option', type: 'u64' }],
                ['printingMint', 'pubkeyAsString'],
                ['oneTimePrintingAuthorizationMint', 'pubkeyAsString'],
            ],
        },
    ],
    [
        MasterEditionV2,
        {
            kind: 'struct',
            fields: [
                ['key', 'u8'],
                ['supply', 'u64'],
                ['maxSupply', { kind: 'option', type: 'u64' }],
            ],
        },
    ],
    [
        Edition,
        {
            kind: 'struct',
            fields: [
                ['key', 'u8'],
                ['parent', 'pubkeyAsString'],
                ['edition', 'u64'],
            ],
        },
    ],
    [
        Data,
        {
            kind: 'struct',
            fields: [
                ['name', 'string'],
                ['symbol', 'string'],
                ['uri', 'string'],
                ['sellerFeeBasisPoints', 'u16'],
                ['creators', { kind: 'option', type: [Creator] }],
            ],
        },
    ],
    [
        Creator,
        {
            kind: 'struct',
            fields: [
                ['address', 'pubkeyAsString'],
                ['verified', 'u8'],
                ['share', 'u8'],
            ],
        },
    ],
    [
        Metadata,
        {
            kind: 'struct',
            fields: [
                ['key', 'u8'],
                ['updateAuthority', 'pubkeyAsString'],
                ['mint', 'pubkeyAsString'],
                ['data', Data],
                ['primarySaleHappened', 'u8'],
                ['isMutable', 'u8'],
                ['editionNonce', { kind: 'option', type: 'u8' }],
            ],
        },
    ],
    [
        EditionMarker,
        {
            kind: 'struct',
            fields: [
                ['key', 'u8'],
                ['ledger', [31]],
            ],
        },
    ],
]);
// eslint-disable-next-line no-control-regex
const METADATA_REPLACE = new RegExp('\u0000', 'g');
const decodeMetadata = (buffer) => {
    const metadata = (0, borsh_1.deserializeUnchecked)(exports.METADATA_SCHEMA, Metadata, buffer);
    metadata.data.name = metadata.data.name.replace(METADATA_REPLACE, '');
    metadata.data.uri = metadata.data.uri.replace(METADATA_REPLACE, '');
    metadata.data.symbol = metadata.data.symbol.replace(METADATA_REPLACE, '');
    return metadata;
};
exports.decodeMetadata = decodeMetadata;
const decodeEditionMarker = (buffer) => {
    const editionMarker = (0, borsh_1.deserializeUnchecked)(exports.METADATA_SCHEMA, EditionMarker, buffer);
    return editionMarker;
};
exports.decodeEditionMarker = decodeEditionMarker;
const decodeEdition = (buffer) => {
    return (0, borsh_1.deserializeUnchecked)(exports.METADATA_SCHEMA, Edition, buffer);
};
exports.decodeEdition = decodeEdition;
const decodeMasterEdition = (buffer) => {
    if (buffer[0] == MetadataKey.MasterEditionV1) {
        return (0, borsh_1.deserializeUnchecked)(exports.METADATA_SCHEMA, MasterEditionV1, buffer);
    }
    else {
        return (0, borsh_1.deserializeUnchecked)(exports.METADATA_SCHEMA, MasterEditionV2, buffer);
    }
};
exports.decodeMasterEdition = decodeMasterEdition;
async function updateMetadata(data, newUpdateAuthority, primarySaleHappened, mintKey, updateAuthority, instructions, metadataAccount) {
    const metadataProgramId = (0, programIds_1.programIds)().metadata;
    metadataAccount =
        metadataAccount ||
            (await (0, utils_1.findProgramAddress)([
                Buffer.from('metadata'),
                (0, utils_1.toPublicKey)(metadataProgramId).toBuffer(),
                (0, utils_1.toPublicKey)(mintKey).toBuffer(),
            ], (0, utils_1.toPublicKey)(metadataProgramId)))[0];
    const value = new UpdateMetadataArgs({
        data,
        updateAuthority: !newUpdateAuthority ? undefined : newUpdateAuthority,
        primarySaleHappened: primarySaleHappened === null || primarySaleHappened === undefined
            ? null
            : primarySaleHappened,
    });
    const txnData = Buffer.from((0, borsh_1.serialize)(exports.METADATA_SCHEMA, value));
    const keys = [
        {
            pubkey: (0, utils_1.toPublicKey)(metadataAccount),
            isSigner: false,
            isWritable: true,
        },
        {
            pubkey: (0, utils_1.toPublicKey)(updateAuthority),
            isSigner: true,
            isWritable: false,
        },
    ];
    instructions.push(new web3_js_1.TransactionInstruction({
        keys,
        programId: (0, utils_1.toPublicKey)(metadataProgramId),
        data: txnData,
    }));
    return metadataAccount;
}
exports.updateMetadata = updateMetadata;
async function createMetadata(data, updateAuthority, mintKey, mintAuthorityKey, instructions, payer) {
    const metadataProgramId = (0, programIds_1.programIds)().metadata;
    const metadataAccount = (await (0, utils_1.findProgramAddress)([
        Buffer.from('metadata'),
        (0, utils_1.toPublicKey)(metadataProgramId).toBuffer(),
        (0, utils_1.toPublicKey)(mintKey).toBuffer(),
    ], (0, utils_1.toPublicKey)(metadataProgramId)))[0];
    console.log('Data', data);
    const value = new CreateMetadataArgs({ data, isMutable: true });
    const txnData = Buffer.from((0, borsh_1.serialize)(exports.METADATA_SCHEMA, value));
    const keys = [
        {
            pubkey: (0, utils_1.toPublicKey)(metadataAccount),
            isSigner: false,
            isWritable: true,
        },
        {
            pubkey: (0, utils_1.toPublicKey)(mintKey),
            isSigner: false,
            isWritable: false,
        },
        {
            pubkey: (0, utils_1.toPublicKey)(mintAuthorityKey),
            isSigner: true,
            isWritable: false,
        },
        {
            pubkey: (0, utils_1.toPublicKey)(payer),
            isSigner: true,
            isWritable: false,
        },
        {
            pubkey: (0, utils_1.toPublicKey)(updateAuthority),
            isSigner: false,
            isWritable: false,
        },
        {
            pubkey: web3_js_1.SystemProgram.programId,
            isSigner: false,
            isWritable: false,
        },
        {
            pubkey: web3_js_1.SYSVAR_RENT_PUBKEY,
            isSigner: false,
            isWritable: false,
        },
    ];
    instructions.push(new web3_js_1.TransactionInstruction({
        keys,
        programId: (0, utils_1.toPublicKey)(metadataProgramId),
        data: txnData,
    }));
    return metadataAccount;
}
exports.createMetadata = createMetadata;
async function createMasterEdition(maxSupply, mintKey, updateAuthorityKey, mintAuthorityKey, payer, instructions) {
    const metadataProgramId = (0, programIds_1.programIds)().metadata;
    const metadataAccount = (await (0, utils_1.findProgramAddress)([
        Buffer.from(exports.METADATA_PREFIX),
        (0, utils_1.toPublicKey)(metadataProgramId).toBuffer(),
        (0, utils_1.toPublicKey)(mintKey).toBuffer(),
    ], (0, utils_1.toPublicKey)(metadataProgramId)))[0];
    const editionAccount = (await (0, utils_1.findProgramAddress)([
        Buffer.from(exports.METADATA_PREFIX),
        (0, utils_1.toPublicKey)(metadataProgramId).toBuffer(),
        (0, utils_1.toPublicKey)(mintKey).toBuffer(),
        Buffer.from(exports.EDITION),
    ], (0, utils_1.toPublicKey)(metadataProgramId)))[0];
    const value = new CreateMasterEditionArgs({ maxSupply: maxSupply || null });
    const data = Buffer.from((0, borsh_1.serialize)(exports.METADATA_SCHEMA, value));
    const keys = [
        {
            pubkey: (0, utils_1.toPublicKey)(editionAccount),
            isSigner: false,
            isWritable: true,
        },
        {
            pubkey: (0, utils_1.toPublicKey)(mintKey),
            isSigner: false,
            isWritable: true,
        },
        {
            pubkey: (0, utils_1.toPublicKey)(updateAuthorityKey),
            isSigner: true,
            isWritable: false,
        },
        {
            pubkey: (0, utils_1.toPublicKey)(mintAuthorityKey),
            isSigner: true,
            isWritable: false,
        },
        {
            pubkey: (0, utils_1.toPublicKey)(payer),
            isSigner: true,
            isWritable: false,
        },
        {
            pubkey: (0, utils_1.toPublicKey)(metadataAccount),
            isSigner: false,
            isWritable: false,
        },
        {
            pubkey: (0, programIds_1.programIds)().token,
            isSigner: false,
            isWritable: false,
        },
        {
            pubkey: web3_js_1.SystemProgram.programId,
            isSigner: false,
            isWritable: false,
        },
        {
            pubkey: web3_js_1.SYSVAR_RENT_PUBKEY,
            isSigner: false,
            isWritable: false,
        },
    ];
    instructions.push(new web3_js_1.TransactionInstruction({
        keys,
        programId: (0, utils_1.toPublicKey)(metadataProgramId),
        data,
    }));
}
exports.createMasterEdition = createMasterEdition;
async function deprecatedMintNewEditionFromMasterEditionViaPrintingToken(newMint, tokenMint, newMintAuthority, printingMint, authorizationTokenHoldingAccount, burnAuthority, updateAuthorityOfMaster, reservationList, instructions, payer) {
    const metadataProgramId = (0, programIds_1.programIds)().metadata;
    const newMetadataKey = await getMetadata(newMint);
    const masterMetadataKey = await getMetadata(tokenMint);
    const newEdition = await getEdition(newMint);
    const masterEdition = await getEdition(tokenMint);
    const data = Buffer.from([3]);
    const keys = [
        {
            pubkey: (0, utils_1.toPublicKey)(newMetadataKey),
            isSigner: false,
            isWritable: true,
        },
        {
            pubkey: (0, utils_1.toPublicKey)(newEdition),
            isSigner: false,
            isWritable: true,
        },
        {
            pubkey: (0, utils_1.toPublicKey)(masterEdition),
            isSigner: false,
            isWritable: true,
        },
        {
            pubkey: (0, utils_1.toPublicKey)(newMint),
            isSigner: false,
            isWritable: true,
        },
        {
            pubkey: (0, utils_1.toPublicKey)(newMintAuthority),
            isSigner: true,
            isWritable: false,
        },
        {
            pubkey: (0, utils_1.toPublicKey)(printingMint),
            isSigner: false,
            isWritable: true,
        },
        {
            pubkey: (0, utils_1.toPublicKey)(authorizationTokenHoldingAccount),
            isSigner: false,
            isWritable: true,
        },
        {
            pubkey: (0, utils_1.toPublicKey)(burnAuthority),
            isSigner: true,
            isWritable: false,
        },
        {
            pubkey: (0, utils_1.toPublicKey)(payer),
            isSigner: true,
            isWritable: false,
        },
        {
            pubkey: (0, utils_1.toPublicKey)(updateAuthorityOfMaster),
            isSigner: false,
            isWritable: false,
        },
        {
            pubkey: (0, utils_1.toPublicKey)(masterMetadataKey),
            isSigner: false,
            isWritable: false,
        },
        {
            pubkey: (0, programIds_1.programIds)().token,
            isSigner: false,
            isWritable: false,
        },
        {
            pubkey: web3_js_1.SystemProgram.programId,
            isSigner: false,
            isWritable: false,
        },
        {
            pubkey: web3_js_1.SYSVAR_RENT_PUBKEY,
            isSigner: false,
            isWritable: false,
        },
    ];
    if (reservationList) {
        keys.push({
            pubkey: (0, utils_1.toPublicKey)(reservationList),
            isSigner: false,
            isWritable: true,
        });
    }
    instructions.push(new web3_js_1.TransactionInstruction({
        keys,
        programId: (0, utils_1.toPublicKey)(metadataProgramId),
        data,
    }));
}
exports.deprecatedMintNewEditionFromMasterEditionViaPrintingToken = deprecatedMintNewEditionFromMasterEditionViaPrintingToken;
async function mintNewEditionFromMasterEditionViaToken(newMint, tokenMint, newMintAuthority, newUpdateAuthority, tokenOwner, tokenAccount, instructions, payer, edition) {
    const metadataProgramId = (0, programIds_1.programIds)().metadata;
    const newMetadataKey = await getMetadata(newMint);
    const masterMetadataKey = await getMetadata(tokenMint);
    const newEdition = await getEdition(newMint);
    const masterEdition = await getEdition(tokenMint);
    const editionMarkPda = await getEditionMarkPda(tokenMint, edition);
    const data = Buffer.from([11, ...edition.toArray('le', 8)]);
    const keys = [
        {
            pubkey: (0, utils_1.toPublicKey)(newMetadataKey),
            isSigner: false,
            isWritable: true,
        },
        {
            pubkey: (0, utils_1.toPublicKey)(newEdition),
            isSigner: false,
            isWritable: true,
        },
        {
            pubkey: (0, utils_1.toPublicKey)(masterEdition),
            isSigner: false,
            isWritable: true,
        },
        {
            pubkey: (0, utils_1.toPublicKey)(newMint),
            isSigner: false,
            isWritable: true,
        },
        {
            pubkey: (0, utils_1.toPublicKey)(editionMarkPda),
            isSigner: false,
            isWritable: true,
        },
        {
            pubkey: (0, utils_1.toPublicKey)(newMintAuthority),
            isSigner: true,
            isWritable: false,
        },
        {
            pubkey: (0, utils_1.toPublicKey)(payer),
            isSigner: true,
            isWritable: false,
        },
        {
            pubkey: (0, utils_1.toPublicKey)(tokenOwner),
            isSigner: true,
            isWritable: false,
        },
        {
            pubkey: (0, utils_1.toPublicKey)(tokenAccount),
            isSigner: false,
            isWritable: false,
        },
        {
            pubkey: (0, utils_1.toPublicKey)(newUpdateAuthority),
            isSigner: false,
            isWritable: false,
        },
        {
            pubkey: (0, utils_1.toPublicKey)(masterMetadataKey),
            isSigner: false,
            isWritable: false,
        },
        {
            pubkey: (0, programIds_1.programIds)().token,
            isSigner: false,
            isWritable: false,
        },
        {
            pubkey: web3_js_1.SystemProgram.programId,
            isSigner: false,
            isWritable: false,
        },
        {
            pubkey: web3_js_1.SYSVAR_RENT_PUBKEY,
            isSigner: false,
            isWritable: false,
        },
    ];
    instructions.push(new web3_js_1.TransactionInstruction({
        keys,
        programId: (0, utils_1.toPublicKey)(metadataProgramId),
        data,
    }));
}
exports.mintNewEditionFromMasterEditionViaToken = mintNewEditionFromMasterEditionViaToken;
async function updatePrimarySaleHappenedViaToken(metadata, owner, tokenAccount, instructions) {
    const metadataProgramId = (0, programIds_1.programIds)().metadata;
    const data = Buffer.from([4]);
    const keys = [
        {
            pubkey: (0, utils_1.toPublicKey)(metadata),
            isSigner: false,
            isWritable: true,
        },
        {
            pubkey: (0, utils_1.toPublicKey)(owner),
            isSigner: true,
            isWritable: false,
        },
        {
            pubkey: (0, utils_1.toPublicKey)(tokenAccount),
            isSigner: false,
            isWritable: false,
        },
    ];
    instructions.push(new web3_js_1.TransactionInstruction({
        keys,
        programId: (0, utils_1.toPublicKey)(metadataProgramId),
        data,
    }));
}
exports.updatePrimarySaleHappenedViaToken = updatePrimarySaleHappenedViaToken;
async function deprecatedCreateReservationList(metadata, masterEdition, resource, updateAuthority, payer, instructions) {
    const metadataProgramId = (0, programIds_1.programIds)().metadata;
    const reservationList = await deprecatedGetReservationList(masterEdition, resource);
    const data = Buffer.from([6]);
    const keys = [
        {
            pubkey: (0, utils_1.toPublicKey)(reservationList),
            isSigner: false,
            isWritable: true,
        },
        {
            pubkey: (0, utils_1.toPublicKey)(payer),
            isSigner: true,
            isWritable: false,
        },
        {
            pubkey: (0, utils_1.toPublicKey)(updateAuthority),
            isSigner: true,
            isWritable: false,
        },
        {
            pubkey: (0, utils_1.toPublicKey)(masterEdition),
            isSigner: false,
            isWritable: false,
        },
        {
            pubkey: (0, utils_1.toPublicKey)(resource),
            isSigner: false,
            isWritable: false,
        },
        {
            pubkey: (0, utils_1.toPublicKey)(metadata),
            isSigner: false,
            isWritable: false,
        },
        {
            pubkey: web3_js_1.SystemProgram.programId,
            isSigner: false,
            isWritable: false,
        },
        {
            pubkey: web3_js_1.SYSVAR_RENT_PUBKEY,
            isSigner: false,
            isWritable: false,
        },
    ];
    instructions.push(new web3_js_1.TransactionInstruction({
        keys,
        programId: (0, utils_1.toPublicKey)(metadataProgramId),
        data,
    }));
}
exports.deprecatedCreateReservationList = deprecatedCreateReservationList;
async function signMetadata(metadata, creator, instructions) {
    const metadataProgramId = (0, programIds_1.programIds)().metadata;
    const data = Buffer.from([7]);
    const keys = [
        {
            pubkey: (0, utils_1.toPublicKey)(metadata),
            isSigner: false,
            isWritable: true,
        },
        {
            pubkey: (0, utils_1.toPublicKey)(creator),
            isSigner: true,
            isWritable: false,
        },
    ];
    instructions.push(new web3_js_1.TransactionInstruction({
        keys,
        programId: (0, utils_1.toPublicKey)(metadataProgramId),
        data,
    }));
}
exports.signMetadata = signMetadata;
async function deprecatedMintPrintingTokens(destination, printingMint, updateAuthority, metadata, masterEdition, supply, instructions) {
    const PROGRAM_IDS = (0, programIds_1.programIds)();
    const metadataProgramId = PROGRAM_IDS.metadata;
    const value = new MintPrintingTokensArgs({ supply });
    const data = Buffer.from((0, borsh_1.serialize)(exports.METADATA_SCHEMA, value));
    const keys = [
        {
            pubkey: (0, utils_1.toPublicKey)(destination),
            isSigner: false,
            isWritable: true,
        },
        {
            pubkey: (0, utils_1.toPublicKey)(printingMint),
            isSigner: false,
            isWritable: true,
        },
        {
            pubkey: (0, utils_1.toPublicKey)(updateAuthority),
            isSigner: true,
            isWritable: false,
        },
        {
            pubkey: (0, utils_1.toPublicKey)(metadata),
            isSigner: false,
            isWritable: false,
        },
        {
            pubkey: (0, utils_1.toPublicKey)(masterEdition),
            isSigner: false,
            isWritable: false,
        },
        {
            pubkey: PROGRAM_IDS.token,
            isSigner: false,
            isWritable: false,
        },
        {
            pubkey: web3_js_1.SYSVAR_RENT_PUBKEY,
            isSigner: false,
            isWritable: false,
        },
    ];
    instructions.push(new web3_js_1.TransactionInstruction({
        keys,
        programId: (0, utils_1.toPublicKey)(metadataProgramId),
        data,
    }));
}
exports.deprecatedMintPrintingTokens = deprecatedMintPrintingTokens;
async function convertMasterEditionV1ToV2(masterEdition, oneTimeAuthMint, printingMint, instructions) {
    const metadataProgramId = (0, programIds_1.programIds)().metadata;
    const data = Buffer.from([12]);
    const keys = [
        {
            pubkey: (0, utils_1.toPublicKey)(masterEdition),
            isSigner: false,
            isWritable: true,
        },
        {
            pubkey: (0, utils_1.toPublicKey)(oneTimeAuthMint),
            isSigner: false,
            isWritable: true,
        },
        {
            pubkey: (0, utils_1.toPublicKey)(printingMint),
            isSigner: false,
            isWritable: true,
        },
    ];
    instructions.push(new web3_js_1.TransactionInstruction({
        keys,
        programId: (0, utils_1.toPublicKey)(metadataProgramId),
        data,
    }));
}
exports.convertMasterEditionV1ToV2 = convertMasterEditionV1ToV2;
async function getEdition(tokenMint) {
    const PROGRAM_IDS = (0, programIds_1.programIds)();
    return (await (0, utils_1.findProgramAddress)([
        Buffer.from(exports.METADATA_PREFIX),
        (0, utils_1.toPublicKey)(PROGRAM_IDS.metadata).toBuffer(),
        (0, utils_1.toPublicKey)(tokenMint).toBuffer(),
        Buffer.from(exports.EDITION),
    ], (0, utils_1.toPublicKey)(PROGRAM_IDS.metadata)))[0];
}
exports.getEdition = getEdition;
async function getMetadata(tokenMint) {
    const PROGRAM_IDS = (0, programIds_1.programIds)();
    return (await (0, utils_1.findProgramAddress)([
        Buffer.from(exports.METADATA_PREFIX),
        (0, utils_1.toPublicKey)(PROGRAM_IDS.metadata).toBuffer(),
        (0, utils_1.toPublicKey)(tokenMint).toBuffer(),
    ], (0, utils_1.toPublicKey)(PROGRAM_IDS.metadata)))[0];
}
exports.getMetadata = getMetadata;
async function deprecatedGetReservationList(masterEdition, resource) {
    const PROGRAM_IDS = (0, programIds_1.programIds)();
    return (await (0, utils_1.findProgramAddress)([
        Buffer.from(exports.METADATA_PREFIX),
        (0, utils_1.toPublicKey)(PROGRAM_IDS.metadata).toBuffer(),
        (0, utils_1.toPublicKey)(masterEdition).toBuffer(),
        Buffer.from(exports.RESERVATION),
        (0, utils_1.toPublicKey)(resource).toBuffer(),
    ], (0, utils_1.toPublicKey)(PROGRAM_IDS.metadata)))[0];
}
exports.deprecatedGetReservationList = deprecatedGetReservationList;
async function getEditionMarkPda(mint, edition) {
    const PROGRAM_IDS = (0, programIds_1.programIds)();
    const editionNumber = Math.floor(edition.toNumber() / 248);
    return (await (0, utils_1.findProgramAddress)([
        Buffer.from(exports.METADATA_PREFIX),
        (0, utils_1.toPublicKey)(PROGRAM_IDS.metadata).toBuffer(),
        (0, utils_1.toPublicKey)(mint).toBuffer(),
        Buffer.from(exports.EDITION),
        Buffer.from(editionNumber.toString()),
    ], (0, utils_1.toPublicKey)(PROGRAM_IDS.metadata)))[0];
}
exports.getEditionMarkPda = getEditionMarkPda;
//# sourceMappingURL=metadata.js.map

/***/ }),

/***/ 1559:
/***/ ((__unused_webpack_module, exports) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.PACKS_SCHEMA = exports.CleanUpArgs = exports.RequestCardToRedeemArgs = exports.ClaimPackArgs = exports.ActivatePackArgs = exports.AddVoucherToPackArgs = exports.AddCardToPackArgs = exports.InitPackSetArgs = void 0;
class InitPackSetArgs {
    constructor(args) {
        this.instruction = 0;
        this.name = args.name;
        this.description = args.description;
        this.uri = args.uri;
        this.mutable = args.mutable;
        this.distributionType = args.distributionType;
        this.allowedAmountToRedeem = args.allowedAmountToRedeem;
        this.redeemStartDate = args.redeemStartDate;
        this.redeemEndDate = args.redeemEndDate;
    }
}
exports.InitPackSetArgs = InitPackSetArgs;
class AddCardToPackArgs {
    constructor(args) {
        this.instruction = 1;
        this.maxSupply = args.maxSupply;
        this.weight = args.weight;
        this.index = args.index;
    }
}
exports.AddCardToPackArgs = AddCardToPackArgs;
class AddVoucherToPackArgs {
    constructor() {
        this.instruction = 2;
    }
}
exports.AddVoucherToPackArgs = AddVoucherToPackArgs;
class ActivatePackArgs {
    constructor() {
        this.instruction = 3;
    }
}
exports.ActivatePackArgs = ActivatePackArgs;
class ClaimPackArgs {
    constructor(args) {
        this.instruction = 6;
        this.index = args.index;
    }
}
exports.ClaimPackArgs = ClaimPackArgs;
class RequestCardToRedeemArgs {
    constructor(args) {
        this.instruction = 12;
        this.index = args.index;
    }
}
exports.RequestCardToRedeemArgs = RequestCardToRedeemArgs;
class CleanUpArgs {
    constructor() {
        this.instruction = 13;
    }
}
exports.CleanUpArgs = CleanUpArgs;
exports.PACKS_SCHEMA = new Map([
    [
        InitPackSetArgs,
        {
            kind: 'struct',
            fields: [
                ['instruction', 'u8'],
                ['name', [32]],
                ['description', 'string'],
                ['uri', 'string'],
                ['mutable', 'u8'],
                ['distributionType', 'u8'],
                ['allowedAmountToRedeem', 'u32'],
                ['redeemStartDate', { kind: 'option', type: 'u64' }],
                ['redeemEndDate', { kind: 'option', type: 'u64' }],
            ],
        },
    ],
    [
        AddCardToPackArgs,
        {
            kind: 'struct',
            fields: [
                ['instruction', 'u8'],
                ['maxSupply', 'u32'],
                ['weight', 'u16'],
                ['index', 'u32'],
            ],
        },
    ],
    [
        AddVoucherToPackArgs,
        {
            kind: 'struct',
            fields: [['instruction', 'u8']],
        },
    ],
    [
        ActivatePackArgs,
        {
            kind: 'struct',
            fields: [['instruction', 'u8']],
        },
    ],
    [
        ClaimPackArgs,
        {
            kind: 'struct',
            fields: [
                ['instruction', 'u8'],
                ['index', 'u32'],
            ],
        },
    ],
    [
        RequestCardToRedeemArgs,
        {
            kind: 'struct',
            fields: [
                ['instruction', 'u8'],
                ['index', 'u32'],
            ],
        },
    ],
    [
        CleanUpArgs,
        {
            kind: 'struct',
            fields: [['instruction', 'u8']],
        },
    ],
]);
//# sourceMappingURL=packs.js.map

/***/ }),

/***/ 5620:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.getSafetyDepositBoxAddress = exports.updateExternalPriceAccount = exports.withdrawTokenFromSafetyDepositBox = exports.combineVault = exports.activateVault = exports.addTokenToInactiveVault = exports.getSafetyDepositBox = exports.initVault = exports.setVaultAuthority = exports.decodeSafetyDeposit = exports.decodeExternalPriceAccount = exports.decodeVault = exports.VAULT_SCHEMA = exports.ExternalPriceAccount = exports.SafetyDepositBox = exports.Vault = exports.MAX_EXTERNAL_ACCOUNT_SIZE = exports.MAX_VAULT_SIZE = exports.VaultState = exports.VaultKey = exports.VAULT_PREFIX = void 0;
const web3_js_1 = __webpack_require__(5681);
const programIds_1 = __webpack_require__(6120);
const borsh_1 = __webpack_require__(7384);
const utils_1 = __webpack_require__(398);
exports.VAULT_PREFIX = 'vault';
var VaultKey;
(function (VaultKey) {
    VaultKey[VaultKey["Uninitialized"] = 0] = "Uninitialized";
    VaultKey[VaultKey["VaultV1"] = 3] = "VaultV1";
    VaultKey[VaultKey["SafetyDepositBoxV1"] = 1] = "SafetyDepositBoxV1";
    VaultKey[VaultKey["ExternalPriceAccountV1"] = 2] = "ExternalPriceAccountV1";
})(VaultKey = exports.VaultKey || (exports.VaultKey = {}));
var VaultState;
(function (VaultState) {
    VaultState[VaultState["Inactive"] = 0] = "Inactive";
    VaultState[VaultState["Active"] = 1] = "Active";
    VaultState[VaultState["Combined"] = 2] = "Combined";
    VaultState[VaultState["Deactivated"] = 3] = "Deactivated";
})(VaultState = exports.VaultState || (exports.VaultState = {}));
exports.MAX_VAULT_SIZE = 1 + 32 + 32 + 32 + 32 + 1 + 32 + 1 + 32 + 1 + 1 + 8;
exports.MAX_EXTERNAL_ACCOUNT_SIZE = 1 + 8 + 32 + 1;
class Vault {
    constructor(args) {
        this.key = VaultKey.VaultV1;
        this.tokenProgram = args.tokenProgram;
        this.fractionMint = args.fractionMint;
        this.authority = args.authority;
        this.fractionTreasury = args.fractionTreasury;
        this.redeemTreasury = args.redeemTreasury;
        this.allowFurtherShareCreation = args.allowFurtherShareCreation;
        this.pricingLookupAddress = args.pricingLookupAddress;
        this.tokenTypeCount = args.tokenTypeCount;
        this.state = args.state;
        this.lockedPricePerShare = args.lockedPricePerShare;
    }
}
exports.Vault = Vault;
class SafetyDepositBox {
    constructor(args) {
        this.key = VaultKey.SafetyDepositBoxV1;
        this.vault = args.vault;
        this.tokenMint = args.tokenMint;
        this.store = args.store;
        this.order = args.order;
    }
}
exports.SafetyDepositBox = SafetyDepositBox;
class ExternalPriceAccount {
    constructor(args) {
        this.key = VaultKey.ExternalPriceAccountV1;
        this.pricePerShare = args.pricePerShare;
        this.priceMint = args.priceMint;
        this.allowedToCombine = args.allowedToCombine;
    }
}
exports.ExternalPriceAccount = ExternalPriceAccount;
class InitVaultArgs {
    constructor(args) {
        this.instruction = 0;
        this.allowFurtherShareCreation = false;
        this.allowFurtherShareCreation = args.allowFurtherShareCreation;
    }
}
class AmountArgs {
    constructor(args) {
        this.instruction = args.instruction;
        this.amount = args.amount;
    }
}
class NumberOfShareArgs {
    constructor(args) {
        this.instruction = args.instruction;
        this.numberOfShares = args.numberOfShares;
    }
}
class UpdateExternalPriceAccountArgs {
    constructor(args) {
        this.instruction = 9;
        this.externalPriceAccount = args.externalPriceAccount;
    }
}
exports.VAULT_SCHEMA = new Map([
    [
        InitVaultArgs,
        {
            kind: 'struct',
            fields: [
                ['instruction', 'u8'],
                ['allowFurtherShareCreation', 'u8'],
            ],
        },
    ],
    [
        AmountArgs,
        {
            kind: 'struct',
            fields: [
                ['instruction', 'u8'],
                ['amount', 'u64'],
            ],
        },
    ],
    [
        NumberOfShareArgs,
        {
            kind: 'struct',
            fields: [
                ['instruction', 'u8'],
                ['numberOfShares', 'u64'],
            ],
        },
    ],
    [
        UpdateExternalPriceAccountArgs,
        {
            kind: 'struct',
            fields: [
                ['instruction', 'u8'],
                ['externalPriceAccount', ExternalPriceAccount],
            ],
        },
    ],
    [
        Vault,
        {
            kind: 'struct',
            fields: [
                ['key', 'u8'],
                ['tokenProgram', 'pubkeyAsString'],
                ['fractionMint', 'pubkeyAsString'],
                ['authority', 'pubkeyAsString'],
                ['fractionTreasury', 'pubkeyAsString'],
                ['redeemTreasury', 'pubkeyAsString'],
                ['allowFurtherShareCreation', 'u8'],
                ['pricingLookupAddress', 'pubkeyAsString'],
                ['tokenTypeCount', 'u8'],
                ['state', 'u8'],
                ['lockedPricePerShare', 'u64'],
            ],
        },
    ],
    [
        SafetyDepositBox,
        {
            kind: 'struct',
            fields: [
                ['key', 'u8'],
                ['vault', 'pubkeyAsString'],
                ['tokenMint', 'pubkeyAsString'],
                ['store', 'pubkeyAsString'],
                ['order', 'u8'],
            ],
        },
    ],
    [
        ExternalPriceAccount,
        {
            kind: 'struct',
            fields: [
                ['key', 'u8'],
                ['pricePerShare', 'u64'],
                ['priceMint', 'pubkeyAsString'],
                ['allowedToCombine', 'u8'],
            ],
        },
    ],
]);
const decodeVault = (buffer) => {
    return (0, borsh_1.deserializeUnchecked)(exports.VAULT_SCHEMA, Vault, buffer);
};
exports.decodeVault = decodeVault;
const decodeExternalPriceAccount = (buffer) => {
    return (0, borsh_1.deserializeUnchecked)(exports.VAULT_SCHEMA, ExternalPriceAccount, buffer);
};
exports.decodeExternalPriceAccount = decodeExternalPriceAccount;
const decodeSafetyDeposit = (buffer) => {
    return (0, borsh_1.deserializeUnchecked)(exports.VAULT_SCHEMA, SafetyDepositBox, buffer);
};
exports.decodeSafetyDeposit = decodeSafetyDeposit;
async function setVaultAuthority(vault, currentAuthority, newAuthority, instructions) {
    const vaultProgramId = (0, programIds_1.programIds)().vault;
    const data = Buffer.from([10]);
    const keys = [
        {
            pubkey: (0, utils_1.toPublicKey)(vault),
            isSigner: false,
            isWritable: true,
        },
        {
            pubkey: (0, utils_1.toPublicKey)(currentAuthority),
            isSigner: true,
            isWritable: false,
        },
        {
            pubkey: (0, utils_1.toPublicKey)(newAuthority),
            isSigner: false,
            isWritable: false,
        },
    ];
    instructions.push(new web3_js_1.TransactionInstruction({
        keys,
        programId: (0, utils_1.toPublicKey)(vaultProgramId),
        data: data,
    }));
}
exports.setVaultAuthority = setVaultAuthority;
async function initVault(allowFurtherShareCreation, fractionalMint, redeemTreasury, fractionalTreasury, vault, vaultAuthority, pricingLookupAddress, instructions) {
    const vaultProgramId = (0, programIds_1.programIds)().vault;
    const data = Buffer.from((0, borsh_1.serialize)(exports.VAULT_SCHEMA, new InitVaultArgs({ allowFurtherShareCreation })));
    const keys = [
        {
            pubkey: (0, utils_1.toPublicKey)(fractionalMint),
            isSigner: false,
            isWritable: true,
        },
        {
            pubkey: (0, utils_1.toPublicKey)(redeemTreasury),
            isSigner: false,
            isWritable: true,
        },
        {
            pubkey: (0, utils_1.toPublicKey)(fractionalTreasury),
            isSigner: false,
            isWritable: true,
        },
        {
            pubkey: (0, utils_1.toPublicKey)(vault),
            isSigner: false,
            isWritable: true,
        },
        {
            pubkey: (0, utils_1.toPublicKey)(vaultAuthority),
            isSigner: false,
            isWritable: false,
        },
        {
            pubkey: (0, utils_1.toPublicKey)(pricingLookupAddress),
            isSigner: false,
            isWritable: false,
        },
        {
            pubkey: (0, programIds_1.programIds)().token,
            isSigner: false,
            isWritable: false,
        },
        {
            pubkey: web3_js_1.SYSVAR_RENT_PUBKEY,
            isSigner: false,
            isWritable: false,
        },
    ];
    instructions.push(new web3_js_1.TransactionInstruction({
        keys,
        programId: (0, utils_1.toPublicKey)(vaultProgramId),
        data: data,
    }));
}
exports.initVault = initVault;
async function getSafetyDepositBox(vault, tokenMint) {
    const vaultProgramId = (0, programIds_1.programIds)().vault;
    return (await (0, utils_1.findProgramAddress)([
        Buffer.from(exports.VAULT_PREFIX),
        (0, utils_1.toPublicKey)(vault).toBuffer(),
        (0, utils_1.toPublicKey)(tokenMint).toBuffer(),
    ], (0, utils_1.toPublicKey)(vaultProgramId)))[0];
}
exports.getSafetyDepositBox = getSafetyDepositBox;
async function addTokenToInactiveVault(amount, tokenMint, tokenAccount, tokenStoreAccount, vault, vaultAuthority, payer, transferAuthority, instructions) {
    const vaultProgramId = (0, programIds_1.programIds)().vault;
    const safetyDepositBox = await getSafetyDepositBox(vault, tokenMint);
    const value = new AmountArgs({
        instruction: 1,
        amount,
    });
    const data = Buffer.from((0, borsh_1.serialize)(exports.VAULT_SCHEMA, value));
    const keys = [
        {
            pubkey: (0, utils_1.toPublicKey)(safetyDepositBox),
            isSigner: false,
            isWritable: true,
        },
        {
            pubkey: (0, utils_1.toPublicKey)(tokenAccount),
            isSigner: false,
            isWritable: true,
        },
        {
            pubkey: (0, utils_1.toPublicKey)(tokenStoreAccount),
            isSigner: false,
            isWritable: true,
        },
        {
            pubkey: (0, utils_1.toPublicKey)(vault),
            isSigner: false,
            isWritable: true,
        },
        {
            pubkey: (0, utils_1.toPublicKey)(vaultAuthority),
            isSigner: true,
            isWritable: false,
        },
        {
            pubkey: (0, utils_1.toPublicKey)(payer),
            isSigner: true,
            isWritable: false,
        },
        {
            pubkey: (0, utils_1.toPublicKey)(transferAuthority),
            isSigner: true,
            isWritable: false,
        },
        {
            pubkey: (0, programIds_1.programIds)().token,
            isSigner: false,
            isWritable: false,
        },
        {
            pubkey: web3_js_1.SYSVAR_RENT_PUBKEY,
            isSigner: false,
            isWritable: false,
        },
        {
            pubkey: web3_js_1.SystemProgram.programId,
            isSigner: false,
            isWritable: false,
        },
    ];
    instructions.push(new web3_js_1.TransactionInstruction({
        keys,
        programId: (0, utils_1.toPublicKey)(vaultProgramId),
        data,
    }));
}
exports.addTokenToInactiveVault = addTokenToInactiveVault;
async function activateVault(numberOfShares, vault, fractionMint, fractionTreasury, vaultAuthority, instructions) {
    const vaultProgramId = (0, programIds_1.programIds)().vault;
    const fractionMintAuthority = (await (0, utils_1.findProgramAddress)([
        Buffer.from(exports.VAULT_PREFIX),
        (0, utils_1.toPublicKey)(vaultProgramId).toBuffer(),
        (0, utils_1.toPublicKey)(vault).toBuffer(),
    ], (0, utils_1.toPublicKey)(vaultProgramId)))[0];
    const value = new NumberOfShareArgs({ instruction: 2, numberOfShares });
    const data = Buffer.from((0, borsh_1.serialize)(exports.VAULT_SCHEMA, value));
    const keys = [
        {
            pubkey: (0, utils_1.toPublicKey)(vault),
            isSigner: false,
            isWritable: true,
        },
        {
            pubkey: (0, utils_1.toPublicKey)(fractionMint),
            isSigner: false,
            isWritable: true,
        },
        {
            pubkey: (0, utils_1.toPublicKey)(fractionTreasury),
            isSigner: false,
            isWritable: true,
        },
        {
            pubkey: (0, utils_1.toPublicKey)(fractionMintAuthority),
            isSigner: false,
            isWritable: false,
        },
        {
            pubkey: (0, utils_1.toPublicKey)(vaultAuthority),
            isSigner: true,
            isWritable: false,
        },
        {
            pubkey: (0, programIds_1.programIds)().token,
            isSigner: false,
            isWritable: false,
        },
    ];
    instructions.push(new web3_js_1.TransactionInstruction({
        keys,
        programId: (0, utils_1.toPublicKey)(vaultProgramId),
        data,
    }));
}
exports.activateVault = activateVault;
async function combineVault(vault, outstandingShareTokenAccount, payingTokenAccount, fractionMint, fractionTreasury, redeemTreasury, newVaultAuthority, vaultAuthority, transferAuthority, externalPriceAccount, instructions) {
    const vaultProgramId = (0, programIds_1.programIds)().vault;
    const burnAuthority = (await (0, utils_1.findProgramAddress)([
        Buffer.from(exports.VAULT_PREFIX),
        (0, utils_1.toPublicKey)(vaultProgramId).toBuffer(),
        (0, utils_1.toPublicKey)(vault).toBuffer(),
    ], (0, utils_1.toPublicKey)(vaultProgramId)))[0];
    const data = Buffer.from([3]);
    const keys = [
        {
            pubkey: (0, utils_1.toPublicKey)(vault),
            isSigner: false,
            isWritable: true,
        },
        {
            pubkey: (0, utils_1.toPublicKey)(outstandingShareTokenAccount),
            isSigner: false,
            isWritable: true,
        },
        {
            pubkey: (0, utils_1.toPublicKey)(payingTokenAccount),
            isSigner: false,
            isWritable: true,
        },
        {
            pubkey: (0, utils_1.toPublicKey)(fractionMint),
            isSigner: false,
            isWritable: true,
        },
        {
            pubkey: (0, utils_1.toPublicKey)(fractionTreasury),
            isSigner: false,
            isWritable: true,
        },
        {
            pubkey: (0, utils_1.toPublicKey)(redeemTreasury),
            isSigner: false,
            isWritable: true,
        },
        {
            pubkey: (0, utils_1.toPublicKey)(newVaultAuthority || vaultAuthority),
            isSigner: false,
            isWritable: false,
        },
        {
            pubkey: (0, utils_1.toPublicKey)(vaultAuthority),
            isSigner: true,
            isWritable: false,
        },
        {
            pubkey: (0, utils_1.toPublicKey)(transferAuthority),
            isSigner: true,
            isWritable: false,
        },
        {
            pubkey: (0, utils_1.toPublicKey)(burnAuthority),
            isSigner: false,
            isWritable: false,
        },
        {
            pubkey: (0, utils_1.toPublicKey)(externalPriceAccount),
            isSigner: false,
            isWritable: false,
        },
        {
            pubkey: (0, programIds_1.programIds)().token,
            isSigner: false,
            isWritable: false,
        },
    ];
    instructions.push(new web3_js_1.TransactionInstruction({
        keys,
        programId: (0, utils_1.toPublicKey)(vaultProgramId),
        data,
    }));
}
exports.combineVault = combineVault;
async function withdrawTokenFromSafetyDepositBox(amount, destination, safetyDepositBox, storeKey, vault, fractionMint, vaultAuthority, instructions) {
    const vaultProgramId = (0, programIds_1.programIds)().vault;
    const transferAuthority = (await (0, utils_1.findProgramAddress)([
        Buffer.from(exports.VAULT_PREFIX),
        (0, utils_1.toPublicKey)(vaultProgramId).toBuffer(),
        (0, utils_1.toPublicKey)(vault).toBuffer(),
    ], (0, utils_1.toPublicKey)(vaultProgramId)))[0];
    const value = new AmountArgs({ instruction: 5, amount });
    const data = Buffer.from((0, borsh_1.serialize)(exports.VAULT_SCHEMA, value));
    const keys = [
        {
            pubkey: (0, utils_1.toPublicKey)(destination),
            isSigner: false,
            isWritable: true,
        },
        {
            pubkey: (0, utils_1.toPublicKey)(safetyDepositBox),
            isSigner: false,
            isWritable: true,
        },
        {
            pubkey: (0, utils_1.toPublicKey)(storeKey),
            isSigner: false,
            isWritable: true,
        },
        {
            pubkey: (0, utils_1.toPublicKey)(vault),
            isSigner: false,
            isWritable: true,
        },
        {
            pubkey: (0, utils_1.toPublicKey)(fractionMint),
            isSigner: false,
            isWritable: true,
        },
        {
            pubkey: (0, utils_1.toPublicKey)(vaultAuthority),
            isSigner: true,
            isWritable: false,
        },
        {
            pubkey: (0, utils_1.toPublicKey)(transferAuthority),
            isSigner: false,
            isWritable: false,
        },
        {
            pubkey: (0, programIds_1.programIds)().token,
            isSigner: false,
            isWritable: false,
        },
        {
            pubkey: web3_js_1.SYSVAR_RENT_PUBKEY,
            isSigner: false,
            isWritable: false,
        },
    ];
    instructions.push(new web3_js_1.TransactionInstruction({
        keys,
        programId: (0, utils_1.toPublicKey)(vaultProgramId),
        data,
    }));
}
exports.withdrawTokenFromSafetyDepositBox = withdrawTokenFromSafetyDepositBox;
async function updateExternalPriceAccount(externalPriceAccountKey, externalPriceAccount, instructions) {
    const vaultProgramId = (0, programIds_1.programIds)().vault;
    const value = new UpdateExternalPriceAccountArgs({ externalPriceAccount });
    const data = Buffer.from((0, borsh_1.serialize)(exports.VAULT_SCHEMA, value));
    console.log('Data', data);
    const keys = [
        {
            pubkey: (0, utils_1.toPublicKey)(externalPriceAccountKey),
            isSigner: false,
            isWritable: true,
        },
    ];
    instructions.push(new web3_js_1.TransactionInstruction({
        keys,
        programId: (0, utils_1.toPublicKey)(vaultProgramId),
        data,
    }));
}
exports.updateExternalPriceAccount = updateExternalPriceAccount;
async function getSafetyDepositBoxAddress(vault, tokenMint) {
    const PROGRAM_IDS = (0, programIds_1.programIds)();
    return (await (0, utils_1.findProgramAddress)([
        Buffer.from(exports.VAULT_PREFIX),
        (0, utils_1.toPublicKey)(vault).toBuffer(),
        (0, utils_1.toPublicKey)(tokenMint).toBuffer(),
    ], (0, utils_1.toPublicKey)(PROGRAM_IDS.vault)))[0];
}
exports.getSafetyDepositBoxAddress = getSafetyDepositBoxAddress;
//# sourceMappingURL=vault.js.map

/***/ }),

/***/ 630:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ActionConfirmation = void 0;
const react_1 = __importDefault(__webpack_require__(9297));
const antd_1 = __webpack_require__(953);
const constants_1 = __webpack_require__(7093);
const react_router_dom_1 = __webpack_require__(2146);
const ActionConfirmation = (props) => {
    return (react_1.default.createElement("div", { style: {
            display: 'flex',
            flexDirection: 'column',
            justifyContent: 'space-around',
            alignItems: 'center',
        } },
        react_1.default.createElement("h2", null, "Congratulations!"),
        react_1.default.createElement("div", null, "Your action has been successfully executed"),
        react_1.default.createElement("div", { className: "success-icon" }),
        react_1.default.createElement(react_router_dom_1.Link, { to: "/dashboard" },
            react_1.default.createElement(antd_1.Button, { type: "primary" }, constants_1.LABELS.DASHBOARD_ACTION)),
        react_1.default.createElement(antd_1.Button, { type: "text", onClick: props.onClose }, constants_1.LABELS.GO_BACK_ACTION)));
};
exports.ActionConfirmation = ActionConfirmation;
//# sourceMappingURL=index.js.map

/***/ }),

/***/ 791:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.BackButton = void 0;
const react_1 = __importDefault(__webpack_require__(9297));
const antd_1 = __webpack_require__(953);
const constants_1 = __webpack_require__(7093);
const react_router_dom_1 = __webpack_require__(2146);
const BackButton = () => {
    const history = (0, react_router_dom_1.useHistory)();
    return (react_1.default.createElement(antd_1.Button, { type: "text", onClick: history.goBack }, constants_1.LABELS.GO_BACK_ACTION));
};
exports.BackButton = BackButton;
//# sourceMappingURL=index.js.map

/***/ }),

/***/ 3752:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ConnectButton = void 0;
const antd_1 = __webpack_require__(953);
const react_1 = __importStar(__webpack_require__(9297));
const wallet_adapter_react_1 = __webpack_require__(5772);
const contexts_1 = __webpack_require__(3049);
const ConnectButton = (props) => {
    const { children, disabled, allowWalletChange, className, ...rest } = props;
    const { wallet, connect, connected } = (0, wallet_adapter_react_1.useWallet)();
    const { setVisible } = (0, contexts_1.useWalletModal)();
    const open = (0, react_1.useCallback)(() => setVisible(true), [setVisible]);
    const handleClick = (0, react_1.useCallback)(() => (wallet ? connect().catch(() => { }) : open()), [wallet, connect, open]);
    // only show if wallet selected or user connected
    if (!wallet || !allowWalletChange) {
        return (react_1.default.createElement(antd_1.Button, { className: className || 'connector', ...rest, onClick: e => {
                props.onClick ? props.onClick(e) : null;
                handleClick();
            }, disabled: connected && disabled }, connected ? children : 'Connect Wallet'));
    }
    return (react_1.default.createElement(antd_1.Dropdown.Button, { className: className || (connected ? 'connector' : ''), onClick: handleClick, disabled: connected && disabled, overlay: react_1.default.createElement(antd_1.Menu, { className: 'black-dropdown' },
            react_1.default.createElement(antd_1.Menu.Item, { onClick: open }, "Change Wallet")) }, "Connect"));
};
exports.ConnectButton = ConnectButton;
//# sourceMappingURL=index.js.map

/***/ }),

/***/ 628:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.EtherscanLink = void 0;
const react_1 = __importDefault(__webpack_require__(9297));
const antd_1 = __webpack_require__(953);
const utils_1 = __webpack_require__(7392);
const EtherscanLink = (props) => {
    var _a;
    const { type, code } = props;
    const address = props.address;
    if (!address) {
        return null;
    }
    const length = (_a = props.length) !== null && _a !== void 0 ? _a : 9;
    return (react_1.default.createElement("a", { href: `https://etherscan.io/${type}/${address}`, 
        // eslint-disable-next-line react/jsx-no-target-blank
        target: "_blank", title: address, style: props.style, rel: "noreferrer" }, code ? (react_1.default.createElement(antd_1.Typography.Text, { style: props.style, code: true }, (0, utils_1.shortenAddress)(address, length))) : ((0, utils_1.shortenAddress)(address, length))));
};
exports.EtherscanLink = EtherscanLink;
//# sourceMappingURL=index.js.map

/***/ }),

/***/ 4548:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ExplorerLink = void 0;
const react_1 = __importDefault(__webpack_require__(9297));
const antd_1 = __webpack_require__(953);
const utils_1 = __webpack_require__(7392);
const ExplorerLink = (props) => {
    var _a, _b;
    const { type, code } = props;
    const address = typeof props.address === 'string'
        ? props.address
        : (_a = props.address) === null || _a === void 0 ? void 0 : _a.toBase58();
    if (!address) {
        return null;
    }
    const length = (_b = props.length) !== null && _b !== void 0 ? _b : 9;
    return (react_1.default.createElement("a", { href: `https://explorer.solana.com/${type}/${address}`, 
        // eslint-disable-next-line react/jsx-no-target-blank
        target: "_blank", title: address, style: props.style, rel: "noreferrer" }, code ? (react_1.default.createElement(antd_1.Typography.Text, { style: props.style, code: true }, (0, utils_1.shortenAddress)(address, length))) : ((0, utils_1.shortenAddress)(address, length))));
};
exports.ExplorerLink = ExplorerLink;
//# sourceMappingURL=index.js.map

/***/ }),

/***/ 7160:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Info = void 0;
const antd_1 = __webpack_require__(953);
const react_1 = __importDefault(__webpack_require__(9297));
const icons_1 = __webpack_require__(2372);
const Info = (props) => {
    return (react_1.default.createElement(antd_1.Popover, { trigger: "hover", content: react_1.default.createElement("div", { style: { width: 300 } }, props.text) },
        react_1.default.createElement(antd_1.Button, { type: "text", shape: "circle" },
            react_1.default.createElement(icons_1.InfoCircleOutlined, { style: props.style }))));
};
exports.Info = Info;
//# sourceMappingURL=info.js.map

/***/ }),

/***/ 8128:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Identicon = void 0;
const react_1 = __importStar(__webpack_require__(9297));
const jazzicon_1 = __importDefault(__webpack_require__(351));
const bs58_1 = __importDefault(__webpack_require__(2815));
const Identicon = (props) => {
    var _a;
    const { style, className, alt } = props;
    const address = typeof props.address === 'string'
        ? props.address
        : (_a = props.address) === null || _a === void 0 ? void 0 : _a.toBase58();
    const ref = (0, react_1.useRef)();
    (0, react_1.useEffect)(() => {
        if (address && ref.current) {
            try {
                ref.current.innerHTML = '';
                ref.current.className = className || '';
                ref.current.appendChild((0, jazzicon_1.default)((style === null || style === void 0 ? void 0 : style.width) || 16, parseInt(bs58_1.default.decode(address).toString('hex').slice(5, 15), 16)));
            }
            catch (err) {
                // TODO
            }
        }
    }, [address, style, className]);
    return (react_1.default.createElement("div", { className: "identicon-wrapper", title: alt, ref: ref, style: props.style }));
};
exports.Identicon = Identicon;
//# sourceMappingURL=index.js.map

/***/ }),

/***/ 9630:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.NumericInput = void 0;
const react_1 = __importDefault(__webpack_require__(9297));
const antd_1 = __webpack_require__(953);
class NumericInput extends react_1.default.Component {
    constructor() {
        super(...arguments);
        this.onChange = (e) => {
            const { value } = e.target;
            const reg = /^-?\d*(\.\d*)?$/;
            if (reg.test(value) || value === '' || value === '-') {
                this.props.onChange(value);
            }
        };
        // '.' at the end or only '-' in the input box.
        this.onBlur = () => {
            const { value, onBlur, onChange } = this.props;
            let valueTemp = value;
            if (value === undefined || value === null)
                return;
            if (value.charAt &&
                (value.charAt(value.length - 1) === '.' || value === '-')) {
                valueTemp = value.slice(0, -1);
            }
            if (value.startsWith && (value.startsWith('.') || value.startsWith('-.'))) {
                valueTemp = valueTemp.replace('.', '0.');
            }
            if (valueTemp.replace)
                onChange === null || onChange === void 0 ? void 0 : onChange(valueTemp.replace(/0*(\d+)/, '$1'));
            if (onBlur) {
                onBlur();
            }
        };
    }
    render() {
        return (react_1.default.createElement(antd_1.Input, { ...this.props, onChange: this.onChange, onBlur: this.onBlur, maxLength: 25 }));
    }
}
exports.NumericInput = NumericInput;
//# sourceMappingURL=numeric.js.map

/***/ }),

/***/ 9128:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.MetaplexModal = void 0;
const react_1 = __importDefault(__webpack_require__(9297));
const antd_1 = __webpack_require__(953);
const MetaplexModal = (props) => {
    const { children, bodyStyle, className, ...rest } = props;
    return (react_1.default.createElement(antd_1.Modal, { bodyStyle: {
            background: '#2F2F2F',
            boxShadow: '0px 20px 12px 8px rgba(0, 0, 0, 0.3)',
            display: 'flex',
            flexDirection: 'column',
            ...bodyStyle,
        }, className: `modal-box small-modal ${className}`, footer: null, width: 500, ...rest }, children));
};
exports.MetaplexModal = MetaplexModal;
//# sourceMappingURL=index.js.map

/***/ }),

/***/ 9973:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.MetaplexOverlay = void 0;
const react_1 = __importDefault(__webpack_require__(9297));
const antd_1 = __webpack_require__(953);
const MetaplexOverlay = (props) => {
    const { children, ...rest } = props;
    const content = (react_1.default.createElement("div", { style: {
            display: 'flex',
            flexDirection: 'column',
            alignItems: 'center',
            pointerEvents: 'auto',
            justifyContent: 'center',
        } }, children));
    return (react_1.default.createElement(antd_1.Modal, { centered: true, modalRender: () => content, width: '100vw', mask: false, ...rest }));
};
exports.MetaplexOverlay = MetaplexOverlay;
//# sourceMappingURL=index.js.map

/***/ }),

/***/ 4483:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Settings = void 0;
const react_1 = __importDefault(__webpack_require__(9297));
const antd_1 = __webpack_require__(953);
const wallet_adapter_react_1 = __webpack_require__(5772);
const utils_1 = __webpack_require__(398);
const icons_1 = __webpack_require__(2372);
const Identicon_1 = __webpack_require__(8128);
const Settings = ({ additionalSettings, }) => {
    const { publicKey } = (0, wallet_adapter_react_1.useWallet)();
    return (react_1.default.createElement(react_1.default.Fragment, null,
        react_1.default.createElement("div", { style: {
                display: 'flex',
                flexDirection: 'column',
                alignItems: 'center',
                padding: '15px 0',
            } },
            react_1.default.createElement(Identicon_1.Identicon, { address: publicKey === null || publicKey === void 0 ? void 0 : publicKey.toBase58(), style: {
                    width: 48,
                } }),
            publicKey && (react_1.default.createElement(react_1.default.Fragment, null,
                react_1.default.createElement(antd_1.Tooltip, { title: "Address copied" },
                    react_1.default.createElement("div", { style: {
                            fontWeight: 600,
                            letterSpacing: '-0.02em',
                            color: '#FFFFFF',
                        }, onClick: () => navigator.clipboard.writeText((publicKey === null || publicKey === void 0 ? void 0 : publicKey.toBase58()) || '') },
                        react_1.default.createElement(icons_1.CopyOutlined, null),
                        "\u00A0",
                        (0, utils_1.shortenAddress)(publicKey === null || publicKey === void 0 ? void 0 : publicKey.toBase58()))))),
            react_1.default.createElement("br", null),
            react_1.default.createElement("span", { style: {
                    borderBottom: '1px solid rgba(255, 255, 255, 0.1)',
                    width: 'calc(100% + 32px)',
                    marginBottom: 10,
                } }),
            additionalSettings)));
};
exports.Settings = Settings;
//# sourceMappingURL=index.js.map

/***/ }),

/***/ 7296:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.TokenDisplay = void 0;
const react_1 = __importDefault(__webpack_require__(9297));
const accounts_1 = __webpack_require__(9834);
const hooks_1 = __webpack_require__(5902);
const TokenIcon_1 = __webpack_require__(3106);
const TokenDisplay = (props) => {
    const { showBalance, mintAddress, name, icon } = props;
    const tokenMint = (0, accounts_1.useMint)(mintAddress);
    const tokenAccount = (0, hooks_1.useAccountByMint)(mintAddress);
    let balance = 0;
    let hasBalance = false;
    if (showBalance) {
        if (tokenAccount && tokenMint) {
            balance =
                tokenAccount.info.amount.toNumber() / Math.pow(10, tokenMint.decimals);
            hasBalance = balance > 0;
        }
    }
    return (react_1.default.createElement(react_1.default.Fragment, null,
        react_1.default.createElement("div", { title: mintAddress, key: mintAddress, style: {
                display: 'flex',
                alignItems: 'center',
                justifyContent: 'space-between',
            } },
            react_1.default.createElement("div", { style: { display: 'flex', alignItems: 'center' } },
                icon || react_1.default.createElement(TokenIcon_1.TokenIcon, { mintAddress: mintAddress }),
                name),
            showBalance ? (react_1.default.createElement("span", { title: balance.toString(), key: mintAddress, className: "token-balance" },
                "\u00A0",
                ' ',
                hasBalance
                    ? balance < 0.001
                        ? '<0.001'
                        : balance.toFixed(3)
                    : '-')) : null)));
};
exports.TokenDisplay = TokenDisplay;
//# sourceMappingURL=index.js.map

/***/ }),

/***/ 3106:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.PoolIcon = exports.TokenIcon = void 0;
const react_1 = __importDefault(__webpack_require__(9297));
const utils_1 = __webpack_require__(398);
const connection_1 = __webpack_require__(8877);
const Identicon_1 = __webpack_require__(8128);
const TokenIcon = (props) => {
    var _a, _b;
    let icon = '';
    if (props.tokenMap) {
        icon = (0, utils_1.getTokenIcon)(props.tokenMap, props.mintAddress);
    }
    else {
        const { tokens } = (0, connection_1.useConnectionConfig)();
        icon = (0, utils_1.getTokenIcon)(tokens, props.mintAddress);
    }
    const size = props.size || 20;
    if (icon) {
        return (react_1.default.createElement("img", { alt: "Token icon", className: props.className, key: icon, width: ((_a = props.style) === null || _a === void 0 ? void 0 : _a.width) || size.toString(), height: ((_b = props.style) === null || _b === void 0 ? void 0 : _b.height) || size.toString(), src: icon, style: {
                marginRight: '0.5rem',
                marginTop: '0.11rem',
                borderRadius: '10rem',
                backgroundColor: 'white',
                backgroundClip: 'padding-box',
                ...props.style,
            } }));
    }
    return (react_1.default.createElement(Identicon_1.Identicon, { address: props.mintAddress, style: {
            marginRight: '0.5rem',
            width: size,
            height: size,
            marginTop: 2,
            ...props.style,
        } }));
};
exports.TokenIcon = TokenIcon;
const PoolIcon = (props) => {
    return (react_1.default.createElement("div", { className: props.className, style: { display: 'flex' } },
        react_1.default.createElement(exports.TokenIcon, { mintAddress: props.mintA, style: { marginRight: '-0.5rem', ...props.style } }),
        react_1.default.createElement(exports.TokenIcon, { mintAddress: props.mintB })));
};
exports.PoolIcon = PoolIcon;
//# sourceMappingURL=index.js.map

/***/ }),

/***/ 2878:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.MetaplexOverlay = exports.MetaplexModal = exports.EtherscanLink = exports.TokenDisplay = exports.TokenIcon = exports.BackButton = exports.ActionConfirmation = exports.Settings = exports.NumericInput = exports.Info = exports.Identicon = exports.ConnectButton = exports.ExplorerLink = void 0;
var index_1 = __webpack_require__(4548);
Object.defineProperty(exports, "ExplorerLink", ({ enumerable: true, get: function () { return index_1.ExplorerLink; } }));
var index_2 = __webpack_require__(3752);
Object.defineProperty(exports, "ConnectButton", ({ enumerable: true, get: function () { return index_2.ConnectButton; } }));
var index_3 = __webpack_require__(8128);
Object.defineProperty(exports, "Identicon", ({ enumerable: true, get: function () { return index_3.Identicon; } }));
var info_1 = __webpack_require__(7160);
Object.defineProperty(exports, "Info", ({ enumerable: true, get: function () { return info_1.Info; } }));
var numeric_1 = __webpack_require__(9630);
Object.defineProperty(exports, "NumericInput", ({ enumerable: true, get: function () { return numeric_1.NumericInput; } }));
var index_4 = __webpack_require__(4483);
Object.defineProperty(exports, "Settings", ({ enumerable: true, get: function () { return index_4.Settings; } }));
var index_5 = __webpack_require__(630);
Object.defineProperty(exports, "ActionConfirmation", ({ enumerable: true, get: function () { return index_5.ActionConfirmation; } }));
var index_6 = __webpack_require__(791);
Object.defineProperty(exports, "BackButton", ({ enumerable: true, get: function () { return index_6.BackButton; } }));
var TokenIcon_1 = __webpack_require__(3106);
Object.defineProperty(exports, "TokenIcon", ({ enumerable: true, get: function () { return TokenIcon_1.TokenIcon; } }));
var TokenDisplay_1 = __webpack_require__(7296);
Object.defineProperty(exports, "TokenDisplay", ({ enumerable: true, get: function () { return TokenDisplay_1.TokenDisplay; } }));
var EtherscanLink_1 = __webpack_require__(628);
Object.defineProperty(exports, "EtherscanLink", ({ enumerable: true, get: function () { return EtherscanLink_1.EtherscanLink; } }));
var MetaplexModal_1 = __webpack_require__(9128);
Object.defineProperty(exports, "MetaplexModal", ({ enumerable: true, get: function () { return MetaplexModal_1.MetaplexModal; } }));
var MetaplexOverlay_1 = __webpack_require__(9973);
Object.defineProperty(exports, "MetaplexOverlay", ({ enumerable: true, get: function () { return MetaplexOverlay_1.MetaplexOverlay; } }));
//# sourceMappingURL=index.js.map

/***/ }),

/***/ 7093:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
__exportStar(__webpack_require__(2193), exports);
__exportStar(__webpack_require__(9270), exports);
//# sourceMappingURL=index.js.map

/***/ }),

/***/ 9270:
/***/ ((__unused_webpack_module, exports) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.LABELS = void 0;
exports.LABELS = {
    CONNECT_LABEL: 'Connect Wallet',
    AUDIT_WARNING: 'Oyster is an unaudited software project used for internal purposes at the Solana Foundation. This app is not for public use.',
    FOOTER: 'This page was produced by the Solana Foundation ("SF") for internal educational and inspiration purposes only. SF does not encourage, induce or sanction the deployment, integration or use of Oyster or any similar application (including its code) in violation of applicable laws or regulations and hereby prohibits any such deployment, integration or use. Anyone using this code or a derivation thereof must comply with applicable laws and regulations when releasing related software.',
    MENU_HOME: 'Home',
    MENU_DASHBOARD: 'Dashboard',
    CONNECT_BUTTON: 'Connect',
    WALLET_TOOLTIP: 'Wallet public key',
    WALLET_BALANCE: 'Wallet balance',
    SETTINGS_TOOLTIP: 'Settings',
    DASHBOARD_ACTION: 'Go to dashboard',
    GO_BACK_ACTION: 'Go back',
};
//# sourceMappingURL=labels.js.map

/***/ }),

/***/ 2193:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ZERO = exports.RAY = exports.WAD = exports.HALF_WAD = exports.TEN = void 0;
const bn_js_1 = __importDefault(__webpack_require__(4894));
exports.TEN = new bn_js_1.default(10);
exports.HALF_WAD = exports.TEN.pow(new bn_js_1.default(18));
exports.WAD = exports.TEN.pow(new bn_js_1.default(18));
exports.RAY = exports.TEN.pow(new bn_js_1.default(27));
exports.ZERO = new bn_js_1.default(0);
//# sourceMappingURL=math.js.map

/***/ }),

/***/ 5634:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.useAccount = exports.useMint = exports.useNativeAccount = exports.AccountsProvider = exports.useAccountsContext = void 0;
const react_1 = __importStar(__webpack_require__(9297));
const wallet_adapter_react_1 = __webpack_require__(5772);
const web3_js_1 = __webpack_require__(5681);
const spl_token_1 = __webpack_require__(5653);
const connection_1 = __webpack_require__(8877);
const ids_1 = __webpack_require__(9556);
const programIds_1 = __webpack_require__(6120);
const cache_1 = __webpack_require__(8883);
const deserialize_1 = __webpack_require__(9734);
const parsesrs_1 = __webpack_require__(7220);
const AccountsContext = react_1.default.createContext(null);
const useAccountsContext = () => {
    const context = (0, react_1.useContext)(AccountsContext);
    return context;
};
exports.useAccountsContext = useAccountsContext;
function wrapNativeAccount(pubkey, account) {
    if (!account) {
        return undefined;
    }
    const key = new web3_js_1.PublicKey(pubkey);
    return {
        pubkey: pubkey,
        account,
        info: {
            address: key,
            mint: ids_1.WRAPPED_SOL_MINT,
            owner: key,
            amount: new spl_token_1.u64(account.lamports),
            delegate: null,
            delegatedAmount: new spl_token_1.u64(0),
            isInitialized: true,
            isFrozen: false,
            isNative: true,
            rentExemptReserve: null,
            closeAuthority: null,
        },
    };
}
const UseNativeAccount = () => {
    const connection = (0, connection_1.useConnection)();
    const { publicKey } = (0, wallet_adapter_react_1.useWallet)();
    const [nativeAccount, setNativeAccount] = (0, react_1.useState)();
    const updateCache = (0, react_1.useCallback)(account => {
        if (publicKey) {
            const wrapped = wrapNativeAccount(publicKey.toBase58(), account);
            if (wrapped !== undefined) {
                const id = publicKey.toBase58();
                cache_1.cache.registerParser(id, parsesrs_1.TokenAccountParser);
                cache_1.genericCache.set(id, wrapped);
                cache_1.cache.emitter.raiseCacheUpdated(id, false, parsesrs_1.TokenAccountParser, true);
            }
        }
    }, [publicKey]);
    (0, react_1.useEffect)(() => {
        let subId = 0;
        const updateAccount = (account) => {
            if (account) {
                updateCache(account);
                setNativeAccount(account);
            }
        };
        (async () => {
            if (!connection || !publicKey) {
                return;
            }
            const account = await connection.getAccountInfo(publicKey);
            updateAccount(account);
            subId = connection.onAccountChange(publicKey, updateAccount);
        })();
        return () => {
            if (subId) {
                connection.removeAccountChangeListener(subId);
            }
        };
    }, [setNativeAccount, publicKey, connection, updateCache]);
    return { nativeAccount };
};
const PRECACHED_OWNERS = new Set();
const precacheUserTokenAccounts = async (connection, owner) => {
    if (!owner) {
        return;
    }
    // used for filtering account updates over websocket
    PRECACHED_OWNERS.add(owner.toBase58());
    // user accounts are updated via ws subscription
    const accounts = await connection.getTokenAccountsByOwner(owner, {
        programId: (0, programIds_1.programIds)().token,
    });
    accounts.value.forEach(info => {
        cache_1.cache.add(info.pubkey.toBase58(), info.account, parsesrs_1.TokenAccountParser);
    });
};
function AccountsProvider({ children = null, }) {
    const connection = (0, connection_1.useConnection)();
    const { publicKey } = (0, wallet_adapter_react_1.useWallet)();
    const [tokenAccounts, setTokenAccounts] = (0, react_1.useState)([]);
    const [userAccounts, setUserAccounts] = (0, react_1.useState)([]);
    const { nativeAccount } = UseNativeAccount();
    const walletKey = publicKey === null || publicKey === void 0 ? void 0 : publicKey.toBase58();
    const selectUserAccounts = (0, react_1.useCallback)(() => {
        return cache_1.cache
            .byParser(parsesrs_1.TokenAccountParser)
            .map(id => cache_1.cache.get(id))
            .filter(a => a && a.info.owner.toBase58() === walletKey)
            .map(a => a);
    }, [walletKey, nativeAccount]);
    (0, react_1.useEffect)(() => {
        const accounts = selectUserAccounts().filter(a => a !== undefined);
        setUserAccounts(accounts);
    }, [nativeAccount, tokenAccounts, selectUserAccounts]);
    (0, react_1.useEffect)(() => {
        const subs = [];
        cache_1.cache.emitter.onCache(args => {
            if (args.isNew && args.isActive) {
                const id = args.id;
                const deserialize = args.parser;
                connection.onAccountChange(new web3_js_1.PublicKey(id), info => {
                    cache_1.cache.add(id, info, deserialize);
                });
            }
        });
        return () => {
            subs.forEach(id => connection.removeAccountChangeListener(id));
        };
    }, [connection]);
    (0, react_1.useEffect)(() => {
        if (!connection || !publicKey) {
            setTokenAccounts([]);
        }
        else {
            precacheUserTokenAccounts(connection, publicKey).then(() => {
                setTokenAccounts(selectUserAccounts());
            });
            // This can return different types of accounts: token-account, mint, multisig
            // TODO: web3.js expose ability to filter.
            // this should use only filter syntax to only get accounts that are owned by user
            const tokenSubID = connection.onProgramAccountChange((0, programIds_1.programIds)().token, info => {
                // TODO: fix type in web3.js
                const id = info.accountId;
                // TODO: do we need a better way to identify layout (maybe a enum identifing type?)
                if (info.accountInfo.data.length === spl_token_1.AccountLayout.span) {
                    const data = (0, deserialize_1.deserializeAccount)(info.accountInfo.data);
                    if (PRECACHED_OWNERS.has(data.owner.toBase58())) {
                        cache_1.cache.add(id, info.accountInfo, parsesrs_1.TokenAccountParser);
                        setTokenAccounts(selectUserAccounts());
                    }
                }
            }, 'singleGossip');
            return () => {
                connection.removeProgramAccountChangeListener(tokenSubID);
            };
        }
    }, [connection, publicKey, selectUserAccounts]);
    return (react_1.default.createElement(AccountsContext.Provider, { value: {
            userAccounts,
            nativeAccount,
        } }, children));
}
exports.AccountsProvider = AccountsProvider;
function useNativeAccount() {
    const context = (0, react_1.useContext)(AccountsContext);
    return {
        account: context.nativeAccount,
    };
}
exports.useNativeAccount = useNativeAccount;
function useMint(key) {
    const connection = (0, connection_1.useConnection)();
    const [mint, setMint] = (0, react_1.useState)();
    const id = typeof key === 'string' ? key : key === null || key === void 0 ? void 0 : key.toBase58();
    (0, react_1.useEffect)(() => {
        if (!id) {
            return;
        }
        cache_1.cache
            .query(connection, id, parsesrs_1.MintParser)
            .then(acc => setMint(acc.info))
            .catch(err => console.log(err));
        const dispose = cache_1.cache.emitter.onCache(e => {
            const event = e;
            if (event.id === id) {
                cache_1.cache
                    .query(connection, id, parsesrs_1.MintParser)
                    .then(mint => setMint(mint.info));
            }
        });
        return () => {
            dispose();
        };
    }, [connection, id]);
    return mint;
}
exports.useMint = useMint;
function useAccount(pubKey) {
    const connection = (0, connection_1.useConnection)();
    const [account, setAccount] = (0, react_1.useState)();
    const key = pubKey === null || pubKey === void 0 ? void 0 : pubKey.toBase58();
    (0, react_1.useEffect)(() => {
        const query = async () => {
            try {
                if (!key) {
                    return;
                }
                const acc = await cache_1.cache
                    .query(connection, key, parsesrs_1.TokenAccountParser)
                    .catch(err => console.log(err));
                if (acc) {
                    setAccount(acc);
                }
            }
            catch (err) {
                console.error(err);
            }
        };
        query();
        const dispose = cache_1.cache.emitter.onCache(e => {
            const event = e;
            if (event.id === key) {
                query();
            }
        });
        return () => {
            dispose();
        };
    }, [connection, key]);
    return account;
}
exports.useAccount = useAccount;
//# sourceMappingURL=accounts.js.map

/***/ }),

/***/ 8883:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.getCachedAccount = exports.cache = exports.genericCache = void 0;
const web3_js_1 = __webpack_require__(5681);
const eventEmitter_1 = __webpack_require__(9757);
const deserialize_1 = __webpack_require__(9734);
exports.genericCache = new Map();
const mintCache = new Map();
const pendingCalls = new Map();
const pendingMintCalls = new Map();
const keyToAccountParser = new Map();
const getMintInfo = async (connection, pubKey) => {
    const info = await connection.getAccountInfo(pubKey);
    if (info === null) {
        throw new Error('Failed to find mint account');
    }
    const data = Buffer.from(info.data);
    return (0, deserialize_1.deserializeMint)(data);
};
exports.cache = {
    emitter: new eventEmitter_1.EventEmitter(),
    query: async (connection, pubKey, parser) => {
        let id;
        if (typeof pubKey === 'string') {
            id = new web3_js_1.PublicKey(pubKey);
        }
        else {
            id = pubKey;
        }
        const address = id.toBase58();
        const account = exports.genericCache.get(address);
        if (account) {
            return account;
        }
        let query = pendingCalls.get(address);
        if (query) {
            return query;
        }
        // TODO: refactor to use multiple accounts query with flush like behavior
        query = connection.getAccountInfo(id).then(data => {
            if (!data) {
                throw new Error('Account not found');
            }
            return exports.cache.add(id, data, parser);
        });
        pendingCalls.set(address, query);
        return query;
    },
    add: (id, obj, parser, isActive) => {
        const address = typeof id === 'string' ? id : id === null || id === void 0 ? void 0 : id.toBase58();
        const deserialize = parser ? parser : keyToAccountParser.get(address);
        if (!deserialize) {
            throw new Error('Deserializer needs to be registered or passed as a parameter');
        }
        exports.cache.registerParser(id, deserialize);
        pendingCalls.delete(address);
        const account = deserialize(address, obj);
        if (!account) {
            return;
        }
        if (isActive === undefined)
            isActive = true;
        else if (isActive instanceof Function)
            isActive = isActive(account);
        const isNew = !exports.genericCache.has(address);
        exports.genericCache.set(address, account);
        exports.cache.emitter.raiseCacheUpdated(address, isNew, deserialize, isActive);
        return account;
    },
    get: (pubKey) => {
        let key;
        if (typeof pubKey !== 'string') {
            key = pubKey.toBase58();
        }
        else {
            key = pubKey;
        }
        return exports.genericCache.get(key);
    },
    delete: (pubKey) => {
        let key;
        if (typeof pubKey !== 'string') {
            key = pubKey.toBase58();
        }
        else {
            key = pubKey;
        }
        if (exports.genericCache.get(key)) {
            exports.genericCache.delete(key);
            exports.cache.emitter.raiseCacheDeleted(key);
            return true;
        }
        return false;
    },
    byParser: (parser) => {
        const result = [];
        for (const id of keyToAccountParser.keys()) {
            if (keyToAccountParser.get(id) === parser) {
                result.push(id);
            }
        }
        return result;
    },
    registerParser: (pubkey, parser) => {
        if (pubkey) {
            const address = typeof pubkey === 'string' ? pubkey : pubkey === null || pubkey === void 0 ? void 0 : pubkey.toBase58();
            keyToAccountParser.set(address, parser);
        }
        return pubkey;
    },
    queryMint: async (connection, pubKey) => {
        let id;
        if (typeof pubKey === 'string') {
            id = new web3_js_1.PublicKey(pubKey);
        }
        else {
            id = pubKey;
        }
        const address = id.toBase58();
        const mint = mintCache.get(address);
        if (mint) {
            return mint;
        }
        let query = pendingMintCalls.get(address);
        if (query) {
            return query;
        }
        query = getMintInfo(connection, id).then(data => {
            pendingMintCalls.delete(address);
            mintCache.set(address, data);
            return data;
        });
        pendingMintCalls.set(address, query);
        return query;
    },
    getMint: (pubKey) => {
        let key;
        if (typeof pubKey !== 'string') {
            key = pubKey.toBase58();
        }
        else {
            key = pubKey;
        }
        return mintCache.get(key);
    },
    addMint: (pubKey, obj) => {
        const mint = (0, deserialize_1.deserializeMint)(obj.data);
        const id = pubKey.toBase58();
        mintCache.set(id, mint);
        return mint;
    },
};
const getCachedAccount = (predicate) => {
    for (const account of exports.genericCache.values()) {
        if (predicate(account)) {
            return account;
        }
    }
};
exports.getCachedAccount = getCachedAccount;
//# sourceMappingURL=cache.js.map

/***/ }),

/***/ 9734:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.deserializeMint = exports.deserializeAccount = void 0;
const web3_js_1 = __webpack_require__(5681);
const spl_token_1 = __webpack_require__(5653);
// TODO: expose in spl package
const deserializeAccount = (data) => {
    const accountInfo = spl_token_1.AccountLayout.decode(data);
    accountInfo.mint = new web3_js_1.PublicKey(accountInfo.mint);
    accountInfo.owner = new web3_js_1.PublicKey(accountInfo.owner);
    accountInfo.amount = spl_token_1.u64.fromBuffer(accountInfo.amount);
    if (accountInfo.delegateOption === 0) {
        accountInfo.delegate = null;
        accountInfo.delegatedAmount = new spl_token_1.u64(0);
    }
    else {
        accountInfo.delegate = new web3_js_1.PublicKey(accountInfo.delegate);
        accountInfo.delegatedAmount = spl_token_1.u64.fromBuffer(accountInfo.delegatedAmount);
    }
    accountInfo.isInitialized = accountInfo.state !== 0;
    accountInfo.isFrozen = accountInfo.state === 2;
    if (accountInfo.isNativeOption === 1) {
        accountInfo.rentExemptReserve = spl_token_1.u64.fromBuffer(accountInfo.isNative);
        accountInfo.isNative = true;
    }
    else {
        accountInfo.rentExemptReserve = null;
        accountInfo.isNative = false;
    }
    if (accountInfo.closeAuthorityOption === 0) {
        accountInfo.closeAuthority = null;
    }
    else {
        accountInfo.closeAuthority = new web3_js_1.PublicKey(accountInfo.closeAuthority);
    }
    return accountInfo;
};
exports.deserializeAccount = deserializeAccount;
// TODO: expose in spl package
const deserializeMint = (data) => {
    if (data.length !== spl_token_1.MintLayout.span) {
        throw new Error('Not a valid Mint');
    }
    const mintInfo = spl_token_1.MintLayout.decode(data);
    if (mintInfo.mintAuthorityOption === 0) {
        mintInfo.mintAuthority = null;
    }
    else {
        mintInfo.mintAuthority = new web3_js_1.PublicKey(mintInfo.mintAuthority);
    }
    mintInfo.supply = spl_token_1.u64.fromBuffer(mintInfo.supply);
    mintInfo.isInitialized = mintInfo.isInitialized !== 0;
    if (mintInfo.freezeAuthorityOption === 0) {
        mintInfo.freezeAuthority = null;
    }
    else {
        mintInfo.freezeAuthority = new web3_js_1.PublicKey(mintInfo.freezeAuthority);
    }
    return mintInfo;
};
exports.deserializeMint = deserializeMint;
//# sourceMappingURL=deserialize.js.map

/***/ }),

/***/ 3270:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.getMultipleAccounts = void 0;
const utils_1 = __webpack_require__(7392);
const getMultipleAccounts = async (connection, keys, commitment) => {
    const result = await Promise.all((0, utils_1.chunks)(keys, 99).map(chunk => getMultipleAccountsCore(connection, chunk, commitment)));
    const array = result
        .map(a => a.array.map(acc => {
        if (!acc) {
            return undefined;
        }
        const { data, ...rest } = acc;
        const obj = {
            ...rest,
            data: Buffer.from(data[0], 'base64'),
        };
        return obj;
    }))
        .flat();
    return { keys, array };
};
exports.getMultipleAccounts = getMultipleAccounts;
const getMultipleAccountsCore = async (connection, keys, commitment) => {
    const args = connection._buildArgs([keys], commitment, 'base64');
    const unsafeRes = await connection._rpcRequest('getMultipleAccounts', args);
    if (unsafeRes.error) {
        throw new Error('failed to get info about account ' + unsafeRes.error.message);
    }
    if (unsafeRes.result.value) {
        const array = unsafeRes.result.value;
        return { keys, array };
    }
    // TODO: fix
    throw new Error();
};
//# sourceMappingURL=getMultipleAccounts.js.map

/***/ }),

/***/ 9834:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
__exportStar(__webpack_require__(5634), exports);
__exportStar(__webpack_require__(8883), exports);
__exportStar(__webpack_require__(3270), exports);
__exportStar(__webpack_require__(7220), exports);
__exportStar(__webpack_require__(9734), exports);
__exportStar(__webpack_require__(8127), exports);
//# sourceMappingURL=index.js.map

/***/ }),

/***/ 7220:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.GenericAccountParser = exports.TokenAccountParser = exports.MintParser = void 0;
const deserialize_1 = __webpack_require__(9734);
const MintParser = (pubKey, info) => {
    const buffer = Buffer.from(info.data);
    const data = (0, deserialize_1.deserializeMint)(buffer);
    const details = {
        pubkey: pubKey,
        account: {
            ...info,
        },
        info: data,
    };
    return details;
};
exports.MintParser = MintParser;
const TokenAccountParser = (pubKey, info) => {
    // Sometimes a wrapped sol account gets closed, goes to 0 length,
    // triggers an update over wss which triggers this guy to get called
    // since your UI already logged that pubkey as a token account. Check for length.
    if (info.data.length > 0) {
        const buffer = Buffer.from(info.data);
        const data = (0, deserialize_1.deserializeAccount)(buffer);
        const details = {
            pubkey: pubKey,
            account: {
                ...info,
            },
            info: data,
        };
        return details;
    }
};
exports.TokenAccountParser = TokenAccountParser;
const GenericAccountParser = (pubKey, info) => {
    const buffer = Buffer.from(info.data);
    const details = {
        pubkey: pubKey,
        account: {
            ...info,
        },
        info: buffer,
    };
    return details;
};
exports.GenericAccountParser = GenericAccountParser;
//# sourceMappingURL=parsesrs.js.map

/***/ }),

/***/ 8127:
/***/ ((__unused_webpack_module, exports) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
//# sourceMappingURL=types.js.map

/***/ }),

/***/ 8877:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.sendSignedTransaction = exports.getUnixTs = exports.sendTransactionWithRetry = exports.sendTransaction = exports.sendTransactionsWithRecentBlock = exports.sendTransactions = exports.sendTransactionsInChunks = exports.sendTransactionsWithManualRetry = exports.SequenceType = exports.getErrorForTransaction = exports.useConnectionConfig = exports.useConnection = exports.ConnectionProvider = exports.ENDPOINTS = void 0;
const react_1 = __importStar(__webpack_require__(9297));
const utils_1 = __webpack_require__(398);
const spl_token_registry_1 = __webpack_require__(407);
const wallet_adapter_base_1 = __webpack_require__(384);
const web3_js_1 = __webpack_require__(5681);
const utils_2 = __webpack_require__(7392);
const notifications_1 = __webpack_require__(5858);
const ExplorerLink_1 = __webpack_require__(4548);
const hooks_1 = __webpack_require__(5902);
exports.ENDPOINTS = [
    {
        name: 'mainnet-beta',
        label: 'mainnet-beta',
        url: 'https://api.metaplex.solana.com/',
        chainId: spl_token_registry_1.ENV.MainnetBeta,
    },
    {
        name: 'testnet',
        label: 'testnet',
        url: (0, web3_js_1.clusterApiUrl)('testnet'),
        chainId: spl_token_registry_1.ENV.Testnet,
    },
    {
        name: 'devnet',
        label: 'devnet',
        url: (0, web3_js_1.clusterApiUrl)('devnet'),
        chainId: spl_token_registry_1.ENV.Devnet,
    },
];
const DEFAULT_ENDPOINT = exports.ENDPOINTS[0];
const ConnectionContext = react_1.default.createContext({
    connection: new web3_js_1.Connection(DEFAULT_ENDPOINT.url, 'recent'),
    endpoint: DEFAULT_ENDPOINT,
    tokens: new Map(),
});
function ConnectionProvider({ children }) {
    const searchParams = (0, hooks_1.useQuerySearch)();
    const [networkStorage, setNetworkStorage] = (0, utils_2.useLocalStorageState)('network', DEFAULT_ENDPOINT.name);
    const networkParam = searchParams.get('network');
    let maybeEndpoint;
    if (networkParam) {
        const endpointParam = exports.ENDPOINTS.find(({ name }) => name === networkParam);
        if (endpointParam) {
            maybeEndpoint = endpointParam;
        }
    }
    if (networkStorage && !maybeEndpoint) {
        const endpointStorage = exports.ENDPOINTS.find(({ name }) => name === networkStorage);
        if (endpointStorage) {
            maybeEndpoint = endpointStorage;
        }
    }
    const endpoint = maybeEndpoint || DEFAULT_ENDPOINT;
    const { current: connection } = (0, react_1.useRef)(new web3_js_1.Connection(endpoint.url));
    const [tokens, setTokens] = (0, react_1.useState)(new Map());
    (0, react_1.useEffect)(() => {
        function fetchTokens() {
            return (0, utils_1.getTokenListContainerPromise)().then(container => {
                const list = container
                    .excludeByTag('nft')
                    .filterByChainId(endpoint.chainId)
                    .getList();
                const map = new Map(list.map(item => [item.address, item]));
                setTokens(map);
            });
        }
        fetchTokens();
    }, []);
    (0, react_1.useEffect)(() => {
        function updateNetworkInLocalStorageIfNeeded() {
            if (networkStorage !== endpoint.name) {
                setNetworkStorage(endpoint.name);
            }
        }
        updateNetworkInLocalStorageIfNeeded();
    }, []);
    // solana/web3.js closes its websocket connection when the subscription list
    // is empty after opening for the first time, preventing subsequent
    // subscriptions from receiving responses.
    // This is a hack to prevent the list from ever being empty.
    (0, react_1.useEffect)(() => {
        const id = connection.onAccountChange(web3_js_1.Keypair.generate().publicKey, () => { });
        return () => {
            connection.removeAccountChangeListener(id);
        };
    }, []);
    (0, react_1.useEffect)(() => {
        const id = connection.onSlotChange(() => null);
        return () => {
            connection.removeSlotChangeListener(id);
        };
    }, []);
    const contextValue = react_1.default.useMemo(() => {
        return {
            endpoint,
            connection,
            tokens,
        };
    }, [tokens]);
    return (react_1.default.createElement(ConnectionContext.Provider, { value: contextValue }, children));
}
exports.ConnectionProvider = ConnectionProvider;
function useConnection() {
    const { connection } = (0, react_1.useContext)(ConnectionContext);
    return connection;
}
exports.useConnection = useConnection;
function useConnectionConfig() {
    const { endpoint, tokens } = (0, react_1.useContext)(ConnectionContext);
    return {
        endpoint,
        tokens,
    };
}
exports.useConnectionConfig = useConnectionConfig;
const getErrorForTransaction = async (connection, txid) => {
    // wait for all confirmation before geting transaction
    await connection.confirmTransaction(txid, 'max');
    const tx = await connection.getParsedConfirmedTransaction(txid);
    const errors = [];
    if ((tx === null || tx === void 0 ? void 0 : tx.meta) && tx.meta.logMessages) {
        tx.meta.logMessages.forEach(log => {
            const regex = /Error: (.*)/gm;
            let m;
            while ((m = regex.exec(log)) !== null) {
                // This is necessary to avoid infinite loops with zero-width matches
                if (m.index === regex.lastIndex) {
                    regex.lastIndex++;
                }
                if (m.length > 1) {
                    errors.push(m[1]);
                }
            }
        });
    }
    return errors;
};
exports.getErrorForTransaction = getErrorForTransaction;
var SequenceType;
(function (SequenceType) {
    SequenceType[SequenceType["Sequential"] = 0] = "Sequential";
    SequenceType[SequenceType["Parallel"] = 1] = "Parallel";
    SequenceType[SequenceType["StopOnFailure"] = 2] = "StopOnFailure";
})(SequenceType = exports.SequenceType || (exports.SequenceType = {}));
async function sendTransactionsWithManualRetry(connection, wallet, instructions, signers) {
    let stopPoint = 0;
    let tries = 0;
    let lastInstructionsLength = null;
    const toRemoveSigners = {};
    instructions = instructions.filter((instr, i) => {
        if (instr.length > 0) {
            return true;
        }
        else {
            toRemoveSigners[i] = true;
            return false;
        }
    });
    let filteredSigners = signers.filter((_, i) => !toRemoveSigners[i]);
    while (stopPoint < instructions.length && tries < 3) {
        instructions = instructions.slice(stopPoint, instructions.length);
        filteredSigners = filteredSigners.slice(stopPoint, filteredSigners.length);
        if (instructions.length === lastInstructionsLength)
            tries = tries + 1;
        else
            tries = 0;
        try {
            if (instructions.length === 1) {
                await (0, exports.sendTransactionWithRetry)(connection, wallet, instructions[0], filteredSigners[0], 'single');
                stopPoint = 1;
            }
            else {
                stopPoint = await (0, exports.sendTransactions)(connection, wallet, instructions, filteredSigners, SequenceType.StopOnFailure, 'single');
            }
        }
        catch (e) {
            console.error(e);
        }
        console.log('Died on ', stopPoint, 'retrying from instruction', instructions[stopPoint], 'instructions length is', instructions.length);
        lastInstructionsLength = instructions.length;
    }
}
exports.sendTransactionsWithManualRetry = sendTransactionsWithManualRetry;
const sendTransactionsInChunks = async (connection, wallet, instructionSet, signersSet, sequenceType = SequenceType.Parallel, commitment = 'singleGossip', timeout = 120000, batchSize) => {
    if (!wallet.publicKey)
        throw new wallet_adapter_base_1.WalletNotConnectedError();
    let instructionsChunk = [instructionSet];
    let signersChunk = [signersSet];
    instructionsChunk = (0, utils_2.chunks)(instructionSet, batchSize);
    signersChunk = (0, utils_2.chunks)(signersSet, batchSize);
    for (let c = 0; c < instructionsChunk.length; c++) {
        const unsignedTxns = [];
        for (let i = 0; i < instructionsChunk[c].length; i++) {
            const instructions = instructionsChunk[c][i];
            const signers = signersChunk[c][i];
            if (instructions.length === 0) {
                continue;
            }
            const transaction = new web3_js_1.Transaction();
            const block = await connection.getRecentBlockhash(commitment);
            instructions.forEach(instruction => transaction.add(instruction));
            transaction.recentBlockhash = block.blockhash;
            transaction.setSigners(
            // fee payed by the wallet owner
            wallet.publicKey, ...signers.map(s => s.publicKey));
            if (signers.length > 0) {
                transaction.partialSign(...signers);
            }
            unsignedTxns.push(transaction);
        }
        const signedTxns = await wallet.signAllTransactions(unsignedTxns);
        const breakEarlyObject = { breakEarly: false, i: 0 };
        console.log('Signed txns length', signedTxns.length, 'vs handed in length', instructionSet.length);
        for (let i = 0; i < signedTxns.length; i++) {
            const signedTxnPromise = sendSignedTransaction({
                connection,
                signedTransaction: signedTxns[i],
                timeout,
            });
            signedTxnPromise.catch(() => {
                // @ts-ignore
                if (sequenceType === SequenceType.StopOnFailure) {
                    breakEarlyObject.breakEarly = true;
                    breakEarlyObject.i = i;
                }
            });
            try {
                await signedTxnPromise;
            }
            catch (e) {
                console.log('Caught failure', e);
                if (breakEarlyObject.breakEarly) {
                    console.log('Died on ', breakEarlyObject.i);
                    return breakEarlyObject.i; // Return the txn we failed on by index
                }
            }
        }
    }
    return instructionSet.length;
};
exports.sendTransactionsInChunks = sendTransactionsInChunks;
const sendTransactions = async (connection, wallet, instructionSet, signersSet, sequenceType = SequenceType.Parallel, commitment = 'singleGossip', successCallback = () => { }, failCallback = () => false, block) => {
    if (!wallet.publicKey)
        throw new wallet_adapter_base_1.WalletNotConnectedError();
    const unsignedTxns = [];
    if (!block) {
        block = await connection.getRecentBlockhash(commitment);
    }
    for (let i = 0; i < instructionSet.length; i++) {
        const instructions = instructionSet[i];
        const signers = signersSet[i];
        if (instructions.length === 0) {
            continue;
        }
        const transaction = new web3_js_1.Transaction();
        instructions.forEach(instruction => transaction.add(instruction));
        transaction.recentBlockhash = block.blockhash;
        transaction.setSigners(
        // fee payed by the wallet owner
        wallet.publicKey, ...signers.map(s => s.publicKey));
        if (signers.length > 0) {
            transaction.partialSign(...signers);
        }
        unsignedTxns.push(transaction);
    }
    const signedTxns = await wallet.signAllTransactions(unsignedTxns);
    const pendingTxns = [];
    const breakEarlyObject = { breakEarly: false, i: 0 };
    console.log('Signed txns length', signedTxns.length, 'vs handed in length', instructionSet.length);
    for (let i = 0; i < signedTxns.length; i++) {
        const signedTxnPromise = sendSignedTransaction({
            connection,
            signedTransaction: signedTxns[i],
        });
        signedTxnPromise
            .then(({ txid }) => {
            successCallback(txid, i);
        })
            .catch(() => {
            // @ts-ignore
            failCallback(signedTxns[i], i);
            if (sequenceType === SequenceType.StopOnFailure) {
                breakEarlyObject.breakEarly = true;
                breakEarlyObject.i = i;
            }
        });
        if (sequenceType !== SequenceType.Parallel) {
            try {
                await signedTxnPromise;
            }
            catch (e) {
                console.log('Caught failure', e);
                if (breakEarlyObject.breakEarly) {
                    console.log('Died on ', breakEarlyObject.i);
                    return breakEarlyObject.i; // Return the txn we failed on by index
                }
            }
        }
        else {
            pendingTxns.push(signedTxnPromise);
        }
    }
    if (sequenceType !== SequenceType.Parallel) {
        await Promise.all(pendingTxns);
    }
    return signedTxns.length;
};
exports.sendTransactions = sendTransactions;
const sendTransactionsWithRecentBlock = async (connection, wallet, instructionSet, signersSet, commitment = 'singleGossip') => {
    if (!wallet.publicKey)
        throw new wallet_adapter_base_1.WalletNotConnectedError();
    const unsignedTxns = [];
    for (let i = 0; i < instructionSet.length; i++) {
        const instructions = instructionSet[i];
        const signers = signersSet[i];
        if (instructions.length === 0) {
            continue;
        }
        const block = await connection.getRecentBlockhash(commitment);
        await (0, utils_2.sleep)(1200);
        const transaction = new web3_js_1.Transaction();
        instructions.forEach(instruction => transaction.add(instruction));
        transaction.recentBlockhash = block.blockhash;
        transaction.setSigners(
        // fee payed by the wallet owner
        wallet.publicKey, ...signers.map(s => s.publicKey));
        if (signers.length > 0) {
            transaction.partialSign(...signers);
        }
        unsignedTxns.push(transaction);
    }
    const signedTxns = await wallet.signAllTransactions(unsignedTxns);
    const breakEarlyObject = { breakEarly: false, i: 0 };
    console.log('Signed txns length', signedTxns.length, 'vs handed in length', instructionSet.length);
    for (let i = 0; i < signedTxns.length; i++) {
        const signedTxnPromise = sendSignedTransaction({
            connection,
            signedTransaction: signedTxns[i],
        });
        signedTxnPromise.catch(() => {
            breakEarlyObject.breakEarly = true;
            breakEarlyObject.i = i;
        });
        try {
            await signedTxnPromise;
        }
        catch (e) {
            console.log('Caught failure', e);
            if (breakEarlyObject.breakEarly) {
                console.log('Died on ', breakEarlyObject.i);
                return breakEarlyObject.i; // Return the txn we failed on by index
            }
        }
    }
    return signedTxns.length;
};
exports.sendTransactionsWithRecentBlock = sendTransactionsWithRecentBlock;
const sendTransaction = async (connection, wallet, instructions, signers, awaitConfirmation = true, commitment = 'singleGossip', includesFeePayer = false, block) => {
    if (!wallet.publicKey)
        throw new wallet_adapter_base_1.WalletNotConnectedError();
    let transaction = new web3_js_1.Transaction();
    instructions.forEach(instruction => transaction.add(instruction));
    transaction.recentBlockhash = (block || (await connection.getRecentBlockhash(commitment))).blockhash;
    if (includesFeePayer) {
        transaction.setSigners(...signers.map(s => s.publicKey));
    }
    else {
        transaction.setSigners(
        // fee payed by the wallet owner
        wallet.publicKey, ...signers.map(s => s.publicKey));
    }
    if (signers.length > 0) {
        transaction.partialSign(...signers);
    }
    if (!includesFeePayer) {
        transaction = await wallet.signTransaction(transaction);
    }
    const rawTransaction = transaction.serialize();
    const options = {
        skipPreflight: true,
        commitment,
    };
    const txid = await connection.sendRawTransaction(rawTransaction, options);
    let slot = 0;
    if (awaitConfirmation) {
        const confirmation = await awaitTransactionSignatureConfirmation(txid, DEFAULT_TIMEOUT, connection, commitment);
        if (!confirmation)
            throw new Error('Timed out awaiting confirmation on transaction');
        slot = (confirmation === null || confirmation === void 0 ? void 0 : confirmation.slot) || 0;
        if (confirmation === null || confirmation === void 0 ? void 0 : confirmation.err) {
            const errors = await (0, exports.getErrorForTransaction)(connection, txid);
            (0, notifications_1.notify)({
                message: 'Transaction failed...',
                description: (react_1.default.createElement(react_1.default.Fragment, null,
                    errors.map((err, ii) => (react_1.default.createElement("div", { key: ii }, err))),
                    react_1.default.createElement(ExplorerLink_1.ExplorerLink, { address: txid, type: "transaction" }))),
                type: 'error',
            });
            throw new Error(`Raw transaction ${txid} failed (${JSON.stringify(status)})`);
        }
    }
    return { txid, slot };
};
exports.sendTransaction = sendTransaction;
const sendTransactionWithRetry = async (connection, wallet, instructions, signers, commitment = 'singleGossip', includesFeePayer = false, block, beforeSend) => {
    if (!wallet.publicKey)
        throw new wallet_adapter_base_1.WalletNotConnectedError();
    let transaction = new web3_js_1.Transaction();
    instructions.forEach(instruction => transaction.add(instruction));
    transaction.recentBlockhash = (block || (await connection.getRecentBlockhash(commitment))).blockhash;
    if (includesFeePayer) {
        transaction.setSigners(...signers.map(s => s.publicKey));
    }
    else {
        transaction.setSigners(
        // fee payed by the wallet owner
        wallet.publicKey, ...signers.map(s => s.publicKey));
    }
    if (signers.length > 0) {
        transaction.partialSign(...signers);
    }
    if (!includesFeePayer) {
        transaction = await wallet.signTransaction(transaction);
    }
    if (beforeSend) {
        beforeSend();
    }
    const { txid, slot } = await sendSignedTransaction({
        connection,
        signedTransaction: transaction,
    });
    return { txid, slot };
};
exports.sendTransactionWithRetry = sendTransactionWithRetry;
const getUnixTs = () => {
    return new Date().getTime() / 1000;
};
exports.getUnixTs = getUnixTs;
const DEFAULT_TIMEOUT = 15000;
async function sendSignedTransaction({ signedTransaction, connection, timeout = DEFAULT_TIMEOUT, }) {
    const rawTransaction = signedTransaction.serialize();
    const startTime = (0, exports.getUnixTs)();
    let slot = 0;
    const txid = await connection.sendRawTransaction(rawTransaction, {
        skipPreflight: true,
    });
    console.log('Started awaiting confirmation for', txid);
    let done = false;
    (async () => {
        while (!done && (0, exports.getUnixTs)() - startTime < timeout) {
            connection.sendRawTransaction(rawTransaction, {
                skipPreflight: true,
            });
            await (0, utils_2.sleep)(500);
        }
    })();
    try {
        const confirmation = await awaitTransactionSignatureConfirmation(txid, timeout, connection, 'recent', true);
        if (!confirmation)
            throw new Error('Timed out awaiting confirmation on transaction');
        if (confirmation.err) {
            console.error(confirmation.err);
            throw new Error('Transaction failed: Custom instruction error');
        }
        slot = (confirmation === null || confirmation === void 0 ? void 0 : confirmation.slot) || 0;
    }
    catch (err) {
        console.error('Timeout Error caught', err);
        if (err.timeout) {
            throw new Error('Timed out awaiting confirmation on transaction');
        }
        let simulateResult = null;
        try {
            simulateResult = (await simulateTransaction(connection, signedTransaction, 'single')).value;
            // eslint-disable-next-line no-empty
        }
        catch (e) { }
        if (simulateResult && simulateResult.err) {
            if (simulateResult.logs) {
                for (let i = simulateResult.logs.length - 1; i >= 0; --i) {
                    const line = simulateResult.logs[i];
                    if (line.startsWith('Program log: ')) {
                        throw new Error('Transaction failed: ' + line.slice('Program log: '.length));
                    }
                }
            }
            throw new Error(JSON.stringify(simulateResult.err));
        }
        // throw new Error('Transaction failed');
    }
    finally {
        done = true;
    }
    console.log('Latency', txid, (0, exports.getUnixTs)() - startTime);
    return { txid, slot };
}
exports.sendSignedTransaction = sendSignedTransaction;
async function simulateTransaction(connection, transaction, commitment) {
    // @ts-ignore
    transaction.recentBlockhash = await connection._recentBlockhash(
    // @ts-ignore
    connection._disableBlockhashCaching);
    const signData = transaction.serializeMessage();
    // @ts-ignore
    const wireTransaction = transaction._serialize(signData);
    const encodedTransaction = wireTransaction.toString('base64');
    const config = { encoding: 'base64', commitment };
    const args = [encodedTransaction, config];
    // @ts-ignore
    const res = await connection._rpcRequest('simulateTransaction', args);
    if (res.error) {
        throw new Error('failed to simulate transaction: ' + res.error.message);
    }
    return res.result;
}
async function awaitTransactionSignatureConfirmation(txid, timeout, connection, commitment = 'recent', queryStatus = false) {
    let done = false;
    let status = {
        slot: 0,
        confirmations: 0,
        err: null,
    };
    let subId = 0;
    status = await (async () => {
        setTimeout(() => {
            if (done) {
                return;
            }
            done = true;
            console.log('Rejecting for timeout...');
            throw { timeout: true };
        }, timeout);
        try {
            return await new Promise((resolve, reject) => {
                subId = connection.onSignature(txid, (result, context) => {
                    done = true;
                    const nextStatus = {
                        err: result.err,
                        slot: context.slot,
                        confirmations: 0,
                    };
                    if (result.err) {
                        console.log('Rejected via websocket', result.err);
                        reject(nextStatus);
                    }
                    else {
                        console.log('Resolved via websocket', result);
                        resolve(nextStatus);
                    }
                }, commitment);
            });
        }
        catch (e) {
            done = true;
            console.error('WS error in setup', txid, e);
        }
        while (!done && queryStatus) {
            try {
                const signatureStatuses = await connection.getSignatureStatuses([txid]);
                const nextStatus = signatureStatuses && signatureStatuses.value[0];
                if (!done) {
                    if (!nextStatus) {
                        console.log('REST null result for', txid, nextStatus);
                    }
                    else if (nextStatus.err) {
                        console.log('REST error for', txid, nextStatus);
                        done = true;
                        throw nextStatus.err;
                    }
                    else if (!nextStatus.confirmations) {
                        console.log('REST no confirmations for', txid, nextStatus);
                    }
                    else {
                        console.log('REST confirmation for', txid, nextStatus);
                        done = true;
                        return nextStatus;
                    }
                }
            }
            catch (e) {
                if (!done) {
                    console.log('REST connection error: txid', txid, e);
                }
            }
            await (0, utils_2.sleep)(2000);
        }
    })();
    //@ts-ignore
    if (connection._signatureSubscriptions[subId])
        connection.removeSignatureListener(subId);
    done = true;
    console.log('Returning status', status);
    return status;
}
//# sourceMappingURL=connection.js.map

/***/ }),

/***/ 3049:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Wallet = exports.Connection = exports.Accounts = void 0;
exports.Accounts = __importStar(__webpack_require__(9834));
__exportStar(__webpack_require__(9834), exports);
exports.Connection = __importStar(__webpack_require__(8877));
__exportStar(__webpack_require__(8877), exports);
exports.Wallet = __importStar(__webpack_require__(3115));
__exportStar(__webpack_require__(3115), exports);
__exportStar(__webpack_require__(7646), exports);
__exportStar(__webpack_require__(5392), exports);
//# sourceMappingURL=index.js.map

/***/ }),

/***/ 4953:
/***/ ((__unused_webpack_module, exports) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.getEmptyMetaState = void 0;
const getEmptyMetaState = () => ({
    metadata: [],
    metadataByMetadata: {},
    metadataByMint: {},
    metadataByAuction: {},
    masterEditions: {},
    masterEditionsByPrintingMint: {},
    masterEditionsByOneTimeAuthMint: {},
    metadataByMasterEdition: {},
    editions: {},
    auctionManagersByAuction: {},
    bidRedemptions: {},
    auctions: {},
    auctionDataExtended: {},
    vaults: {},
    payoutTickets: {},
    store: null,
    whitelistedCreatorsByCreator: {},
    bidderMetadataByAuctionAndBidder: {},
    bidderPotsByAuctionAndBidder: {},
    safetyDepositBoxesByVaultAndIndex: {},
    prizeTrackingTickets: {},
    safetyDepositConfigsByAuctionManagerAndIndex: {},
    bidRedemptionV2sByAuctionManagerAndWinningIndex: {},
    auctionCaches: {},
    storeIndexer: [],
    packs: {},
    packCards: {},
    packCardsByPackSet: {},
    vouchers: {},
    provingProcesses: {},
});
exports.getEmptyMetaState = getEmptyMetaState;
//# sourceMappingURL=getEmptyMetaState.js.map

/***/ }),

/***/ 5392:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
__exportStar(__webpack_require__(5778), exports);
__exportStar(__webpack_require__(2112), exports);
__exportStar(__webpack_require__(9357), exports);
__exportStar(__webpack_require__(811), exports);
__exportStar(__webpack_require__(3445), exports);
__exportStar(__webpack_require__(3680), exports);
__exportStar(__webpack_require__(3881), exports);
__exportStar(__webpack_require__(7067), exports);
__exportStar(__webpack_require__(8317), exports);
__exportStar(__webpack_require__(8005), exports);
__exportStar(__webpack_require__(7857), exports);
//# sourceMappingURL=index.js.map

/***/ }),

/***/ 2112:
/***/ ((__unused_webpack_module, exports) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.isMetadataPartOfStore = void 0;
const isMetadataPartOfStore = (m, whitelistedCreatorsByCreator, store) => {
    var _a, _b;
    if (!((_b = (_a = m === null || m === void 0 ? void 0 : m.info) === null || _a === void 0 ? void 0 : _a.data) === null || _b === void 0 ? void 0 : _b.creators)) {
        return false;
    }
    return m.info.data.creators.some(c => {
        var _a, _b;
        return c.verified &&
            ((store === null || store === void 0 ? void 0 : store.info.public) ||
                ((_b = (_a = whitelistedCreatorsByCreator[c.address]) === null || _a === void 0 ? void 0 : _a.info) === null || _b === void 0 ? void 0 : _b.activated));
    });
};
exports.isMetadataPartOfStore = isMetadataPartOfStore;
//# sourceMappingURL=isMetadataPartOfStore.js.map

/***/ }),

/***/ 9357:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.initMetadata = exports.metadataByMintUpdater = exports.processingAccounts = exports.makeSetter = exports.pullMetadataByKeys = exports.loadAccounts = exports.limitedLoadAccounts = exports.pullPage = exports.pullPages = exports.pullAuctionSubaccounts = exports.pullPack = exports.pullPacks = exports.pullPayoutTickets = exports.pullYourMetadata = exports.pullStoreMetadata = exports.USE_SPEED_RUN = void 0;
const ids_1 = __webpack_require__(9556);
const models_1 = __webpack_require__(5460);
const actions_1 = __webpack_require__(6618);
const lodash_1 = __webpack_require__(3804);
const metaplex_1 = __webpack_require__(4373);
const web3_js_1 = __webpack_require__(5681);
const isMetadataPartOfStore_1 = __webpack_require__(2112);
const processAuctions_1 = __webpack_require__(3680);
const processMetaplexAccounts_1 = __webpack_require__(7067);
const processMetaData_1 = __webpack_require__(3881);
const processVaultData_1 = __webpack_require__(8317);
const getEmptyMetaState_1 = __webpack_require__(4953);
const getMultipleAccounts_1 = __webpack_require__(3270);
const web3_1 = __webpack_require__(8460);
const createPipelineExecutor_1 = __webpack_require__(611);
const __1 = __webpack_require__(9819);
const PackSet_1 = __webpack_require__(6160);
const processPackSets_1 = __webpack_require__(8094);
const PackVoucher_1 = __webpack_require__(6575);
const processPackVouchers_1 = __webpack_require__(7571);
const PackCard_1 = __webpack_require__(7290);
const processPackCards_1 = __webpack_require__(8891);
const ProvingProcess_1 = __webpack_require__(9437);
const processProvingProcess_1 = __webpack_require__(6130);
const MULTIPLE_ACCOUNT_BATCH_SIZE = 100;
exports.USE_SPEED_RUN = false;
const WHITELISTED_METADATA = ['98vYFjBYS9TguUMWQRPjy2SZuxKuUMcqR4vnQiLjZbte'];
const WHITELISTED_AUCTION = ['D8wMB5iLZnsV7XQjpwqXaDynUtFuDs7cRXvEGNj1NF1e'];
const AUCTION_TO_METADATA = {
    D8wMB5iLZnsV7XQjpwqXaDynUtFuDs7cRXvEGNj1NF1e: [
        '98vYFjBYS9TguUMWQRPjy2SZuxKuUMcqR4vnQiLjZbte',
    ],
};
const AUCTION_TO_VAULT = {
    D8wMB5iLZnsV7XQjpwqXaDynUtFuDs7cRXvEGNj1NF1e: '3wHCBd3fYRPWjd5GqzrXanLJUKRyU3nECKbTPKfVwcFX',
};
const WHITELISTED_AUCTION_MANAGER = [
    '3HD2C8oCL8dpqbXo8hq3CMw6tRSZDZJGajLxnrZ3ZkYx',
];
const WHITELISTED_VAULT = ['3wHCBd3fYRPWjd5GqzrXanLJUKRyU3nECKbTPKfVwcFX'];
const pullStoreMetadata = async (connection, tempCache) => {
    const updateTemp = (0, exports.makeSetter)(tempCache);
    const loadMetadata = () => pullMetadataByCreators(connection, tempCache, updateTemp);
    const loadEditions = () => pullEditions(connection, updateTemp, tempCache, tempCache.metadata);
    console.log('-------->Loading all metadata for store.');
    await loadMetadata();
    await loadEditions();
    await postProcessMetadata(tempCache);
    console.log('-------->Metadata processing complete.');
    return tempCache;
};
exports.pullStoreMetadata = pullStoreMetadata;
const pullYourMetadata = async (connection, userTokenAccounts, tempCache) => {
    const updateTemp = (0, exports.makeSetter)(tempCache);
    console.log('--------->Pulling metadata for user.');
    let currBatch = [];
    let batches = [];
    const editions = [];
    for (let i = 0; i < userTokenAccounts.length; i++) {
        if (userTokenAccounts[i].info.amount.toNumber() == 1) {
            const edition = await (0, actions_1.getEdition)(userTokenAccounts[i].info.mint.toBase58());
            const newAdd = [
                await (0, actions_1.getMetadata)(userTokenAccounts[i].info.mint.toBase58()),
                edition,
            ];
            editions.push(edition);
            currBatch = currBatch.concat(newAdd);
            if (2 + currBatch.length >= MULTIPLE_ACCOUNT_BATCH_SIZE) {
                batches.push(currBatch);
                currBatch = [];
            }
        }
    }
    if (currBatch.length > 0 && currBatch.length <= MULTIPLE_ACCOUNT_BATCH_SIZE) {
        batches.push(currBatch);
    }
    console.log('------> From token accounts for user', 'produced', batches.length, 'batches of accounts to pull');
    for (let i = 0; i < batches.length; i++) {
        const accounts = await (0, getMultipleAccounts_1.getMultipleAccounts)(connection, batches[i], 'single');
        if (accounts) {
            console.log('------->Pulled batch', i, 'with', batches[i].length, 'accounts, processing....');
            for (let j = 0; j < accounts.keys.length; j++) {
                const pubkey = accounts.keys[j];
                await (0, processMetaData_1.processMetaData)({
                    pubkey,
                    account: accounts.array[j],
                }, updateTemp);
            }
        }
        else {
            console.log('------->Failed to pull batch', i, 'skipping');
        }
    }
    console.log('------> Pulling master editions for user');
    currBatch = [];
    batches = [];
    for (let i = 0; i < editions.length; i++) {
        if (1 + currBatch.length > MULTIPLE_ACCOUNT_BATCH_SIZE) {
            batches.push(currBatch);
            currBatch = [];
        }
        else if (tempCache.editions[editions[i]]) {
            currBatch.push(tempCache.editions[editions[i]].info.parent);
        }
    }
    if (currBatch.length > 0 && currBatch.length <= MULTIPLE_ACCOUNT_BATCH_SIZE) {
        batches.push(currBatch);
    }
    console.log('------> From token accounts for user', 'produced', batches.length, 'batches of accounts to pull');
    for (let i = 0; i < batches.length; i++) {
        const accounts = await (0, getMultipleAccounts_1.getMultipleAccounts)(connection, batches[i], 'single');
        if (accounts) {
            console.log('------->Pulled batch', i, 'with', batches[i].length, 'accounts, processing....');
            for (let j = 0; j < accounts.keys.length; j++) {
                const pubkey = accounts.keys[j];
                await (0, processMetaData_1.processMetaData)({
                    pubkey,
                    account: accounts.array[j],
                }, updateTemp);
            }
        }
        else {
            console.log('------->Failed to pull batch', i, 'skipping');
        }
    }
    await postProcessMetadata(tempCache);
    console.log('-------->User metadata processing complete.');
    return tempCache;
};
exports.pullYourMetadata = pullYourMetadata;
const pullPayoutTickets = async (connection, tempCache) => {
    const updateTemp = (0, exports.makeSetter)(tempCache);
    const forEach = (fn) => async (accounts) => {
        for (const account of accounts) {
            await fn(account, updateTemp);
        }
    };
    (0, web3_1.getProgramAccounts)(connection, ids_1.METAPLEX_ID, {
        filters: [
            {
                dataSize: metaplex_1.MAX_PAYOUT_TICKET_SIZE,
            },
        ],
    }).then(forEach(processMetaplexAccounts_1.processMetaplexAccounts));
    return tempCache;
};
exports.pullPayoutTickets = pullPayoutTickets;
const pullPacks = async (connection, state, walletKey) => {
    const updateTemp = (0, exports.makeSetter)(state);
    const forEach = (fn) => async (accounts) => {
        for (const account of accounts.flat()) {
            await fn(account, updateTemp);
        }
    };
    const store = (0, __1.programIds)().store;
    if (store) {
        await (0, PackSet_1.getPackSets)({ connection, storeId: store }).then(forEach(processPackSets_1.processPackSets));
    }
    // Fetch packs' cards
    const fetchCardsPromises = Object.keys(state.packs).map(packSetKey => (0, PackCard_1.getCardsByPackSet)({ connection, packSetKey }));
    await Promise.all(fetchCardsPromises).then(cards => cards.forEach(forEach(processPackCards_1.processPackCards)));
    const packKeys = Object.keys(state.packs);
    // Fetch vouchers
    const fetchVouchersPromises = packKeys.map(packSetKey => (0, PackVoucher_1.getVouchersByPackSet)({
        connection,
        packSetKey,
    }));
    await Promise.all(fetchVouchersPromises).then(vouchers => vouchers.forEach(forEach(processPackVouchers_1.processPackVouchers)));
    // Fetch proving process if user connected wallet
    if (walletKey) {
        const fetchProvingProcessPromises = packKeys.map(packSetKey => (0, ProvingProcess_1.getProvingProcessByPackSetAndWallet)({
            connection,
            packSetKey,
            walletKey,
        }));
        await Promise.all(fetchProvingProcessPromises).then(provingProcess => provingProcess.forEach(forEach(processProvingProcess_1.processProvingProcess)));
    }
    const metadataKeys = Object.values(state.packCards).map(({ info }) => info.metadata);
    const newState = await (0, exports.pullMetadataByKeys)(connection, state, metadataKeys);
    await pullEditions(connection, updateTemp, newState, metadataKeys.map(m => newState.metadataByMetadata[m]));
    return newState;
};
exports.pullPacks = pullPacks;
const pullPack = async ({ connection, state, packSetKey, walletKey, }) => {
    const updateTemp = (0, exports.makeSetter)(state);
    const packSet = await (0, PackSet_1.getPackSetByPubkey)(connection, packSetKey);
    (0, processPackSets_1.processPackSets)(packSet, updateTemp);
    const packCards = await (0, PackCard_1.getCardsByPackSet)({
        connection,
        packSetKey,
    });
    packCards.forEach(card => (0, processPackCards_1.processPackCards)(card, updateTemp));
    if (walletKey) {
        const provingProcess = await (0, ProvingProcess_1.getProvingProcessByPackSetAndWallet)({
            connection,
            packSetKey,
            walletKey,
        });
        provingProcess.forEach(process => (0, processProvingProcess_1.processProvingProcess)(process, updateTemp));
    }
    const metadataKeys = Object.values(state.packCardsByPackSet[packSetKey] || {}).map(({ info }) => info.metadata);
    const newState = await (0, exports.pullMetadataByKeys)(connection, state, metadataKeys);
    await pullEditions(connection, updateTemp, newState, metadataKeys.map(m => newState.metadataByMetadata[m]));
    return newState;
};
exports.pullPack = pullPack;
const pullAuctionSubaccounts = async (connection, auction, tempCache) => {
    var _a;
    const updateTemp = (0, exports.makeSetter)(tempCache);
    let cacheKey;
    try {
        cacheKey = await (0, metaplex_1.getAuctionCache)(auction);
    }
    catch (e) {
        console.log(e);
        console.log('Failed to get auction cache key');
        return tempCache;
    }
    const cache = (_a = tempCache.auctionCaches[cacheKey]) === null || _a === void 0 ? void 0 : _a.info;
    if (!cache) {
        console.log('-----> No auction cache exists for', auction, 'returning');
        return tempCache;
    }
    const forEach = (fn) => async (accounts) => {
        for (const account of accounts) {
            await fn(account, updateTemp);
        }
    };
    const auctionExtKey = await (0, actions_1.getAuctionExtended)({
        auctionProgramId: ids_1.AUCTION_ID,
        resource: cache.vault,
    });
    const promises = [
        // pull editions
        pullEditions(connection, updateTemp, tempCache, cache.metadata.map(m => tempCache.metadataByMetadata[m])),
        // pull auction data ext
        connection
            .getAccountInfo((0, ids_1.toPublicKey)(auctionExtKey))
            .then(a => a
            ? (0, processAuctions_1.processAuctions)({ pubkey: auctionExtKey, account: a }, updateTemp)
            : null),
        // bidder metadata pull
        (0, web3_1.getProgramAccounts)(connection, ids_1.AUCTION_ID, {
            filters: [
                {
                    memcmp: {
                        offset: 32,
                        bytes: auction,
                    },
                },
            ],
        }).then(forEach(processAuctions_1.processAuctions)),
        // bidder pot pull
        (0, web3_1.getProgramAccounts)(connection, ids_1.AUCTION_ID, {
            filters: [
                {
                    memcmp: {
                        offset: 64,
                        bytes: auction,
                    },
                },
            ],
        }).then(forEach(processAuctions_1.processAuctions)),
        // safety deposit pull
        (0, web3_1.getProgramAccounts)(connection, ids_1.VAULT_ID, {
            filters: [
                {
                    memcmp: {
                        offset: 1,
                        bytes: cache.vault,
                    },
                },
            ],
        }).then(forEach(processVaultData_1.processVaultData)),
        // bid redemptions
        (0, web3_1.getProgramAccounts)(connection, ids_1.METAPLEX_ID, {
            filters: [
                {
                    memcmp: {
                        offset: 10,
                        bytes: cache.auctionManager,
                    },
                },
            ],
        }).then(forEach(processMetaplexAccounts_1.processMetaplexAccounts)),
        // bdis where you arent winner
        (0, web3_1.getProgramAccounts)(connection, ids_1.METAPLEX_ID, {
            filters: [
                {
                    memcmp: {
                        offset: 2,
                        bytes: cache.auctionManager,
                    },
                },
            ],
        }).then(forEach(processMetaplexAccounts_1.processMetaplexAccounts)),
        // safety deposit configs
        (0, web3_1.getProgramAccounts)(connection, ids_1.METAPLEX_ID, {
            filters: [
                {
                    memcmp: {
                        offset: 1,
                        bytes: cache.auctionManager,
                    },
                },
            ],
        }).then(forEach(processMetaplexAccounts_1.processMetaplexAccounts)),
        // prize tracking tickets
        ...cache.metadata
            .map(md => (0, web3_1.getProgramAccounts)(connection, ids_1.METAPLEX_ID, {
            filters: [
                {
                    memcmp: {
                        offset: 1,
                        bytes: md,
                    },
                },
            ],
        }).then(forEach(processMetaplexAccounts_1.processMetaplexAccounts)))
            .flat(),
    ];
    await Promise.all(promises);
    console.log('---------->Pulled sub accounts for auction', auction);
    return tempCache;
};
exports.pullAuctionSubaccounts = pullAuctionSubaccounts;
const pullPages = async (connection) => {
    let i = 0;
    let pageKey = await (0, metaplex_1.getStoreIndexer)(i);
    let account = await connection.getAccountInfo(new web3_js_1.PublicKey(pageKey));
    const pages = [];
    while (account) {
        pages.push({
            info: (0, metaplex_1.decodeStoreIndexer)(account.data),
            pubkey: pageKey,
            account,
        });
        i++;
        pageKey = await (0, metaplex_1.getStoreIndexer)(i);
        account = await connection.getAccountInfo(new web3_js_1.PublicKey(pageKey));
    }
    return pages;
};
exports.pullPages = pullPages;
const pullPage = async (connection, page, tempCache, walletKey, shouldFetchNftPacks) => {
    const updateTemp = (0, exports.makeSetter)(tempCache);
    const forEach = (fn) => async (accounts) => {
        for (const account of accounts) {
            await fn(account, updateTemp);
        }
    };
    const pageKey = await (0, metaplex_1.getStoreIndexer)(page);
    const account = await connection.getAccountInfo(new web3_js_1.PublicKey(pageKey));
    if (account) {
        (0, processMetaplexAccounts_1.processMetaplexAccounts)({
            pubkey: pageKey,
            account,
        }, updateTemp);
        const newPage = tempCache.storeIndexer.find(s => s.pubkey == pageKey);
        const auctionCaches = await (0, getMultipleAccounts_1.getMultipleAccounts)(connection, (newPage === null || newPage === void 0 ? void 0 : newPage.info.auctionCaches) || [], 'single');
        if (auctionCaches && auctionCaches.keys.length) {
            console.log('-------->Page ', page, ' found', auctionCaches.keys.length, ' cached auction data');
            auctionCaches.keys.map((pubkey, i) => {
                (0, processMetaplexAccounts_1.processMetaplexAccounts)({
                    pubkey,
                    account: auctionCaches.array[i],
                }, updateTemp);
            });
            const batches = [];
            let currBatch = [];
            for (let i = 0; i < auctionCaches.keys.length; i++) {
                const cache = tempCache.auctionCaches[auctionCaches.keys[i]];
                const totalNewAccountsToAdd = cache.info.metadata.length + 3;
                if (totalNewAccountsToAdd + currBatch.length >
                    MULTIPLE_ACCOUNT_BATCH_SIZE) {
                    batches.push(currBatch);
                    currBatch = [];
                }
                else {
                    const newAdd = [
                        ...cache.info.metadata,
                        cache.info.auction,
                        cache.info.auctionManager,
                        cache.info.vault,
                    ];
                    currBatch = currBatch.concat(newAdd);
                }
            }
            if (currBatch.length > 0 &&
                currBatch.length <= MULTIPLE_ACCOUNT_BATCH_SIZE) {
                batches.push(currBatch);
            }
            console.log('------> From account caches for page', page, 'produced', batches.length, 'batches of accounts to pull');
            for (let i = 0; i < batches.length; i++) {
                const accounts = await (0, getMultipleAccounts_1.getMultipleAccounts)(connection, batches[i], 'single');
                if (accounts) {
                    console.log('------->Pulled batch', i, 'with', batches[i].length, 'accounts, processing....');
                    for (let i = 0; i < accounts.keys.length; i++) {
                        const pubkey = accounts.keys[i];
                        await (0, processMetaplexAccounts_1.processMetaplexAccounts)({
                            pubkey,
                            account: accounts.array[i],
                        }, updateTemp);
                        await (0, processVaultData_1.processVaultData)({
                            pubkey,
                            account: accounts.array[i],
                        }, updateTemp);
                        await (0, processMetaData_1.processMetaData)({
                            pubkey,
                            account: accounts.array[i],
                        }, updateTemp);
                        await (0, processAuctions_1.processAuctions)({
                            pubkey,
                            account: accounts.array[i],
                        }, updateTemp);
                    }
                }
                else {
                    console.log('------->Failed to pull batch', i, 'skipping');
                }
            }
            for (let i = 0; i < auctionCaches.keys.length; i++) {
                const auctionCache = tempCache.auctionCaches[auctionCaches.keys[i]];
                const metadata = auctionCache.info.metadata.map(s => tempCache.metadataByMetadata[s]);
                tempCache.metadataByAuction[auctionCache.info.auction] = metadata;
            }
        }
        if (shouldFetchNftPacks) {
            await (0, exports.pullPacks)(connection, tempCache, walletKey);
        }
        if (page == 0) {
            console.log('-------->Page 0, pulling creators and store');
            await (0, web3_1.getProgramAccounts)(connection, ids_1.METAPLEX_ID, {
                filters: [
                    {
                        dataSize: models_1.MAX_WHITELISTED_CREATOR_SIZE,
                    },
                ],
            }).then(forEach(processMetaplexAccounts_1.processMetaplexAccounts));
            const store = (0, __1.programIds)().store;
            if (store) {
                const storeAcc = await connection.getAccountInfo(store);
                if (storeAcc) {
                    await (0, processMetaplexAccounts_1.processMetaplexAccounts)({ pubkey: store.toBase58(), account: storeAcc }, updateTemp);
                }
            }
        }
        await postProcessMetadata(tempCache);
    }
    return tempCache;
};
exports.pullPage = pullPage;
const limitedLoadAccounts = async (connection) => {
    const tempCache = (0, getEmptyMetaState_1.getEmptyMetaState)();
    const updateTemp = (0, exports.makeSetter)(tempCache);
    const forEach = (fn) => async (accounts) => {
        for (const account of accounts) {
            await fn(account, updateTemp);
        }
    };
    const pullMetadata = async (metadata) => {
        const mdKey = new web3_js_1.PublicKey(metadata);
        const md = await connection.getAccountInfo(mdKey);
        const mdObject = (0, actions_1.decodeMetadata)(Buffer.from((md === null || md === void 0 ? void 0 : md.data) || new Uint8Array([])));
        const editionKey = await (0, actions_1.getEdition)(mdObject.mint);
        const editionData = await connection.getAccountInfo(new web3_js_1.PublicKey(editionKey));
        if (md) {
            //@ts-ignore
            md.owner = md.owner.toBase58();
            (0, processMetaData_1.processMetaData)({
                pubkey: metadata,
                account: md,
            }, updateTemp);
            if (editionData) {
                //@ts-ignore
                editionData.owner = editionData.owner.toBase58();
                (0, processMetaData_1.processMetaData)({
                    pubkey: editionKey,
                    account: editionData,
                }, updateTemp);
            }
        }
    };
    const pullAuction = async (auction) => {
        const auctionExtendedKey = await (0, actions_1.getAuctionExtended)({
            auctionProgramId: ids_1.AUCTION_ID,
            resource: AUCTION_TO_VAULT[auction],
        });
        const auctionData = await (0, getMultipleAccounts_1.getMultipleAccounts)(connection, [auction, auctionExtendedKey], 'single');
        if (auctionData) {
            auctionData.keys.map((pubkey, i) => {
                (0, processAuctions_1.processAuctions)({
                    pubkey,
                    account: auctionData.array[i],
                }, updateTemp);
            });
        }
    };
    const pullAuctionManager = async (auctionManager) => {
        const auctionManagerKey = new web3_js_1.PublicKey(auctionManager);
        const auctionManagerData = await connection.getAccountInfo(auctionManagerKey);
        if (auctionManagerData) {
            //@ts-ignore
            auctionManagerData.owner = auctionManagerData.owner.toBase58();
            (0, processMetaplexAccounts_1.processMetaplexAccounts)({
                pubkey: auctionManager,
                account: auctionManagerData,
            }, updateTemp);
        }
    };
    const pullVault = async (vault) => {
        const vaultKey = new web3_js_1.PublicKey(vault);
        const vaultData = await connection.getAccountInfo(vaultKey);
        if (vaultData) {
            //@ts-ignore
            vaultData.owner = vaultData.owner.toBase58();
            (0, processVaultData_1.processVaultData)({
                pubkey: vault,
                account: vaultData,
            }, updateTemp);
        }
    };
    const promises = [
        ...WHITELISTED_METADATA.map(md => pullMetadata(md)),
        ...WHITELISTED_AUCTION.map(a => pullAuction(a)),
        ...WHITELISTED_AUCTION_MANAGER.map(a => pullAuctionManager(a)),
        ...WHITELISTED_VAULT.map(a => pullVault(a)),
        // bidder metadata pull
        ...WHITELISTED_AUCTION.map(a => (0, web3_1.getProgramAccounts)(connection, ids_1.AUCTION_ID, {
            filters: [
                {
                    memcmp: {
                        offset: 32,
                        bytes: a,
                    },
                },
            ],
        }).then(forEach(processAuctions_1.processAuctions))),
        // bidder pot pull
        ...WHITELISTED_AUCTION.map(a => (0, web3_1.getProgramAccounts)(connection, ids_1.AUCTION_ID, {
            filters: [
                {
                    memcmp: {
                        offset: 64,
                        bytes: a,
                    },
                },
            ],
        }).then(forEach(processAuctions_1.processAuctions))),
        // safety deposit pull
        ...WHITELISTED_VAULT.map(v => (0, web3_1.getProgramAccounts)(connection, ids_1.VAULT_ID, {
            filters: [
                {
                    memcmp: {
                        offset: 1,
                        bytes: v,
                    },
                },
            ],
        }).then(forEach(processVaultData_1.processVaultData))),
        // bid redemptions
        ...WHITELISTED_AUCTION_MANAGER.map(a => (0, web3_1.getProgramAccounts)(connection, ids_1.METAPLEX_ID, {
            filters: [
                {
                    memcmp: {
                        offset: 9,
                        bytes: a,
                    },
                },
            ],
        }).then(forEach(processMetaplexAccounts_1.processMetaplexAccounts))),
        // safety deposit configs
        ...WHITELISTED_AUCTION_MANAGER.map(a => (0, web3_1.getProgramAccounts)(connection, ids_1.METAPLEX_ID, {
            filters: [
                {
                    memcmp: {
                        offset: 1,
                        bytes: a,
                    },
                },
            ],
        }).then(forEach(processMetaplexAccounts_1.processMetaplexAccounts))),
        // prize tracking tickets
        ...Object.keys(AUCTION_TO_METADATA)
            .map(key => AUCTION_TO_METADATA[key]
            .map(md => (0, web3_1.getProgramAccounts)(connection, ids_1.METAPLEX_ID, {
            filters: [
                {
                    memcmp: {
                        offset: 1,
                        bytes: md,
                    },
                },
            ],
        }).then(forEach(processMetaplexAccounts_1.processMetaplexAccounts)))
            .flat())
            .flat(),
        // whitelisted creators
        (0, web3_1.getProgramAccounts)(connection, ids_1.METAPLEX_ID, {
            filters: [
                {
                    dataSize: models_1.MAX_WHITELISTED_CREATOR_SIZE,
                },
            ],
        }).then(forEach(processMetaplexAccounts_1.processMetaplexAccounts)),
    ];
    await Promise.all(promises);
    await postProcessMetadata(tempCache);
    return tempCache;
};
exports.limitedLoadAccounts = limitedLoadAccounts;
const loadAccounts = async (connection) => {
    const state = (0, getEmptyMetaState_1.getEmptyMetaState)();
    const updateState = (0, exports.makeSetter)(state);
    const forEachAccount = (0, exports.processingAccounts)(updateState);
    const forEach = (fn) => async (accounts) => {
        for (const account of accounts) {
            await fn(account, updateState);
        }
    };
    const loadVaults = () => (0, web3_1.getProgramAccounts)(connection, ids_1.VAULT_ID).then(forEachAccount(processVaultData_1.processVaultData));
    const loadAuctions = () => (0, web3_1.getProgramAccounts)(connection, ids_1.AUCTION_ID).then(forEachAccount(processAuctions_1.processAuctions));
    const loadMetaplex = () => (0, web3_1.getProgramAccounts)(connection, ids_1.METAPLEX_ID).then(forEachAccount(processMetaplexAccounts_1.processMetaplexAccounts));
    const loadCreators = () => (0, web3_1.getProgramAccounts)(connection, ids_1.METAPLEX_ID, {
        filters: [
            {
                dataSize: models_1.MAX_WHITELISTED_CREATOR_SIZE,
            },
        ],
    }).then(forEach(processMetaplexAccounts_1.processMetaplexAccounts));
    const loadMetadata = () => pullMetadataByCreators(connection, state, updateState);
    const loadEditions = () => pullEditions(connection, updateState, state, state.metadata);
    const loading = [
        loadCreators().then(loadMetadata).then(loadEditions),
        loadVaults(),
        loadAuctions(),
        loadMetaplex(),
    ];
    await Promise.all(loading);
    state.metadata = (0, lodash_1.uniqWith)(state.metadata, (a, b) => a.pubkey === b.pubkey);
    return state;
};
exports.loadAccounts = loadAccounts;
const pullEditions = async (connection, updater, state, metadataArr) => {
    console.log('Pulling editions for optimized metadata');
    let setOf100MetadataEditionKeys = [];
    const editionPromises = [];
    const loadBatch = () => {
        editionPromises.push((0, getMultipleAccounts_1.getMultipleAccounts)(connection, setOf100MetadataEditionKeys, 'recent').then(processEditions));
        setOf100MetadataEditionKeys = [];
    };
    const processEditions = (returnedAccounts) => {
        for (let j = 0; j < returnedAccounts.array.length; j++) {
            (0, processMetaData_1.processMetaData)({
                pubkey: returnedAccounts.keys[j],
                account: returnedAccounts.array[j],
            }, updater);
        }
    };
    for (const metadata of metadataArr) {
        // let editionKey: StringPublicKey;
        // TODO the nonce builder isnt working here, figure out why
        //if (metadata.info.editionNonce === null) {
        const editionKey = await (0, actions_1.getEdition)(metadata.info.mint);
        /*} else {
          editionKey = (
            await PublicKey.createProgramAddress(
              [
                Buffer.from(METADATA_PREFIX),
                toPublicKey(METADATA_PROGRAM_ID).toBuffer(),
                toPublicKey(metadata.info.mint).toBuffer(),
                new Uint8Array([metadata.info.editionNonce || 0]),
              ],
              toPublicKey(METADATA_PROGRAM_ID),
            )
          ).toBase58();
        }*/
        setOf100MetadataEditionKeys.push(editionKey);
        if (setOf100MetadataEditionKeys.length >= 100) {
            loadBatch();
        }
    }
    if (setOf100MetadataEditionKeys.length >= 0) {
        loadBatch();
    }
    await Promise.all(editionPromises);
    console.log('Edition size', Object.keys(state.editions).length, Object.keys(state.masterEditions).length);
};
const pullMetadataByCreators = (connection, state, updater) => {
    console.log('pulling optimized nfts');
    const whitelistedCreators = Object.values(state.whitelistedCreatorsByCreator);
    const setter = async (prop, key, value) => {
        if (prop === 'metadataByMint') {
            await (0, exports.initMetadata)(value, state.whitelistedCreatorsByCreator, updater);
        }
        else {
            updater(prop, key, value);
        }
    };
    const forEachAccount = (0, exports.processingAccounts)(setter);
    const additionalPromises = [];
    for (const creator of whitelistedCreators) {
        for (let i = 0; i < actions_1.MAX_CREATOR_LIMIT; i++) {
            const promise = (0, web3_1.getProgramAccounts)(connection, ids_1.METADATA_PROGRAM_ID, {
                filters: [
                    {
                        memcmp: {
                            offset: 1 + // key
                                32 + // update auth
                                32 + // mint
                                4 + // name string length
                                actions_1.MAX_NAME_LENGTH + // name
                                4 + // uri string length
                                actions_1.MAX_URI_LENGTH + // uri
                                4 + // symbol string length
                                actions_1.MAX_SYMBOL_LENGTH + // symbol
                                2 + // seller fee basis points
                                1 + // whether or not there is a creators vec
                                4 + // creators vec length
                                i * actions_1.MAX_CREATOR_LEN,
                            bytes: creator.info.address,
                        },
                    },
                ],
            }).then(forEachAccount(processMetaData_1.processMetaData));
            additionalPromises.push(promise);
        }
    }
    return Promise.all(additionalPromises);
};
const pullMetadataByKeys = async (connection, state, metadataKeys) => {
    const updateState = (0, exports.makeSetter)(state);
    let setOf100MetadataEditionKeys = [];
    const metadataPromises = [];
    const loadBatch = () => {
        metadataPromises.push((0, getMultipleAccounts_1.getMultipleAccounts)(connection, setOf100MetadataEditionKeys, 'recent').then(({ keys, array }) => {
            keys.forEach((key, index) => (0, processMetaData_1.processMetaData)({ pubkey: key, account: array[index] }, updateState));
        }));
        setOf100MetadataEditionKeys = [];
    };
    for (const metadata of metadataKeys) {
        setOf100MetadataEditionKeys.push(metadata);
        if (setOf100MetadataEditionKeys.length >= 100) {
            loadBatch();
        }
    }
    if (setOf100MetadataEditionKeys.length >= 0) {
        loadBatch();
    }
    await Promise.all(metadataPromises);
    return state;
};
exports.pullMetadataByKeys = pullMetadataByKeys;
const makeSetter = (state) => (prop, key, value) => {
    if (prop === 'store') {
        state[prop] = value;
    }
    else if (prop === 'metadata') {
        state.metadata.push(value);
    }
    else if (prop === 'storeIndexer') {
        state.storeIndexer = state.storeIndexer.filter(p => p.info.page.toNumber() != value.info.page.toNumber());
        state.storeIndexer.push(value);
        state.storeIndexer = state.storeIndexer.sort((a, b) => a.info.page.sub(b.info.page).toNumber());
    }
    else if (prop === 'packCardsByPackSet') {
        if (!state.packCardsByPackSet[key]) {
            state.packCardsByPackSet[key] = [];
        }
        const alreadyHasInState = state.packCardsByPackSet[key].some(({ pubkey }) => pubkey === value.pubkey);
        if (!alreadyHasInState) {
            state.packCardsByPackSet[key].push(value);
        }
    }
    else {
        state[prop][key] = value;
    }
    return state;
};
exports.makeSetter = makeSetter;
const processingAccounts = (updater) => (fn) => async (accounts) => {
    await (0, createPipelineExecutor_1.createPipelineExecutor)(accounts.values(), account => fn(account, updater), {
        sequence: 10,
        delay: 1,
        jobsCount: 3,
    });
};
exports.processingAccounts = processingAccounts;
const postProcessMetadata = async (state) => {
    const values = Object.values(state.metadataByMint);
    for (const metadata of values) {
        await (0, exports.metadataByMintUpdater)(metadata, state);
    }
};
const metadataByMintUpdater = async (metadata, state) => {
    var _a;
    const key = metadata.info.mint;
    if ((0, isMetadataPartOfStore_1.isMetadataPartOfStore)(metadata, state.whitelistedCreatorsByCreator)) {
        await metadata.info.init();
        const masterEditionKey = (_a = metadata.info) === null || _a === void 0 ? void 0 : _a.masterEdition;
        if (masterEditionKey) {
            state.metadataByMasterEdition[masterEditionKey] = metadata;
        }
        if (!state.metadata.some(({ pubkey }) => metadata.pubkey === pubkey)) {
            state.metadata.push(metadata);
        }
        state.metadataByMint[key] = metadata;
    }
    else {
        delete state.metadataByMint[key];
    }
    return state;
};
exports.metadataByMintUpdater = metadataByMintUpdater;
const initMetadata = async (metadata, whitelistedCreators, setter) => {
    var _a;
    if ((0, isMetadataPartOfStore_1.isMetadataPartOfStore)(metadata, whitelistedCreators)) {
        await metadata.info.init();
        setter('metadataByMint', metadata.info.mint, metadata);
        setter('metadata', '', metadata);
        const masterEditionKey = (_a = metadata.info) === null || _a === void 0 ? void 0 : _a.masterEdition;
        if (masterEditionKey) {
            setter('metadataByMasterEdition', masterEditionKey, metadata);
        }
    }
};
exports.initMetadata = initMetadata;
//# sourceMappingURL=loadAccounts.js.map

/***/ }),

/***/ 5778:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.useMeta = exports.MetaProvider = void 0;
const react_1 = __importStar(__webpack_require__(9297));
const wallet_adapter_react_1 = __webpack_require__(5772);
const queryExtendedMetadata_1 = __webpack_require__(8005);
const getEmptyMetaState_1 = __webpack_require__(4953);
const loadAccounts_1 = __webpack_require__(9357);
const connection_1 = __webpack_require__(8877);
const store_1 = __webpack_require__(7646);
const actions_1 = __webpack_require__(6618);
const _1 = __webpack_require__(5392);
const __1 = __webpack_require__(9819);
const MetaContext = react_1.default.createContext({
    ...(0, getEmptyMetaState_1.getEmptyMetaState)(),
    isLoading: false,
    isFetching: false,
    // @ts-ignore
    update: () => [actions_1.AuctionData, actions_1.BidderMetadata, actions_1.BidderPot],
});
function MetaProvider({ children = null, }) {
    const connection = (0, connection_1.useConnection)();
    const { isReady, storeAddress } = (0, store_1.useStore)();
    const wallet = (0, wallet_adapter_react_1.useWallet)();
    const [state, setState] = (0, react_1.useState)((0, getEmptyMetaState_1.getEmptyMetaState)());
    const [page, setPage] = (0, react_1.useState)(0);
    const [
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    _lastLength, setLastLength,] = (0, react_1.useState)(0);
    const { userAccounts } = (0, __1.useUserAccounts)();
    const [isLoading, setIsLoading] = (0, react_1.useState)(false);
    const updateRequestsInQueue = (0, react_1.useRef)(0);
    const [isLoadingMetadata, setIsLoadingMetadata] = (0, react_1.useState)(false);
    const loadedMetadataLength = (0, react_1.useRef)(0);
    const updateMints = (0, react_1.useCallback)(async (metadataByMint) => {
        try {
            const { metadata, mintToMetadata } = await (0, queryExtendedMetadata_1.queryExtendedMetadata)(connection, metadataByMint);
            setState(current => ({
                ...current,
                metadata,
                metadataByMint: mintToMetadata,
            }));
        }
        catch (er) {
            console.error(er);
        }
    }, [setState]);
    async function pullAllMetadata() {
        if (isLoading)
            return false;
        if (!storeAddress) {
            if (isReady) {
                setIsLoading(false);
            }
            return;
        }
        else if (!state.store) {
            setIsLoading(true);
        }
        setIsLoading(true);
        const nextState = await (0, _1.pullStoreMetadata)(connection, state);
        setIsLoading(false);
        setState(nextState);
        await updateMints(nextState.metadataByMint);
        return [];
    }
    async function pullBillingPage(auctionAddress) {
        if (isLoading)
            return false;
        if (!storeAddress) {
            if (isReady) {
                setIsLoading(false);
            }
            return;
        }
        else if (!state.store) {
            setIsLoading(true);
        }
        const nextState = await (0, _1.pullAuctionSubaccounts)(connection, auctionAddress, state);
        console.log('-----> Pulling all payout tickets');
        await (0, _1.pullPayoutTickets)(connection, nextState);
        setState(nextState);
        await updateMints(nextState.metadataByMint);
        return [];
    }
    async function pullAuctionPage(auctionAddress) {
        if (isLoading)
            return state;
        if (!storeAddress) {
            if (isReady) {
                setIsLoading(false);
            }
            return state;
        }
        else if (!state.store) {
            setIsLoading(true);
        }
        const nextState = await (0, _1.pullAuctionSubaccounts)(connection, auctionAddress, state);
        setState(nextState);
        await updateMints(nextState.metadataByMint);
        return nextState;
    }
    async function pullItemsPage(userTokenAccounts) {
        if (isFetching) {
            return;
        }
        const shouldEnableNftPacks = process.env.NEXT_ENABLE_NFT_PACKS === 'true';
        const packsState = shouldEnableNftPacks
            ? await (0, _1.pullPacks)(connection, state, wallet === null || wallet === void 0 ? void 0 : wallet.publicKey)
            : state;
        await pullUserMetadata(userTokenAccounts, packsState);
    }
    async function pullPackPage(userTokenAccounts, packSetKey) {
        if (isFetching) {
            return;
        }
        const packState = await (0, _1.pullPack)({
            connection,
            state,
            packSetKey,
            walletKey: wallet === null || wallet === void 0 ? void 0 : wallet.publicKey,
        });
        await pullUserMetadata(userTokenAccounts, packState);
    }
    async function pullUserMetadata(userTokenAccounts, tempState) {
        setIsLoadingMetadata(true);
        loadedMetadataLength.current = userTokenAccounts.length;
        const nextState = await (0, loadAccounts_1.pullYourMetadata)(connection, userTokenAccounts, tempState || state);
        await updateMints(nextState.metadataByMint);
        setState(nextState);
        setIsLoadingMetadata(false);
    }
    async function pullAllSiteData() {
        if (isLoading)
            return state;
        if (!storeAddress) {
            if (isReady) {
                setIsLoading(false);
            }
            return state;
        }
        else if (!state.store) {
            setIsLoading(true);
        }
        console.log('------->Query started');
        const nextState = await (0, loadAccounts_1.loadAccounts)(connection);
        console.log('------->Query finished');
        setState(nextState);
        await updateMints(nextState.metadataByMint);
        return;
    }
    async function update(auctionAddress, bidderAddress) {
        if (!storeAddress) {
            if (isReady) {
                //@ts-ignore
                window.loadingData = false;
                setIsLoading(false);
            }
            return;
        }
        else if (!state.store) {
            //@ts-ignore
            window.loadingData = true;
            setIsLoading(true);
        }
        const shouldFetchNftPacks = process.env.NEXT_ENABLE_NFT_PACKS === 'true';
        let nextState = await (0, _1.pullPage)(connection, page, state, wallet === null || wallet === void 0 ? void 0 : wallet.publicKey, shouldFetchNftPacks);
        console.log('-----> Query started');
        if (nextState.storeIndexer.length) {
            if (loadAccounts_1.USE_SPEED_RUN) {
                nextState = await (0, loadAccounts_1.limitedLoadAccounts)(connection);
                console.log('------->Query finished');
                setState(nextState);
                //@ts-ignore
                window.loadingData = false;
                setIsLoading(false);
            }
            else {
                console.log('------->Pagination detected, pulling page', page);
                const auction = window.location.href.match(/#\/auction\/(\w+)/);
                const billing = window.location.href.match(/#\/auction\/(\w+)\/billing/);
                if (auction && page == 0) {
                    console.log('---------->Loading auction page on initial load, pulling sub accounts');
                    nextState = await (0, _1.pullAuctionSubaccounts)(connection, auction[1], nextState);
                    if (billing) {
                        console.log('-----> Pulling all payout tickets');
                        await (0, _1.pullPayoutTickets)(connection, nextState);
                    }
                }
                let currLastLength;
                setLastLength(last => {
                    currLastLength = last;
                    return last;
                });
                if (nextState.storeIndexer.length != currLastLength) {
                    setPage(page => page + 1);
                }
                setLastLength(nextState.storeIndexer.length);
                //@ts-ignore
                window.loadingData = false;
                setIsLoading(false);
                setState(nextState);
            }
        }
        else {
            console.log('------->No pagination detected');
            nextState = !loadAccounts_1.USE_SPEED_RUN
                ? await (0, loadAccounts_1.loadAccounts)(connection)
                : await (0, loadAccounts_1.limitedLoadAccounts)(connection);
            console.log('------->Query finished');
            setState(nextState);
            //@ts-ignore
            window.loadingData = false;
            setIsLoading(false);
        }
        console.log('------->set finished');
        if (auctionAddress && bidderAddress) {
            nextState = await (0, _1.pullAuctionSubaccounts)(connection, auctionAddress, nextState);
            setState(nextState);
            const auctionBidderKey = auctionAddress + '-' + bidderAddress;
            return [
                nextState.auctions[auctionAddress],
                nextState.bidderPotsByAuctionAndBidder[auctionBidderKey],
                nextState.bidderMetadataByAuctionAndBidder[auctionBidderKey],
            ];
        }
    }
    (0, react_1.useEffect)(() => {
        //@ts-ignore
        if (window.loadingData) {
            console.log('currently another update is running, so queue for 3s...');
            updateRequestsInQueue.current += 1;
            const interval = setInterval(() => {
                //@ts-ignore
                if (window.loadingData) {
                    console.log('not running queued update right now, still loading');
                }
                else {
                    console.log('running queued update');
                    update(undefined, undefined);
                    updateRequestsInQueue.current -= 1;
                    clearInterval(interval);
                }
            }, 3000);
        }
        else {
            console.log('no update is running, updating.');
            update(undefined, undefined);
            updateRequestsInQueue.current = 0;
        }
    }, [
        connection,
        setState,
        updateMints,
        storeAddress,
        isReady,
        page,
    ]);
    // Fetch metadata on userAccounts change
    (0, react_1.useEffect)(() => {
        const shouldFetch = !isLoading &&
            !isLoadingMetadata &&
            loadedMetadataLength.current !== userAccounts.length;
        if (shouldFetch) {
            pullUserMetadata(userAccounts);
        }
    }, [
        isLoading,
        isLoadingMetadata,
        loadedMetadataLength.current,
        userAccounts.length,
    ]);
    const isFetching = isLoading || updateRequestsInQueue.current > 0;
    return (react_1.default.createElement(MetaContext.Provider, { value: {
            ...state,
            // @ts-ignore
            update,
            pullAuctionPage,
            pullAllMetadata,
            pullBillingPage,
            // @ts-ignore
            pullAllSiteData,
            pullItemsPage,
            pullPackPage,
            pullUserMetadata,
            isLoading,
            isFetching,
        } }, children));
}
exports.MetaProvider = MetaProvider;
const useMeta = () => {
    const context = (0, react_1.useContext)(MetaContext);
    return context;
};
exports.useMeta = useMeta;
//# sourceMappingURL=meta.js.map

/***/ }),

/***/ 811:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.onChangeAccount = void 0;
const utils_1 = __webpack_require__(398);
const onChangeAccount = (process, setter) => async (info) => {
    const pubkey = (0, utils_1.pubkeyToString)(info.accountId);
    const account = info.accountInfo;
    await process({
        pubkey,
        account: {
            ...account,
            // to make sure these accounts get processed by processAuctions, processVaultData, etc
            owner: account.owner.toBase58(),
        },
    }, setter);
};
exports.onChangeAccount = onChangeAccount;
//# sourceMappingURL=onChangeAccount.js.map

/***/ }),

/***/ 3680:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.processAuctions = void 0;
const actions_1 = __webpack_require__(6618);
const utils_1 = __webpack_require__(398);
const accounts_1 = __webpack_require__(9834);
const processAuctions = ({ account, pubkey }, setter) => {
    if (!isAuctionAccount(account))
        return;
    try {
        const parsedAccount = accounts_1.cache.add(pubkey, account, actions_1.AuctionParser, false);
        setter('auctions', pubkey, parsedAccount);
    }
    catch (e) {
        // ignore errors
        // add type as first byte for easier deserialization
    }
    try {
        if (isExtendedAuctionAccount(account)) {
            const parsedAccount = accounts_1.cache.add(pubkey, account, actions_1.AuctionDataExtendedParser, false);
            setter('auctionDataExtended', pubkey, parsedAccount);
        }
    }
    catch {
        // ignore errors
        // add type as first byte for easier deserialization
    }
    try {
        if (isBidderMetadataAccount(account)) {
            const parsedAccount = accounts_1.cache.add(pubkey, account, actions_1.BidderMetadataParser, false);
            setter('bidderMetadataByAuctionAndBidder', parsedAccount.info.auctionPubkey +
                '-' +
                parsedAccount.info.bidderPubkey, parsedAccount);
        }
    }
    catch {
        // ignore errors
        // add type as first byte for easier deserialization
    }
    try {
        if (isBidderPotAccount(account)) {
            const parsedAccount = accounts_1.cache.add(pubkey, account, actions_1.BidderPotParser, false);
            setter('bidderPotsByAuctionAndBidder', parsedAccount.info.auctionAct + '-' + parsedAccount.info.bidderAct, parsedAccount);
        }
    }
    catch {
        // ignore errors
        // add type as first byte for easier deserialization
    }
};
exports.processAuctions = processAuctions;
const isAuctionAccount = account => account && (0, utils_1.pubkeyToString)(account.owner) === utils_1.AUCTION_ID;
const isExtendedAuctionAccount = account => account.data.length === actions_1.MAX_AUCTION_DATA_EXTENDED_SIZE;
const isBidderMetadataAccount = account => account.data.length === actions_1.BIDDER_METADATA_LEN;
const isBidderPotAccount = account => account.data.length === actions_1.BIDDER_POT_LEN;
//# sourceMappingURL=processAuctions.js.map

/***/ }),

/***/ 3881:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.processMetaData = void 0;
const isValidHttpUrl_1 = __webpack_require__(3923);
const actions_1 = __webpack_require__(6618);
const utils_1 = __webpack_require__(398);
const processMetaData = async ({ account, pubkey }, setter) => {
    if (!isMetadataAccount(account))
        return;
    try {
        if (isMetadataV1Account(account)) {
            const metadata = (0, actions_1.decodeMetadata)(account.data);
            if ((0, isValidHttpUrl_1.isValidHttpUrl)(metadata.data.uri)) {
                const parsedAccount = {
                    pubkey,
                    account,
                    info: metadata,
                };
                await setter('metadataByMint', metadata.mint, parsedAccount);
                await setter('metadataByMetadata', pubkey, parsedAccount);
            }
        }
        if (isEditionV1Account(account)) {
            const edition = (0, actions_1.decodeEdition)(account.data);
            const parsedAccount = {
                pubkey,
                account,
                info: edition,
            };
            setter('editions', pubkey, parsedAccount);
        }
        if (isMasterEditionAccount(account)) {
            const masterEdition = (0, actions_1.decodeMasterEdition)(account.data);
            if (isMasterEditionV1(masterEdition)) {
                const parsedAccount = {
                    pubkey,
                    account,
                    info: masterEdition,
                };
                setter('masterEditions', pubkey, parsedAccount);
                setter('masterEditionsByPrintingMint', masterEdition.printingMint, parsedAccount);
                setter('masterEditionsByOneTimeAuthMint', masterEdition.oneTimePrintingAuthorizationMint, parsedAccount);
            }
            else {
                const parsedAccount = {
                    pubkey,
                    account,
                    info: masterEdition,
                };
                setter('masterEditions', pubkey, parsedAccount);
            }
        }
    }
    catch {
        // ignore errors
        // add type as first byte for easier deserialization
    }
};
exports.processMetaData = processMetaData;
const isMetadataAccount = (account) => account && (0, utils_1.pubkeyToString)(account.owner) === utils_1.METADATA_PROGRAM_ID;
const isMetadataV1Account = (account) => account.data[0] === actions_1.MetadataKey.MetadataV1;
const isEditionV1Account = (account) => account.data[0] === actions_1.MetadataKey.EditionV1;
const isMasterEditionAccount = (account) => account.data[0] === actions_1.MetadataKey.MasterEditionV1 ||
    account.data[0] === actions_1.MetadataKey.MasterEditionV2;
const isMasterEditionV1 = (me) => {
    return me.key === actions_1.MetadataKey.MasterEditionV1;
};
//# sourceMappingURL=processMetaData.js.map

/***/ }),

/***/ 7067:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.processMetaplexAccounts = void 0;
const web3_js_1 = __webpack_require__(5681);
const models_1 = __webpack_require__(5460);
const utils_1 = __webpack_require__(398);
const accounts_1 = __webpack_require__(9834);
const userNames_json_1 = __importDefault(__webpack_require__(760));
const processMetaplexAccounts = async ({ account, pubkey }, setter) => {
    if (!isMetaplexAccount(account))
        return;
    try {
        const STORE_ID = (0, utils_1.programIds)().store;
        if (isAuctionManagerV1Account(account) ||
            isAuctionManagerV2Account(account)) {
            const storeKey = new web3_js_1.PublicKey(account.data.slice(1, 33));
            if (STORE_ID && storeKey.equals(STORE_ID)) {
                const auctionManager = (0, models_1.decodeAuctionManager)(account.data);
                const parsedAccount = {
                    pubkey,
                    account,
                    info: auctionManager,
                };
                setter('auctionManagersByAuction', auctionManager.auction, parsedAccount);
            }
        }
        if (isBidRedemptionTicketV1Account(account) ||
            isBidRedemptionTicketV2Account(account)) {
            const ticket = (0, models_1.decodeBidRedemptionTicket)(account.data);
            const parsedAccount = {
                pubkey,
                account,
                info: ticket,
            };
            setter('bidRedemptions', pubkey, parsedAccount);
            if (ticket.key == models_1.MetaplexKey.BidRedemptionTicketV2) {
                const asV2 = ticket;
                if (asV2.winnerIndex) {
                    setter('bidRedemptionV2sByAuctionManagerAndWinningIndex', asV2.auctionManager + '-' + asV2.winnerIndex.toNumber(), parsedAccount);
                }
            }
        }
        if (isPayoutTicketV1Account(account)) {
            const ticket = (0, models_1.decodePayoutTicket)(account.data);
            const parsedAccount = {
                pubkey,
                account,
                info: ticket,
            };
            setter('payoutTickets', pubkey, parsedAccount);
        }
        if (isAuctionCacheV1Account(account)) {
            const cache = (0, models_1.decodeAuctionCache)(account.data);
            const parsedAccount = {
                pubkey,
                account,
                info: cache,
            };
            setter('auctionCaches', pubkey, parsedAccount);
        }
        if (isStoreIndexerV1Account(account)) {
            const indexer = (0, models_1.decodeStoreIndexer)(account.data);
            const parsedAccount = {
                pubkey,
                account,
                info: indexer,
            };
            if (parsedAccount.info.store == (STORE_ID === null || STORE_ID === void 0 ? void 0 : STORE_ID.toBase58())) {
                setter('storeIndexer', pubkey, parsedAccount);
            }
        }
        if (isPrizeTrackingTicketV1Account(account)) {
            const ticket = (0, models_1.decodePrizeTrackingTicket)(account.data);
            const parsedAccount = {
                pubkey,
                account,
                info: ticket,
            };
            setter('prizeTrackingTickets', pubkey, parsedAccount);
        }
        if (isStoreV1Account(account)) {
            const store = (0, models_1.decodeStore)(account.data);
            const parsedAccount = {
                pubkey,
                account,
                info: store,
            };
            if (STORE_ID && pubkey === STORE_ID.toBase58()) {
                setter('store', pubkey, parsedAccount);
            }
        }
        if (isSafetyDepositConfigV1Account(account)) {
            const config = (0, models_1.decodeSafetyDepositConfig)(account.data);
            const parsedAccount = {
                pubkey,
                account,
                info: config,
            };
            setter('safetyDepositConfigsByAuctionManagerAndIndex', config.auctionManager + '-' + config.order.toNumber(), parsedAccount);
        }
        if (isWhitelistedCreatorV1Account(account)) {
            const parsedAccount = accounts_1.cache.add(pubkey, account, models_1.WhitelistedCreatorParser, false);
            // TODO: figure out a way to avoid generating creator addresses during parsing
            // should we store store id inside creator?
            if (STORE_ID) {
                const isWhitelistedCreator = await (0, models_1.isCreatorPartOfTheStore)(parsedAccount.info.address, pubkey);
                const nameInfo = userNames_json_1.default[parsedAccount.info.address];
                if (nameInfo) {
                    parsedAccount.info = { ...parsedAccount.info, ...nameInfo };
                }
                if (isWhitelistedCreator) {
                    setter('whitelistedCreatorsByCreator', parsedAccount.info.address, parsedAccount);
                }
            }
        }
    }
    catch {
        // ignore errors
        // add type as first byte for easier deserialization
    }
};
exports.processMetaplexAccounts = processMetaplexAccounts;
const isMetaplexAccount = (account) => account && (0, utils_1.pubkeyToString)(account.owner) === utils_1.METAPLEX_ID;
const isAuctionManagerV1Account = (account) => account.data[0] === models_1.MetaplexKey.AuctionManagerV1;
const isAuctionManagerV2Account = (account) => account.data[0] === models_1.MetaplexKey.AuctionManagerV2;
const isBidRedemptionTicketV1Account = (account) => account.data[0] === models_1.MetaplexKey.BidRedemptionTicketV1;
const isBidRedemptionTicketV2Account = (account) => account.data[0] === models_1.MetaplexKey.BidRedemptionTicketV2;
const isPayoutTicketV1Account = (account) => account.data[0] === models_1.MetaplexKey.PayoutTicketV1;
const isPrizeTrackingTicketV1Account = (account) => account.data[0] === models_1.MetaplexKey.PrizeTrackingTicketV1;
const isStoreV1Account = (account) => account.data[0] === models_1.MetaplexKey.StoreV1;
const isSafetyDepositConfigV1Account = (account) => account.data[0] === models_1.MetaplexKey.SafetyDepositConfigV1;
const isWhitelistedCreatorV1Account = (account) => account.data[0] === models_1.MetaplexKey.WhitelistedCreatorV1;
const isAuctionCacheV1Account = (account) => account.data[0] === models_1.MetaplexKey.AuctionCacheV1;
const isStoreIndexerV1Account = (account) => account.data[0] === models_1.MetaplexKey.StoreIndexerV1;
//# sourceMappingURL=processMetaplexAccounts.js.map

/***/ }),

/***/ 8891:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.processPackCards = void 0;
const __1 = __webpack_require__(9819);
const PackCard_1 = __webpack_require__(7290);
const utils_1 = __webpack_require__(398);
const processPackCards = ({ account, pubkey }, setter) => {
    if (!isPackAccount(account))
        return;
    try {
        if (isPackCardAccount(account)) {
            const packCard = (0, PackCard_1.decodePackCard)(account.data);
            const parsedAccount = {
                pubkey,
                account: account,
                info: packCard,
            };
            setter('packCards', pubkey, parsedAccount);
            setter('packCardsByPackSet', packCard.packSet, parsedAccount);
        }
    }
    catch {
        // ignore errors
        // add type as first byte for easier deserialization
    }
};
exports.processPackCards = processPackCards;
const isPackAccount = (account) => account && (0, utils_1.pubkeyToString)(account.owner) === utils_1.PACK_CREATE_ID.toString();
const isPackCardAccount = (account) => account.data[0] === __1.PackKey.PackCard;
//# sourceMappingURL=processPackCards.js.map

/***/ }),

/***/ 8094:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.processPackSets = void 0;
const __1 = __webpack_require__(9819);
const PackSet_1 = __webpack_require__(6160);
const utils_1 = __webpack_require__(398);
const processPackSets = ({ account, pubkey }, setter) => {
    if (!isPackAccount(account))
        return;
    try {
        if (isPackSetAccount(account)) {
            const packSet = (0, PackSet_1.decodePackSet)(account.data);
            const parsedAccount = {
                pubkey,
                account: account,
                info: packSet,
            };
            setter('packs', pubkey, parsedAccount);
        }
    }
    catch {
        // ignore errors
        // add type as first byte for easier deserialization
    }
};
exports.processPackSets = processPackSets;
const isPackAccount = (account) => account && (0, utils_1.pubkeyToString)(account.owner) === utils_1.PACK_CREATE_ID.toString();
const isPackSetAccount = (account) => account.data[0] === __1.PackKey.PackSet;
//# sourceMappingURL=processPackSets.js.map

/***/ }),

/***/ 7571:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.processPackVouchers = void 0;
const __1 = __webpack_require__(9819);
const PackVoucher_1 = __webpack_require__(6575);
const utils_1 = __webpack_require__(398);
const processPackVouchers = ({ account, pubkey }, setter) => {
    if (!isPackAccount(account))
        return;
    try {
        if (isPackVoucherAccount(account)) {
            const packVoucher = (0, PackVoucher_1.decodePackVoucher)(account.data);
            const parsedAccount = {
                pubkey,
                account: account,
                info: packVoucher,
            };
            setter('vouchers', pubkey, parsedAccount);
        }
    }
    catch {
        // ignore errors
        // add type as first byte for easier deserialization
    }
};
exports.processPackVouchers = processPackVouchers;
const isPackAccount = (account) => account && (0, utils_1.pubkeyToString)(account.owner) === utils_1.PACK_CREATE_ID.toString();
const isPackVoucherAccount = (account) => account.data[0] === __1.PackKey.PackVoucher;
//# sourceMappingURL=processPackVouchers.js.map

/***/ }),

/***/ 6130:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.processProvingProcess = void 0;
const __1 = __webpack_require__(9819);
const ProvingProcess_1 = __webpack_require__(9437);
const utils_1 = __webpack_require__(398);
const processProvingProcess = ({ account, pubkey }, setter) => {
    if (!isPackAccount(account))
        return;
    try {
        if (isPackProvingProcessAccount(account)) {
            const provingProcess = (0, ProvingProcess_1.decodePackProvingProcess)(account.data);
            const parsedAccount = {
                pubkey,
                account: account,
                info: provingProcess,
            };
            setter('provingProcesses', pubkey, parsedAccount);
        }
    }
    catch {
        // ignore errors
        // add type as first byte for easier deserialization
    }
};
exports.processProvingProcess = processProvingProcess;
const isPackAccount = (account) => account && (0, utils_1.pubkeyToString)(account.owner) === utils_1.PACK_CREATE_ID.toString();
const isPackProvingProcessAccount = (account) => account.data[0] === __1.PackKey.ProvingProcess;
//# sourceMappingURL=processProvingProcess.js.map

/***/ }),

/***/ 8317:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.processVaultData = void 0;
const actions_1 = __webpack_require__(6618);
const utils_1 = __webpack_require__(398);
const processVaultData = ({ account, pubkey }, setter) => {
    if (!isVaultAccount(account))
        return;
    try {
        if (isSafetyDepositBoxV1Account(account)) {
            const safetyDeposit = (0, actions_1.decodeSafetyDeposit)(account.data);
            const parsedAccount = {
                pubkey,
                account: account,
                info: safetyDeposit,
            };
            setter('safetyDepositBoxesByVaultAndIndex', safetyDeposit.vault + '-' + safetyDeposit.order, parsedAccount);
        }
        if (isVaultV1Account(account)) {
            const vault = (0, actions_1.decodeVault)(account.data);
            const parsedAccount = {
                pubkey,
                account: account,
                info: vault,
            };
            setter('vaults', pubkey, parsedAccount);
        }
    }
    catch {
        // ignore errors
        // add type as first byte for easier deserialization
    }
};
exports.processVaultData = processVaultData;
const isVaultAccount = (account) => account && (0, utils_1.pubkeyToString)(account.owner) === utils_1.VAULT_ID;
const isSafetyDepositBoxV1Account = (account) => account.data[0] === actions_1.VaultKey.SafetyDepositBoxV1;
const isVaultV1Account = (account) => account.data[0] === actions_1.VaultKey.VaultV1;
//# sourceMappingURL=processVaultData.js.map

/***/ }),

/***/ 8005:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.queryExtendedMetadata = void 0;
const accounts_1 = __webpack_require__(9834);
const accounts_2 = __webpack_require__(9834);
const accounts_3 = __webpack_require__(9834);
const queryExtendedMetadata = async (connection, mintToMeta) => {
    const mintToMetadata = { ...mintToMeta };
    const mints = await (0, accounts_2.getMultipleAccounts)(connection, [...Object.keys(mintToMetadata)].filter(k => !accounts_1.cache.get(k)), 'single');
    mints.keys.forEach((key, index) => {
        const mintAccount = mints.array[index];
        if (mintAccount) {
            const mint = accounts_1.cache.add(key, mintAccount, accounts_3.MintParser, false);
            if (!mint.info.supply.eqn(1) || mint.info.decimals !== 0) {
                // naive not NFT check
                delete mintToMetadata[key];
            }
            else {
                // const metadata = mintToMetadata[key];
            }
        }
    });
    // await Promise.all([...extendedMetadataFetch.values()]);
    const metadata = [...Object.values(mintToMetadata)];
    return {
        metadata,
        mintToMetadata,
    };
};
exports.queryExtendedMetadata = queryExtendedMetadata;
//# sourceMappingURL=queryExtendedMetadata.js.map

/***/ }),

/***/ 3445:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.subscribeAccountsChange = void 0;
const utils_1 = __webpack_require__(398);
const loadAccounts_1 = __webpack_require__(9357);
const onChangeAccount_1 = __webpack_require__(811);
const processAuctions_1 = __webpack_require__(3680);
const processMetaData_1 = __webpack_require__(3881);
const processMetaplexAccounts_1 = __webpack_require__(7067);
const processVaultData_1 = __webpack_require__(8317);
const subscribeAccountsChange = (connection, getState, setState) => {
    const subscriptions = [];
    const updateStateValue = (prop, key, value) => {
        const state = getState();
        const nextState = (0, loadAccounts_1.makeSetter)({ ...state })(prop, key, value);
        setState(nextState);
    };
    subscriptions.push(connection.onProgramAccountChange((0, utils_1.toPublicKey)(utils_1.VAULT_ID), (0, onChangeAccount_1.onChangeAccount)(processVaultData_1.processVaultData, updateStateValue)));
    subscriptions.push(connection.onProgramAccountChange((0, utils_1.toPublicKey)(utils_1.AUCTION_ID), (0, onChangeAccount_1.onChangeAccount)(processAuctions_1.processAuctions, updateStateValue)));
    subscriptions.push(connection.onProgramAccountChange((0, utils_1.toPublicKey)(utils_1.METAPLEX_ID), (0, onChangeAccount_1.onChangeAccount)(processMetaplexAccounts_1.processMetaplexAccounts, updateStateValue)));
    subscriptions.push(connection.onProgramAccountChange((0, utils_1.toPublicKey)(utils_1.METADATA_PROGRAM_ID), (0, onChangeAccount_1.onChangeAccount)(processMetaData_1.processMetaData, async (prop, key, value) => {
        const state = { ...getState() };
        const setter = (0, loadAccounts_1.makeSetter)(state);
        let hasChanges = false;
        const updater = (...args) => {
            hasChanges = true;
            setter(...args);
        };
        if (prop === 'metadataByMint') {
            await (0, loadAccounts_1.initMetadata)(value, state.whitelistedCreatorsByCreator, updater);
        }
        else {
            updater(prop, key, value);
        }
        if (hasChanges) {
            setState(state);
        }
    })));
    return () => {
        subscriptions.forEach(subscriptionId => {
            connection.removeProgramAccountChangeListener(subscriptionId);
        });
    };
};
exports.subscribeAccountsChange = subscribeAccountsChange;
//# sourceMappingURL=subscribeAccountsChange.js.map

/***/ }),

/***/ 7857:
/***/ ((__unused_webpack_module, exports) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
//# sourceMappingURL=types.js.map

/***/ }),

/***/ 8460:
/***/ ((__unused_webpack_module, exports) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.unsafeResAccounts = exports.unsafeAccount = exports.getProgramAccounts = void 0;
async function getProgramAccounts(connection, programId, configOrCommitment) {
    const extra = {};
    let commitment;
    //let encoding;
    if (configOrCommitment) {
        if (typeof configOrCommitment === 'string') {
            commitment = configOrCommitment;
        }
        else {
            commitment = configOrCommitment.commitment;
            //encoding = configOrCommitment.encoding;
            if (configOrCommitment.dataSlice) {
                extra.dataSlice = configOrCommitment.dataSlice;
            }
            if (configOrCommitment.filters) {
                extra.filters = configOrCommitment.filters;
            }
        }
    }
    const args = connection._buildArgs([programId], commitment, 'base64', extra);
    const unsafeRes = await connection._rpcRequest('getProgramAccounts', args);
    return unsafeResAccounts(unsafeRes.result);
}
exports.getProgramAccounts = getProgramAccounts;
function unsafeAccount(account) {
    return {
        // TODO: possible delay parsing could be added here
        data: Buffer.from(account.data[0], 'base64'),
        executable: account.executable,
        lamports: account.lamports,
        // TODO: maybe we can do it in lazy way? or just use string
        owner: account.owner,
    };
}
exports.unsafeAccount = unsafeAccount;
function unsafeResAccounts(data) {
    return data.map(item => ({
        account: unsafeAccount(item.account),
        pubkey: item.pubkey,
    }));
}
exports.unsafeResAccounts = unsafeResAccounts;
//# sourceMappingURL=web3.js.map

/***/ }),

/***/ 7646:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.useStore = exports.StoreProvider = exports.StoreContext = void 0;
const react_1 = __importStar(__webpack_require__(9297));
const utils_1 = __webpack_require__(398);
const hooks_1 = __webpack_require__(5902);
exports.StoreContext = (0, react_1.createContext)(null);
const StoreProvider = ({ children, ownerAddress, storeAddress }) => {
    const searchParams = (0, hooks_1.useQuerySearch)();
    const ownerAddressFromQuery = searchParams.get('store');
    const initOwnerAddress = ownerAddressFromQuery || ownerAddress;
    const initStoreAddress = !ownerAddressFromQuery ? storeAddress : undefined;
    const isConfigured = Boolean(initStoreAddress || initOwnerAddress);
    const [store, setStore] = (0, react_1.useState)({
        storeAddress: initStoreAddress,
        isReady: Boolean(!initOwnerAddress || initStoreAddress),
    });
    const setStoreForOwner = (0, react_1.useMemo)(() => async (ownerAddress) => {
        const storeAddress = await (0, utils_1.getStoreID)(ownerAddress);
        (0, utils_1.setProgramIds)(storeAddress); // fallback
        setStore({ storeAddress, isReady: true });
        console.log(`CUSTOM STORE: ${storeAddress}`);
        return storeAddress;
    }, []);
    (0, react_1.useEffect)(() => {
        console.log(`STORE_OWNER_ADDRESS: ${initOwnerAddress}`);
        if (initOwnerAddress && !initStoreAddress) {
            setStoreForOwner(initOwnerAddress);
        }
        else {
            (0, utils_1.setProgramIds)(initStoreAddress); // fallback
            console.log(`CUSTOM STORE FROM ENV: ${initStoreAddress}`);
        }
    }, [initOwnerAddress]);
    return (react_1.default.createElement(exports.StoreContext.Provider, { value: { ...store, setStoreForOwner, isConfigured } }, children));
};
exports.StoreProvider = StoreProvider;
const useStore = () => {
    return (0, react_1.useContext)(exports.StoreContext);
};
exports.useStore = useStore;
//# sourceMappingURL=store.js.map

/***/ }),

/***/ 3115:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.WalletProvider = exports.WalletModalProvider = exports.WalletModal = exports.useWalletModal = exports.WalletModalContext = void 0;
const wallet_adapter_react_1 = __webpack_require__(5772);
const wallet_adapter_wallets_1 = __webpack_require__(965);
const antd_1 = __webpack_require__(953);
const react_1 = __importStar(__webpack_require__(9297));
const utils_1 = __webpack_require__(398);
const components_1 = __webpack_require__(2878);
const { Panel } = antd_1.Collapse;
exports.WalletModalContext = (0, react_1.createContext)({});
function useWalletModal() {
    return (0, react_1.useContext)(exports.WalletModalContext);
}
exports.useWalletModal = useWalletModal;
const WalletModal = () => {
    const { wallets, select } = (0, wallet_adapter_react_1.useWallet)();
    const { visible, setVisible } = useWalletModal();
    const close = (0, react_1.useCallback)(() => {
        setVisible(false);
    }, [setVisible]);
    const phatomWallet = (0, react_1.useMemo)(() => (0, wallet_adapter_wallets_1.getPhantomWallet)(), []);
    return (react_1.default.createElement(components_1.MetaplexModal, { title: "Connect Wallet", visible: visible, onCancel: close },
        react_1.default.createElement("span", { style: {
                color: 'rgba(255, 255, 255, 0.75)',
                fontSize: '14px',
                lineHeight: '14px',
                fontFamily: 'GraphikWeb',
                letterSpacing: '0.02em',
                marginBottom: 14,
            } }, "RECOMMENDED"),
        react_1.default.createElement(antd_1.Button, { className: "phantom-button metaplex-button", onClick: () => {
                console.log(phatomWallet.name);
                select(phatomWallet.name);
                close();
            } },
            react_1.default.createElement("img", { src: phatomWallet === null || phatomWallet === void 0 ? void 0 : phatomWallet.icon, style: { width: '1.2rem' } }),
            "\u00A0Connect to Phantom"),
        react_1.default.createElement(antd_1.Collapse, { ghost: true, expandIcon: panelProps => panelProps.isActive ? (react_1.default.createElement("svg", { width: "20", height: "20", viewBox: "0 0 20 20", fill: "none", xmlns: "http://www.w3.org/2000/svg" },
                react_1.default.createElement("path", { d: "M15 7.5L10 12.5L5 7.5", stroke: "white", strokeWidth: "2", strokeLinecap: "round", strokeLinejoin: "round" }))) : (react_1.default.createElement("svg", { width: "20", height: "20", viewBox: "0 0 20 20", fill: "none", xmlns: "http://www.w3.org/2000/svg" },
                react_1.default.createElement("path", { d: "M7.5 5L12.5 10L7.5 15", stroke: "white", strokeWidth: "2", strokeLinecap: "round", strokeLinejoin: "round" }))) },
            react_1.default.createElement(Panel, { header: react_1.default.createElement("span", { style: {
                        fontWeight: 600,
                        fontSize: '16px',
                        lineHeight: '16px',
                        letterSpacing: '-0.01em',
                        color: 'rgba(255, 255, 255, 255)',
                    } }, "Other Wallets"), key: "1" }, wallets.map((wallet, idx) => {
                if (wallet.name === 'Phantom')
                    return null;
                return (react_1.default.createElement(antd_1.Button, { key: idx, className: "metaplex-button w100", style: {
                        marginBottom: 5,
                    }, onClick: () => {
                        select(wallet.name);
                        close();
                    } },
                    "Connect to ",
                    wallet.name));
            })))));
};
exports.WalletModal = WalletModal;
const WalletModalProvider = ({ children, }) => {
    const { publicKey } = (0, wallet_adapter_react_1.useWallet)();
    const [connected, setConnected] = (0, react_1.useState)(!!publicKey);
    const [visible, setVisible] = (0, react_1.useState)(false);
    (0, react_1.useEffect)(() => {
        if (publicKey) {
            const base58 = publicKey.toBase58();
            const keyToDisplay = base58.length > 20
                ? `${base58.substring(0, 7)}.....${base58.substring(base58.length - 7, base58.length)}`
                : base58;
            (0, utils_1.notify)({
                message: 'Wallet update',
                description: 'Connected to wallet ' + keyToDisplay,
            });
        }
    }, [publicKey]);
    (0, react_1.useEffect)(() => {
        if (!publicKey && connected) {
            (0, utils_1.notify)({
                message: 'Wallet update',
                description: 'Disconnected from wallet',
            });
        }
        setConnected(!!publicKey);
    }, [publicKey, connected, setConnected]);
    return (react_1.default.createElement(exports.WalletModalContext.Provider, { value: {
            visible,
            setVisible,
        } },
        children,
        react_1.default.createElement(exports.WalletModal, null)));
};
exports.WalletModalProvider = WalletModalProvider;
const WalletProvider = ({ children }) => {
    const wallets = (0, react_1.useMemo)(() => [
        (0, wallet_adapter_wallets_1.getPhantomWallet)(),
        (0, wallet_adapter_wallets_1.getSolflareWallet)(),
        (0, wallet_adapter_wallets_1.getSlopeWallet)(),
        // getTorusWallet({
        //   options: {
        //     // @FIXME: this should be changed for Metaplex, and by each Metaplex storefront
        //     clientId:
        //       'BOM5Cl7PXgE9Ylq1Z1tqzhpydY0RVr8k90QQ85N7AKI5QGSrr9iDC-3rvmy0K_hF0JfpLMiXoDhta68JwcxS1LQ',
        //   },
        // }),
        (0, wallet_adapter_wallets_1.getLedgerWallet)(),
        (0, wallet_adapter_wallets_1.getSolongWallet)(),
        (0, wallet_adapter_wallets_1.getMathWallet)(),
        (0, wallet_adapter_wallets_1.getSolletWallet)(),
    ], []);
    const onError = (0, react_1.useCallback)((error) => {
        console.error(error);
        (0, utils_1.notify)({
            message: 'Wallet error',
            description: error.message,
        });
    }, []);
    return (react_1.default.createElement(wallet_adapter_react_1.WalletProvider, { wallets: wallets, onError: onError, autoConnect: true },
        react_1.default.createElement(exports.WalletModalProvider, null, children)));
};
exports.WalletProvider = WalletProvider;
//# sourceMappingURL=wallet.js.map

/***/ }),

/***/ 5902:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
__exportStar(__webpack_require__(8911), exports);
__exportStar(__webpack_require__(3801), exports);
__exportStar(__webpack_require__(6531), exports);
__exportStar(__webpack_require__(1114), exports);
__exportStar(__webpack_require__(8991), exports);
//# sourceMappingURL=index.js.map

/***/ }),

/***/ 3801:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.useAccountByMint = void 0;
const useUserAccounts_1 = __webpack_require__(8911);
const useAccountByMint = (mint) => {
    const { userAccounts } = (0, useUserAccounts_1.useUserAccounts)();
    const mintAddress = typeof mint === 'string' ? mint : mint === null || mint === void 0 ? void 0 : mint.toBase58();
    const index = userAccounts.findIndex(acc => acc.info.mint.toBase58() === mintAddress);
    if (index !== -1) {
        return userAccounts[index];
    }
    return;
};
exports.useAccountByMint = useAccountByMint;
//# sourceMappingURL=useAccountByMint.js.map

/***/ }),

/***/ 8991:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.useQuerySearch = void 0;
const react_1 = __webpack_require__(9297);
const react_router_dom_1 = __webpack_require__(2146);
function useQuerySearch() {
    const { search } = (0, react_router_dom_1.useLocation)();
    return (0, react_1.useMemo)(() => new URLSearchParams(search), [search]);
}
exports.useQuerySearch = useQuerySearch;
//# sourceMappingURL=useQuerySearch.js.map

/***/ }),

/***/ 1114:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.useThatState = void 0;
const react_1 = __webpack_require__(9297);
// Extends useState() hook with async getThatState getter which can be used to get state value in contexts (ex. async callbacks) where up to date state is not available
function useThatState(initialState) {
    const [state, setState] = (0, react_1.useState)(initialState);
    const getThatState = () => new Promise(resolve => {
        // Use NOP setState call to retrieve current state value
        setState(s => {
            resolve(s);
            return s;
        });
    });
    return [state, setState, getThatState];
}
exports.useThatState = useThatState;
//# sourceMappingURL=useThatState.js.map

/***/ }),

/***/ 6531:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.useTokenName = void 0;
const connection_1 = __webpack_require__(8877);
const utils_1 = __webpack_require__(7392);
function useTokenName(mintAddress) {
    const { tokens } = (0, connection_1.useConnectionConfig)();
    const address = typeof mintAddress === 'string' ? mintAddress : mintAddress === null || mintAddress === void 0 ? void 0 : mintAddress.toBase58();
    return (0, utils_1.getTokenName)(tokens, address);
}
exports.useTokenName = useTokenName;
//# sourceMappingURL=useTokenName.js.map

/***/ }),

/***/ 8911:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.useUserAccounts = void 0;
const accounts_1 = __webpack_require__(9834);
function useUserAccounts() {
    const context = (0, accounts_1.useAccountsContext)();
    const accountByMint = context.userAccounts.reduce((prev, acc) => {
        prev.set(acc.info.mint.toBase58(), acc);
        return prev;
    }, new Map());
    return {
        userAccounts: context.userAccounts,
        accountByMint,
    };
}
exports.useUserAccounts = useUserAccounts;
//# sourceMappingURL=useUserAccounts.js.map

/***/ }),

/***/ 9819:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.utils = exports.models = exports.contexts = exports.hooks = exports.constants = exports.components = exports.actions = void 0;
exports.actions = __importStar(__webpack_require__(6618));
__exportStar(__webpack_require__(6618), exports);
exports.components = __importStar(__webpack_require__(2878));
__exportStar(__webpack_require__(2878), exports);
exports.constants = __importStar(__webpack_require__(7093));
__exportStar(__webpack_require__(7093), exports);
exports.hooks = __importStar(__webpack_require__(5902));
__exportStar(__webpack_require__(5902), exports);
exports.contexts = __importStar(__webpack_require__(3049));
__exportStar(__webpack_require__(3049), exports);
exports.models = __importStar(__webpack_require__(5460));
__exportStar(__webpack_require__(5460), exports);
exports.utils = __importStar(__webpack_require__(398));
__exportStar(__webpack_require__(398), exports);
//# sourceMappingURL=index.js.map

/***/ }),

/***/ 1161:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.approve = exports.ParsedDataLayout = void 0;
const web3_js_1 = __webpack_require__(5681);
const spl_token_1 = __webpack_require__(5653);
const ids_1 = __webpack_require__(9556);
const buffer_layout_1 = __importDefault(__webpack_require__(2949));
exports.ParsedDataLayout = buffer_layout_1.default.struct([
    buffer_layout_1.default.blob(32, 'amount'),
    buffer_layout_1.default.u8('toChain'),
    buffer_layout_1.default.blob(32, 'sourceAddress'),
    buffer_layout_1.default.blob(32, 'targetAddress'),
    buffer_layout_1.default.blob(32, 'assetAddress'),
    buffer_layout_1.default.u8('assetChain'),
    buffer_layout_1.default.u8('assetDecimals'),
    buffer_layout_1.default.seq(buffer_layout_1.default.u8(), 1),
    buffer_layout_1.default.u32('nonce'),
    buffer_layout_1.default.blob(1001, 'vaa'),
    buffer_layout_1.default.seq(buffer_layout_1.default.u8(), 3),
    buffer_layout_1.default.u32('vaaTime'),
    buffer_layout_1.default.u32('lockupTime'),
    buffer_layout_1.default.u8('pokeCounter'),
    buffer_layout_1.default.blob(32, 'signatureAccount'),
    buffer_layout_1.default.u8('initialized'),
]);
function approve(instructions, cleanupInstructions, account, owner, amount, autoRevoke = true, 
// if delegate is not passed ephemeral transfer authority is used
delegate, existingTransferAuthority) {
    const tokenProgram = ids_1.TOKEN_PROGRAM_ID;
    const transferAuthority = existingTransferAuthority || web3_js_1.Keypair.generate();
    //const delegateKey = delegate ?? transferAuthority.publicKey;
    instructions.push(spl_token_1.Token.createApproveInstruction(tokenProgram, account, delegate !== null && delegate !== void 0 ? delegate : transferAuthority.publicKey, owner, [], amount));
    if (autoRevoke) {
        cleanupInstructions.push(spl_token_1.Token.createRevokeInstruction(tokenProgram, account, owner, []));
    }
    return transferAuthority;
}
exports.approve = approve;
//# sourceMappingURL=account.js.map

/***/ }),

/***/ 5460:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
__exportStar(__webpack_require__(1161), exports);
__exportStar(__webpack_require__(4373), exports);
__exportStar(__webpack_require__(1152), exports);
//# sourceMappingURL=index.js.map

/***/ }),

/***/ 4173:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

var __webpack_unused_export__;

__webpack_unused_export__ = ({ value: true });
exports.G = void 0;
const web3_js_1 = __webpack_require__(5681);
const borsh_1 = __webpack_require__(7384);
const _1 = __webpack_require__(4373);
const actions_1 = __webpack_require__(6618);
const utils_1 = __webpack_require__(398);
async function claimBid(acceptPayment, bidder, bidderPotToken, vault, tokenMint, instructions) {
    const PROGRAM_IDS = (0, utils_1.programIds)();
    const store = PROGRAM_IDS.store;
    if (!store) {
        throw new Error('Store not initialized');
    }
    const { auctionKey, auctionManagerKey } = await (0, _1.getAuctionKeys)(vault);
    const bidderPotKey = await (0, actions_1.getBidderPotKey)({
        auctionProgramId: PROGRAM_IDS.auction,
        auctionKey,
        bidderPubkey: bidder,
    });
    const value = new _1.ClaimBidArgs();
    const data = Buffer.from((0, borsh_1.serialize)(_1.SCHEMA, value));
    const auctionExtendedKey = await (0, actions_1.getAuctionExtended)({
        auctionProgramId: PROGRAM_IDS.auction,
        resource: vault,
    });
    const keys = [
        {
            pubkey: (0, utils_1.toPublicKey)(acceptPayment),
            isSigner: false,
            isWritable: true,
        },
        {
            pubkey: (0, utils_1.toPublicKey)(bidderPotToken),
            isSigner: false,
            isWritable: true,
        },
        {
            pubkey: (0, utils_1.toPublicKey)(bidderPotKey),
            isSigner: false,
            isWritable: true,
        },
        {
            pubkey: (0, utils_1.toPublicKey)(auctionManagerKey),
            isSigner: false,
            isWritable: true,
        },
        {
            pubkey: (0, utils_1.toPublicKey)(auctionKey),
            isSigner: false,
            isWritable: false,
        },
        {
            pubkey: (0, utils_1.toPublicKey)(bidder),
            isSigner: false,
            isWritable: false,
        },
        {
            pubkey: (0, utils_1.toPublicKey)(tokenMint),
            isSigner: false,
            isWritable: false,
        },
        {
            pubkey: (0, utils_1.toPublicKey)(vault),
            isSigner: false,
            isWritable: false,
        },
        {
            pubkey: (0, utils_1.toPublicKey)(store),
            isSigner: false,
            isWritable: false,
        },
        {
            pubkey: (0, utils_1.toPublicKey)(PROGRAM_IDS.auction),
            isSigner: false,
            isWritable: false,
        },
        {
            pubkey: web3_js_1.SYSVAR_CLOCK_PUBKEY,
            isSigner: false,
            isWritable: false,
        },
        {
            pubkey: PROGRAM_IDS.token,
            isSigner: false,
            isWritable: false,
        },
        {
            pubkey: (0, utils_1.toPublicKey)(auctionExtendedKey),
            isSigner: false,
            isWritable: false,
        },
    ];
    instructions.push(new web3_js_1.TransactionInstruction({
        keys,
        programId: (0, utils_1.toPublicKey)(PROGRAM_IDS.metaplex),
        data,
    }));
}
exports.G = claimBid;
//# sourceMappingURL=claimBid.js.map

/***/ }),

/***/ 9260:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

var __webpack_unused_export__;

__webpack_unused_export__ = ({ value: true });
exports.A = void 0;
const web3_js_1 = __webpack_require__(5681);
const borsh_1 = __webpack_require__(7384);
const _1 = __webpack_require__(4373);
const utils_1 = __webpack_require__(398);
async function decommissionAuctionManager(auctionManager, auction, authority, vault, instructions) {
    const PROGRAM_IDS = (0, utils_1.programIds)();
    const store = PROGRAM_IDS.store;
    if (!store) {
        throw new Error('Store not initialized');
    }
    const value = new _1.DecommissionAuctionManagerArgs();
    const data = Buffer.from((0, borsh_1.serialize)(_1.SCHEMA, value));
    const keys = [
        {
            pubkey: (0, utils_1.toPublicKey)(auctionManager),
            isSigner: false,
            isWritable: true,
        },
        {
            pubkey: (0, utils_1.toPublicKey)(auction),
            isSigner: false,
            isWritable: true,
        },
        {
            pubkey: (0, utils_1.toPublicKey)(authority),
            isSigner: true,
            isWritable: false,
        },
        {
            pubkey: (0, utils_1.toPublicKey)(vault),
            isSigner: false,
            isWritable: true,
        },
        {
            pubkey: (0, utils_1.toPublicKey)(store),
            isSigner: false,
            isWritable: false,
        },
        {
            pubkey: (0, utils_1.toPublicKey)(PROGRAM_IDS.auction),
            isSigner: false,
            isWritable: false,
        },
        {
            pubkey: web3_js_1.SYSVAR_CLOCK_PUBKEY,
            isSigner: false,
            isWritable: false,
        },
        {
            pubkey: (0, utils_1.toPublicKey)((0, utils_1.programIds)().vault),
            isSigner: false,
            isWritable: false,
        },
    ];
    instructions.push(new web3_js_1.TransactionInstruction({
        keys,
        programId: (0, utils_1.toPublicKey)(PROGRAM_IDS.metaplex),
        data,
    }));
}
exports.A = decommissionAuctionManager;
//# sourceMappingURL=decommissionAuctionManager.js.map

/***/ }),

/***/ 8658:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.deprecatedInitAuctionManagerV1 = void 0;
const web3_js_1 = __webpack_require__(5681);
const borsh_1 = __webpack_require__(7384);
const _1 = __webpack_require__(4373);
const utils_1 = __webpack_require__(398);
const deprecatedStates_1 = __webpack_require__(6517);
async function deprecatedInitAuctionManagerV1(vault, auctionManagerAuthority, payer, acceptPaymentAccount, store, settings, instructions) {
    const PROGRAM_IDS = (0, utils_1.programIds)();
    const { auctionKey, auctionManagerKey } = await (0, _1.getAuctionKeys)(vault);
    const value = new deprecatedStates_1.DeprecatedInitAuctionManagerV1Args({
        settings,
    });
    const data = Buffer.from((0, borsh_1.serialize)(_1.SCHEMA, value));
    const keys = [
        {
            pubkey: (0, utils_1.toPublicKey)(auctionManagerKey),
            isSigner: false,
            isWritable: true,
        },
        {
            pubkey: (0, utils_1.toPublicKey)(vault),
            isSigner: false,
            isWritable: false,
        },
        {
            pubkey: (0, utils_1.toPublicKey)(auctionKey),
            isSigner: false,
            isWritable: false,
        },
        {
            pubkey: (0, utils_1.toPublicKey)(auctionManagerAuthority),
            isSigner: false,
            isWritable: false,
        },
        {
            pubkey: (0, utils_1.toPublicKey)(payer),
            isSigner: true,
            isWritable: false,
        },
        {
            pubkey: (0, utils_1.toPublicKey)(acceptPaymentAccount),
            isSigner: false,
            isWritable: false,
        },
        {
            pubkey: (0, utils_1.toPublicKey)(store),
            isSigner: false,
            isWritable: false,
        },
        {
            pubkey: web3_js_1.SystemProgram.programId,
            isSigner: false,
            isWritable: false,
        },
        {
            pubkey: web3_js_1.SYSVAR_RENT_PUBKEY,
            isSigner: false,
            isWritable: false,
        },
    ];
    instructions.push(new web3_js_1.TransactionInstruction({
        keys,
        programId: (0, utils_1.toPublicKey)(PROGRAM_IDS.metaplex),
        data,
    }));
}
exports.deprecatedInitAuctionManagerV1 = deprecatedInitAuctionManagerV1;
//# sourceMappingURL=deprecatedInitAuctionManagerV1.js.map

/***/ }),

/***/ 1739:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

var __webpack_unused_export__;

__webpack_unused_export__ = ({ value: true });
exports.z = void 0;
const web3_js_1 = __webpack_require__(5681);
const borsh_1 = __webpack_require__(7384);
const _1 = __webpack_require__(4373);
const actions_1 = __webpack_require__(6618);
const utils_1 = __webpack_require__(398);
const deprecatedStates_1 = __webpack_require__(6517);
async function deprecatedPopulateParticipationPrintingAccount(vault, auctionManager, auction, safetyDepositTokenStore, transientOneTimeAccount, printingTokenAccount, safetyDeposit, fractionMint, printingMint, oneTimePrintingAuthorizationMint, masterEdition, metadata, payer, instructions) {
    const PROGRAM_IDS = (0, utils_1.programIds)();
    const store = PROGRAM_IDS.store;
    if (!store) {
        throw new Error('Store not initialized');
    }
    const transferAuthority = (await (0, utils_1.findProgramAddress)([
        Buffer.from(actions_1.VAULT_PREFIX),
        (0, utils_1.toPublicKey)(PROGRAM_IDS.vault).toBuffer(),
        (0, utils_1.toPublicKey)(vault).toBuffer(),
    ], (0, utils_1.toPublicKey)(PROGRAM_IDS.vault)))[0];
    const value = new deprecatedStates_1.DeprecatedPopulateParticipationPrintingAccountArgs();
    const data = Buffer.from((0, borsh_1.serialize)(_1.SCHEMA, value));
    const keys = [
        {
            pubkey: (0, utils_1.toPublicKey)(safetyDepositTokenStore),
            isSigner: false,
            isWritable: true,
        },
        {
            pubkey: (0, utils_1.toPublicKey)(transientOneTimeAccount),
            isSigner: false,
            isWritable: true,
        },
        {
            pubkey: (0, utils_1.toPublicKey)(printingTokenAccount),
            isSigner: false,
            isWritable: true,
        },
        {
            pubkey: (0, utils_1.toPublicKey)(oneTimePrintingAuthorizationMint),
            isSigner: false,
            isWritable: true,
        },
        {
            pubkey: (0, utils_1.toPublicKey)(printingMint),
            isSigner: false,
            isWritable: true,
        },
        {
            pubkey: (0, utils_1.toPublicKey)(safetyDeposit),
            isSigner: false,
            isWritable: true,
        },
        {
            pubkey: (0, utils_1.toPublicKey)(vault),
            isSigner: false,
            isWritable: true,
        },
        {
            pubkey: (0, utils_1.toPublicKey)(fractionMint),
            isSigner: false,
            isWritable: false,
        },
        {
            pubkey: (0, utils_1.toPublicKey)(auction),
            isSigner: false,
            isWritable: false,
        },
        {
            pubkey: (0, utils_1.toPublicKey)(await (0, actions_1.getAuctionExtended)({
                auctionProgramId: PROGRAM_IDS.auction,
                resource: vault,
            })),
            isSigner: false,
            isWritable: false,
        },
        {
            pubkey: (0, utils_1.toPublicKey)(auctionManager),
            isSigner: false,
            isWritable: false,
        },
        {
            pubkey: PROGRAM_IDS.token,
            isSigner: false,
            isWritable: false,
        },
        {
            pubkey: (0, utils_1.toPublicKey)(PROGRAM_IDS.vault),
            isSigner: false,
            isWritable: false,
        },
        {
            pubkey: (0, utils_1.toPublicKey)(PROGRAM_IDS.metadata),
            isSigner: false,
            isWritable: false,
        },
        {
            pubkey: store,
            isSigner: false,
            isWritable: false,
        },
        {
            pubkey: (0, utils_1.toPublicKey)(masterEdition),
            isSigner: false,
            isWritable: false,
        },
        {
            pubkey: (0, utils_1.toPublicKey)(metadata),
            isSigner: false,
            isWritable: false,
        },
        {
            pubkey: (0, utils_1.toPublicKey)(transferAuthority),
            isSigner: false,
            isWritable: false,
        },
        {
            pubkey: (0, utils_1.toPublicKey)(payer),
            isSigner: false,
            isWritable: false,
        },
        {
            pubkey: web3_js_1.SYSVAR_RENT_PUBKEY,
            isSigner: false,
            isWritable: false,
        },
    ];
    instructions.push(new web3_js_1.TransactionInstruction({
        keys,
        programId: (0, utils_1.toPublicKey)(PROGRAM_IDS.metaplex),
        data,
    }));
}
exports.z = deprecatedPopulateParticipationPrintingAccount;
//# sourceMappingURL=deprecatedPopulateParticipationPrintingAccount.js.map

/***/ }),

/***/ 1665:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.deprecatedRedeemParticipationBid = void 0;
const web3_js_1 = __webpack_require__(5681);
const borsh_1 = __webpack_require__(7384);
const _1 = __webpack_require__(4373);
const utils_1 = __webpack_require__(398);
const deprecatedStates_1 = __webpack_require__(6517);
async function deprecatedRedeemParticipationBid(vault, safetyDepositTokenStore, destination, safetyDeposit, bidder, payer, instructions, participationPrintingAccount, transferAuthority, acceptPaymentAccount, tokenPaymentAccount) {
    const PROGRAM_IDS = (0, utils_1.programIds)();
    const store = PROGRAM_IDS.store;
    if (!store) {
        throw new Error('Store not initialized');
    }
    const { auctionKey, auctionManagerKey } = await (0, _1.getAuctionKeys)(vault);
    const { bidRedemption, bidMetadata } = await (0, _1.getBidderKeys)(auctionKey, bidder);
    const safetyDepositConfig = await (0, _1.getSafetyDepositConfig)(auctionManagerKey, safetyDeposit);
    const value = new deprecatedStates_1.DeprecatedRedeemParticipationBidArgs();
    const data = Buffer.from((0, borsh_1.serialize)(_1.SCHEMA, value));
    const keys = [
        {
            pubkey: (0, utils_1.toPublicKey)(auctionManagerKey),
            isSigner: false,
            isWritable: true,
        },
        {
            pubkey: (0, utils_1.toPublicKey)(safetyDepositTokenStore),
            isSigner: false,
            isWritable: true,
        },
        {
            pubkey: (0, utils_1.toPublicKey)(destination),
            isSigner: false,
            isWritable: true,
        },
        {
            pubkey: (0, utils_1.toPublicKey)(bidRedemption),
            isSigner: false,
            isWritable: true,
        },
        {
            pubkey: (0, utils_1.toPublicKey)(safetyDeposit),
            isSigner: false,
            isWritable: false,
        },
        {
            pubkey: (0, utils_1.toPublicKey)(vault),
            isSigner: false,
            isWritable: false,
        },
        {
            pubkey: (0, utils_1.toPublicKey)(safetyDepositConfig),
            isSigner: false,
            isWritable: false,
        },
        {
            pubkey: (0, utils_1.toPublicKey)(auctionKey),
            isSigner: false,
            isWritable: false,
        },
        {
            pubkey: (0, utils_1.toPublicKey)(bidMetadata),
            isSigner: false,
            isWritable: false,
        },
        {
            pubkey: (0, utils_1.toPublicKey)(bidder),
            isSigner: false,
            isWritable: true,
        },
        {
            pubkey: (0, utils_1.toPublicKey)(payer),
            isSigner: true,
            isWritable: false,
        },
        {
            pubkey: PROGRAM_IDS.token,
            isSigner: false,
            isWritable: false,
        },
        {
            pubkey: (0, utils_1.toPublicKey)(PROGRAM_IDS.vault),
            isSigner: false,
            isWritable: false,
        },
        {
            pubkey: (0, utils_1.toPublicKey)(PROGRAM_IDS.metadata),
            isSigner: false,
            isWritable: false,
        },
        {
            pubkey: store,
            isSigner: false,
            isWritable: false,
        },
        {
            pubkey: web3_js_1.SystemProgram.programId,
            isSigner: false,
            isWritable: false,
        },
        {
            pubkey: web3_js_1.SYSVAR_RENT_PUBKEY,
            isSigner: false,
            isWritable: false,
        },
        {
            pubkey: (0, utils_1.toPublicKey)(transferAuthority),
            isSigner: true,
            isWritable: false,
        },
        {
            pubkey: (0, utils_1.toPublicKey)(acceptPaymentAccount),
            isSigner: false,
            isWritable: true,
        },
        {
            pubkey: (0, utils_1.toPublicKey)(tokenPaymentAccount),
            isSigner: false,
            isWritable: true,
        },
        {
            pubkey: (0, utils_1.toPublicKey)(participationPrintingAccount),
            isSigner: false,
            isWritable: true,
        },
    ];
    instructions.push(new web3_js_1.TransactionInstruction({
        keys,
        programId: (0, utils_1.toPublicKey)(PROGRAM_IDS.metaplex),
        data,
    }));
}
exports.deprecatedRedeemParticipationBid = deprecatedRedeemParticipationBid;
//# sourceMappingURL=deprecatedRedeemParticipationBid.js.map

/***/ }),

/***/ 6517:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.DEPRECATED_SCHEMA = exports.getSafetyDepositBoxValidationTicket = exports.BidRedemptionTicketV1 = exports.AuctionManagerStateV1 = exports.WinningConfigStateItem = exports.WinningConfigState = exports.WinningConfigItem = exports.WinningConfig = exports.ParticipationConfigV1 = exports.ParticipationStateV1 = exports.AuctionManagerSettingsV1 = exports.DeprecatedValidateParticipationArgs = exports.DeprecatedPopulateParticipationPrintingAccountArgs = exports.DeprecatedRedeemParticipationBidArgs = exports.DeprecatedValidateSafetyDepositBoxV1Args = exports.DeprecatedInitAuctionManagerV1Args = exports.AuctionManagerV1 = exports.MAX_BID_REDEMPTION_TICKET_V1_SIZE = void 0;
const bn_js_1 = __importDefault(__webpack_require__(4894));
const _1 = __webpack_require__(4373);
const utils_1 = __webpack_require__(398);
exports.MAX_BID_REDEMPTION_TICKET_V1_SIZE = 3;
class AuctionManagerV1 {
    constructor(args) {
        this.key = _1.MetaplexKey.AuctionManagerV1;
        this.store = args.store;
        this.authority = args.authority;
        this.auction = args.auction;
        this.vault = args.vault;
        this.acceptPayment = args.acceptPayment;
        this.state = args.state;
        this.settings = args.settings;
    }
}
exports.AuctionManagerV1 = AuctionManagerV1;
class DeprecatedInitAuctionManagerV1Args {
    constructor(args) {
        this.instruction = 0;
        this.settings = args.settings;
    }
}
exports.DeprecatedInitAuctionManagerV1Args = DeprecatedInitAuctionManagerV1Args;
class DeprecatedValidateSafetyDepositBoxV1Args {
    constructor() {
        this.instruction = 1;
    }
}
exports.DeprecatedValidateSafetyDepositBoxV1Args = DeprecatedValidateSafetyDepositBoxV1Args;
class DeprecatedRedeemParticipationBidArgs {
    constructor() {
        this.instruction = 4;
    }
}
exports.DeprecatedRedeemParticipationBidArgs = DeprecatedRedeemParticipationBidArgs;
class DeprecatedPopulateParticipationPrintingAccountArgs {
    constructor() {
        this.instruction = 11;
    }
}
exports.DeprecatedPopulateParticipationPrintingAccountArgs = DeprecatedPopulateParticipationPrintingAccountArgs;
class DeprecatedValidateParticipationArgs {
    constructor() {
        this.instruction = 10;
    }
}
exports.DeprecatedValidateParticipationArgs = DeprecatedValidateParticipationArgs;
class AuctionManagerSettingsV1 {
    constructor(args) {
        this.winningConfigs = [];
        this.participationConfig = null;
        Object.assign(this, args);
    }
}
exports.AuctionManagerSettingsV1 = AuctionManagerSettingsV1;
class ParticipationStateV1 {
    constructor(args) {
        this.collectedToAcceptPayment = new bn_js_1.default(0);
        this.primarySaleHappened = false;
        this.validated = false;
        this.printingAuthorizationTokenAccount = null;
        Object.assign(this, args);
    }
}
exports.ParticipationStateV1 = ParticipationStateV1;
class ParticipationConfigV1 {
    constructor(args) {
        this.winnerConstraint = _1.WinningConstraint.NoParticipationPrize;
        this.nonWinningConstraint = _1.NonWinningConstraint.GivenForFixedPrice;
        this.safetyDepositBoxIndex = 0;
        this.fixedPrice = new bn_js_1.default(0);
        Object.assign(this, args);
    }
}
exports.ParticipationConfigV1 = ParticipationConfigV1;
class WinningConfig {
    constructor(args) {
        this.items = [];
        Object.assign(this, args);
    }
}
exports.WinningConfig = WinningConfig;
class WinningConfigItem {
    constructor(args) {
        this.safetyDepositBoxIndex = 0;
        this.amount = 0;
        this.winningConfigType = _1.WinningConfigType.TokenOnlyTransfer;
        Object.assign(this, args);
    }
}
exports.WinningConfigItem = WinningConfigItem;
class WinningConfigState {
    constructor(args) {
        this.items = [];
        this.moneyPushedToAcceptPayment = false;
        Object.assign(this, args);
    }
}
exports.WinningConfigState = WinningConfigState;
class WinningConfigStateItem {
    constructor(args) {
        this.primarySaleHappened = false;
        this.claimed = false;
        Object.assign(this, args);
    }
}
exports.WinningConfigStateItem = WinningConfigStateItem;
class AuctionManagerStateV1 {
    constructor(args) {
        this.status = _1.AuctionManagerStatus.Initialized;
        this.winningConfigItemsValidated = 0;
        this.winningConfigStates = [];
        this.participationState = null;
        Object.assign(this, args);
    }
}
exports.AuctionManagerStateV1 = AuctionManagerStateV1;
class BidRedemptionTicketV1 {
    constructor(args) {
        this.key = _1.MetaplexKey.BidRedemptionTicketV1;
        this.participationRedeemed = false;
        this.itemsRedeemed = 0;
        Object.assign(this, args);
    }
    getBidRedeemed() {
        return this.participationRedeemed;
    }
}
exports.BidRedemptionTicketV1 = BidRedemptionTicketV1;
async function getSafetyDepositBoxValidationTicket(auctionManager, safetyDepositBox) {
    const PROGRAM_IDS = (0, utils_1.programIds)();
    return (await (0, utils_1.findProgramAddress)([
        Buffer.from(_1.METAPLEX_PREFIX),
        (0, utils_1.toPublicKey)(PROGRAM_IDS.metaplex).toBuffer(),
        (0, utils_1.toPublicKey)(auctionManager).toBuffer(),
        (0, utils_1.toPublicKey)(safetyDepositBox).toBuffer(),
    ], (0, utils_1.toPublicKey)(PROGRAM_IDS.metaplex)))[0];
}
exports.getSafetyDepositBoxValidationTicket = getSafetyDepositBoxValidationTicket;
exports.DEPRECATED_SCHEMA = new Map([
    [
        AuctionManagerV1,
        {
            kind: 'struct',
            fields: [
                ['key', 'u8'],
                ['store', 'pubkeyAsString'],
                ['authority', 'pubkeyAsString'],
                ['auction', 'pubkeyAsString'],
                ['vault', 'pubkeyAsString'],
                ['acceptPayment', 'pubkeyAsString'],
                ['state', AuctionManagerStateV1],
                ['settings', AuctionManagerSettingsV1],
            ],
        },
    ],
    [
        ParticipationConfigV1,
        {
            kind: 'struct',
            fields: [
                ['winnerConstraint', 'u8'],
                ['nonWinningConstraint', 'u8'],
                ['safetyDepositBoxIndex', 'u8'],
                ['fixedPrice', { kind: 'option', type: 'u64' }],
            ],
        },
    ],
    [
        AuctionManagerSettingsV1,
        {
            kind: 'struct',
            fields: [
                ['winningConfigs', [WinningConfig]],
                [
                    'participationConfig',
                    { kind: 'option', type: ParticipationConfigV1 },
                ],
            ],
        },
    ],
    [
        WinningConfig,
        {
            kind: 'struct',
            fields: [['items', [WinningConfigItem]]],
        },
    ],
    [
        WinningConfigItem,
        {
            kind: 'struct',
            fields: [
                ['safetyDepositBoxIndex', 'u8'],
                ['amount', 'u8'],
                ['winningConfigType', 'u8'],
            ],
        },
    ],
    [
        WinningConfigState,
        {
            kind: 'struct',
            fields: [
                ['items', [WinningConfigStateItem]],
                ['moneyPushedToAcceptPayment', 'u8'], // bool
            ],
        },
    ],
    [
        WinningConfigStateItem,
        {
            kind: 'struct',
            fields: [
                ['primarySaleHappened', 'u8'],
                ['claimed', 'u8'], // bool
            ],
        },
    ],
    [
        AuctionManagerStateV1,
        {
            kind: 'struct',
            fields: [
                ['status', 'u8'],
                ['winningConfigItemsValidated', 'u8'],
                ['winningConfigStates', [WinningConfigState]],
                ['participationState', { kind: 'option', type: ParticipationStateV1 }],
            ],
        },
    ],
    [
        ParticipationStateV1,
        {
            kind: 'struct',
            fields: [
                ['collectedToAcceptPayment', 'u64'],
                ['primarySaleHappened', 'u8'],
                ['validated', 'u8'],
                [
                    'printingAuthorizationTokenAccount',
                    { kind: 'option', type: 'pubkeyAsString' },
                ],
            ],
        },
    ],
    [
        BidRedemptionTicketV1,
        {
            kind: 'struct',
            fields: [
                ['key', 'u8'],
                ['participationRedeemed', 'u8'],
                ['itemsRedeemed', 'u8'], // bool
            ],
        },
    ],
    [
        DeprecatedPopulateParticipationPrintingAccountArgs,
        {
            kind: 'struct',
            fields: [['instruction', 'u8']],
        },
    ],
    [
        DeprecatedInitAuctionManagerV1Args,
        {
            kind: 'struct',
            fields: [
                ['instruction', 'u8'],
                ['settings', AuctionManagerSettingsV1],
            ],
        },
    ],
    [
        DeprecatedValidateSafetyDepositBoxV1Args,
        {
            kind: 'struct',
            fields: [['instruction', 'u8']],
        },
    ],
    [
        DeprecatedRedeemParticipationBidArgs,
        {
            kind: 'struct',
            fields: [['instruction', 'u8']],
        },
    ],
    [
        DeprecatedValidateParticipationArgs,
        {
            kind: 'struct',
            fields: [['instruction', 'u8']],
        },
    ],
]);
//# sourceMappingURL=deprecatedStates.js.map

/***/ }),

/***/ 9041:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

var __webpack_unused_export__;

__webpack_unused_export__ = ({ value: true });
exports.I = void 0;
const web3_js_1 = __webpack_require__(5681);
const borsh_1 = __webpack_require__(7384);
const _1 = __webpack_require__(4373);
const utils_1 = __webpack_require__(398);
const deprecatedStates_1 = __webpack_require__(6517);
async function deprecatedValidateParticipation(auctionManager, openEditionMetadata, openEditionMasterAccount, printingAuthorizationHoldingAccount, auctionManagerAuthority, whitelistedCreatorEntry, store, safetyDepositBox, safetyDepositBoxTokenStore, vault, instructions) {
    const PROGRAM_IDS = (0, utils_1.programIds)();
    const value = new deprecatedStates_1.DeprecatedValidateParticipationArgs();
    const data = Buffer.from((0, borsh_1.serialize)(_1.SCHEMA, value));
    const keys = [
        {
            pubkey: (0, utils_1.toPublicKey)(auctionManager),
            isSigner: false,
            isWritable: true,
        },
        {
            pubkey: (0, utils_1.toPublicKey)(openEditionMetadata),
            isSigner: false,
            isWritable: false,
        },
        {
            pubkey: (0, utils_1.toPublicKey)(openEditionMasterAccount),
            isSigner: false,
            isWritable: false,
        },
        {
            pubkey: (0, utils_1.toPublicKey)(printingAuthorizationHoldingAccount),
            isSigner: false,
            isWritable: false,
        },
        {
            pubkey: (0, utils_1.toPublicKey)(auctionManagerAuthority),
            isSigner: true,
            isWritable: false,
        },
        {
            pubkey: (0, utils_1.toPublicKey)(whitelistedCreatorEntry || web3_js_1.SystemProgram.programId),
            isSigner: false,
            isWritable: false,
        },
        {
            pubkey: (0, utils_1.toPublicKey)(store),
            isSigner: false,
            isWritable: false,
        },
        {
            pubkey: (0, utils_1.toPublicKey)(safetyDepositBox),
            isSigner: false,
            isWritable: false,
        },
        {
            pubkey: (0, utils_1.toPublicKey)(safetyDepositBoxTokenStore),
            isSigner: false,
            isWritable: false,
        },
        {
            pubkey: (0, utils_1.toPublicKey)(vault),
            isSigner: false,
            isWritable: false,
        },
        {
            pubkey: web3_js_1.SYSVAR_RENT_PUBKEY,
            isSigner: false,
            isWritable: false,
        },
    ];
    instructions.push(new web3_js_1.TransactionInstruction({
        keys,
        programId: (0, utils_1.toPublicKey)(PROGRAM_IDS.metaplex),
        data,
    }));
}
exports.I = deprecatedValidateParticipation;
//# sourceMappingURL=deprecatedValidateParticipation.js.map

/***/ }),

/***/ 8290:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.deprecatedValidateSafetyDepositBoxV1 = void 0;
const web3_js_1 = __webpack_require__(5681);
const borsh_1 = __webpack_require__(7384);
const _1 = __webpack_require__(4373);
const utils_1 = __webpack_require__(398);
const deprecatedStates_1 = __webpack_require__(6517);
async function deprecatedValidateSafetyDepositBoxV1(vault, metadata, safetyDepositBox, safetyDepositTokenStore, tokenMint, auctionManagerAuthority, metadataAuthority, payer, instructions, edition, whitelistedCreator, store, printingMint, printingMintAuthority) {
    const PROGRAM_IDS = (0, utils_1.programIds)();
    const { auctionKey, auctionManagerKey } = await (0, _1.getAuctionKeys)(vault);
    const originalAuthorityLookup = await (0, _1.getOriginalAuthority)(auctionKey, metadata);
    const value = new deprecatedStates_1.DeprecatedValidateSafetyDepositBoxV1Args();
    const data = Buffer.from((0, borsh_1.serialize)(_1.SCHEMA, value));
    const keys = [
        {
            pubkey: (0, utils_1.toPublicKey)(await (0, deprecatedStates_1.getSafetyDepositBoxValidationTicket)(auctionManagerKey, safetyDepositBox)),
            isSigner: false,
            isWritable: true,
        },
        {
            pubkey: (0, utils_1.toPublicKey)(auctionManagerKey),
            isSigner: false,
            isWritable: true,
        },
        {
            pubkey: (0, utils_1.toPublicKey)(metadata),
            isSigner: false,
            isWritable: true,
        },
        {
            pubkey: (0, utils_1.toPublicKey)(originalAuthorityLookup),
            isSigner: false,
            isWritable: true,
        },
        {
            pubkey: (0, utils_1.toPublicKey)(whitelistedCreator || web3_js_1.SystemProgram.programId),
            isSigner: false,
            isWritable: false,
        },
        {
            pubkey: (0, utils_1.toPublicKey)(store),
            isSigner: false,
            isWritable: false,
        },
        {
            pubkey: (0, utils_1.toPublicKey)(safetyDepositBox),
            isSigner: false,
            isWritable: false,
        },
        {
            pubkey: (0, utils_1.toPublicKey)(safetyDepositTokenStore),
            isSigner: false,
            isWritable: false,
        },
        {
            pubkey: (0, utils_1.toPublicKey)(tokenMint),
            isSigner: false,
            isWritable: false,
        },
        {
            pubkey: (0, utils_1.toPublicKey)(edition),
            isSigner: false,
            isWritable: false,
        },
        {
            pubkey: (0, utils_1.toPublicKey)(vault),
            isSigner: false,
            isWritable: false,
        },
        {
            pubkey: (0, utils_1.toPublicKey)(auctionManagerAuthority),
            isSigner: true,
            isWritable: false,
        },
        {
            pubkey: (0, utils_1.toPublicKey)(metadataAuthority),
            isSigner: true,
            isWritable: false,
        },
        {
            pubkey: (0, utils_1.toPublicKey)(payer),
            isSigner: true,
            isWritable: false,
        },
        {
            pubkey: (0, utils_1.toPublicKey)(PROGRAM_IDS.metadata),
            isSigner: false,
            isWritable: false,
        },
        {
            pubkey: web3_js_1.SystemProgram.programId,
            isSigner: false,
            isWritable: false,
        },
        {
            pubkey: web3_js_1.SYSVAR_RENT_PUBKEY,
            isSigner: false,
            isWritable: false,
        },
    ];
    if (printingMint && printingMintAuthority) {
        keys.push({
            pubkey: (0, utils_1.toPublicKey)(printingMint),
            isSigner: false,
            isWritable: true,
        });
        keys.push({
            pubkey: (0, utils_1.toPublicKey)(printingMintAuthority),
            isSigner: true,
            isWritable: false,
        });
    }
    instructions.push(new web3_js_1.TransactionInstruction({
        keys,
        programId: (0, utils_1.toPublicKey)(PROGRAM_IDS.metaplex),
        data,
    }));
}
exports.deprecatedValidateSafetyDepositBoxV1 = deprecatedValidateSafetyDepositBoxV1;
//# sourceMappingURL=deprecatedValidateSafetyDepositBoxV1.js.map

/***/ }),

/***/ 6672:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

var __webpack_unused_export__;

__webpack_unused_export__ = ({ value: true });
exports.C = void 0;
const web3_js_1 = __webpack_require__(5681);
const borsh_1 = __webpack_require__(7384);
const _1 = __webpack_require__(4373);
const utils_1 = __webpack_require__(398);
async function emptyPaymentAccount(acceptPayment, destination, auctionManager, metadata, masterEdition, safetyDepositBox, vault, auction, payer, recipient, winningConfigIndex, winningConfigItemIndex, creatorIndex, instructions) {
    const PROGRAM_IDS = (0, utils_1.programIds)();
    const store = PROGRAM_IDS.store;
    if (!store) {
        throw new Error('Store not initialized');
    }
    const safetyDepositConfig = await (0, _1.getSafetyDepositConfig)(auctionManager, safetyDepositBox);
    const tokenTracker = await (0, _1.getAuctionWinnerTokenTypeTracker)(auctionManager);
    const value = new _1.EmptyPaymentAccountArgs({
        winningConfigIndex,
        winningConfigItemIndex,
        creatorIndex,
    });
    const data = Buffer.from((0, borsh_1.serialize)(_1.SCHEMA, value));
    const keys = [
        {
            pubkey: (0, utils_1.toPublicKey)(acceptPayment),
            isSigner: false,
            isWritable: true,
        },
        {
            pubkey: (0, utils_1.toPublicKey)(destination),
            isSigner: false,
            isWritable: true,
        },
        {
            pubkey: (0, utils_1.toPublicKey)(auctionManager),
            isSigner: false,
            isWritable: true,
        },
        {
            pubkey: (0, utils_1.toPublicKey)(await (0, _1.getPayoutTicket)(auctionManager, winningConfigIndex, winningConfigItemIndex, creatorIndex, safetyDepositBox, recipient)),
            isSigner: false,
            isWritable: true,
        },
        {
            pubkey: (0, utils_1.toPublicKey)(payer),
            isSigner: true,
            isWritable: false,
        },
        {
            pubkey: (0, utils_1.toPublicKey)(metadata),
            isSigner: false,
            isWritable: false,
        },
        {
            pubkey: (0, utils_1.toPublicKey)(masterEdition || web3_js_1.SystemProgram.programId),
            isSigner: false,
            isWritable: false,
        },
        {
            pubkey: (0, utils_1.toPublicKey)(safetyDepositBox),
            isSigner: false,
            isWritable: false,
        },
        {
            pubkey: (0, utils_1.toPublicKey)(store),
            isSigner: false,
            isWritable: false,
        },
        {
            pubkey: (0, utils_1.toPublicKey)(vault),
            isSigner: false,
            isWritable: false,
        },
        {
            pubkey: (0, utils_1.toPublicKey)(auction),
            isSigner: false,
            isWritable: false,
        },
        {
            pubkey: PROGRAM_IDS.token,
            isSigner: false,
            isWritable: false,
        },
        {
            pubkey: web3_js_1.SystemProgram.programId,
            isSigner: false,
            isWritable: false,
        },
        {
            pubkey: web3_js_1.SYSVAR_RENT_PUBKEY,
            isSigner: false,
            isWritable: false,
        },
        {
            pubkey: (0, utils_1.toPublicKey)(tokenTracker),
            isSigner: false,
            isWritable: false,
        },
        {
            pubkey: (0, utils_1.toPublicKey)(safetyDepositConfig),
            isSigner: false,
            isWritable: false,
        },
    ];
    instructions.push(new web3_js_1.TransactionInstruction({
        keys,
        programId: (0, utils_1.toPublicKey)(PROGRAM_IDS.metaplex),
        data,
    }));
}
exports.C = emptyPaymentAccount;
//# sourceMappingURL=emptyPaymentAccount.js.map

/***/ }),

/***/ 4373:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Store = exports.WhitelistedCreator = exports.decodePayoutTicket = exports.decodeSafetyDepositConfig = exports.decodeBidRedemptionTicket = exports.decodeAuctionManager = exports.decodeStore = exports.WhitelistedCreatorParser = exports.decodeWhitelistedCreator = exports.decodePrizeTrackingTicket = exports.decodeAuctionCache = exports.decodeStoreIndexer = exports.WinningConfigType = exports.NonWinningConstraint = exports.WinningConstraint = exports.SetAuctionCacheArgs = exports.SetStoreIndexArgs = exports.RedeemParticipationBidV3Args = exports.WithdrawMasterEditionArgs = exports.RedeemPrintingV2BidArgs = exports.DecommissionAuctionManagerArgs = exports.SetWhitelistedCreatorArgs = exports.SetStoreArgs = exports.EmptyPaymentAccountArgs = exports.RedeemUnusedWinningConfigItemsAsAuctioneerArgs = exports.ProxyCallAddress = exports.ClaimBidArgs = exports.EndAuctionArgs = exports.StartAuctionArgs = exports.RedeemFullRightsTransferBidArgs = exports.RedeemBidArgs = exports.ParticipationConfigV2 = exports.ParticipationStateV2 = exports.AuctionManagerStateV2 = exports.AuctionManagerV2 = exports.AuctionManager = exports.AuctionCache = exports.StoreIndexer = exports.PayoutTicket = exports.PrizeTrackingTicket = exports.MetaplexKey = exports.MAX_PAYOUT_TICKET_SIZE = exports.MAX_WHITELISTED_CREATOR_SIZE = exports.MAX_PRIZE_TRACKING_TICKET_SIZE = exports.ORIGINAL_AUTHORITY_LOOKUP_SIZE = exports.MAX_INDEXED_ELEMENTS = exports.TOTALS = exports.CACHE = exports.INDEX = exports.METAPLEX_PREFIX = void 0;
exports.getPayoutTicket = exports.getAuctionCache = exports.getStoreIndexer = exports.getSafetyDepositConfig = exports.getAuctionWinnerTokenTypeTracker = exports.getPrizeTrackingTicket = exports.getWhitelistedCreator = exports.isCreatorPartOfTheStore = exports.getOriginalAuthority = exports.getBidderKeys = exports.getBidRedemption = exports.getAuctionKeys = exports.getAuctionManagerKey = exports.SCHEMA = exports.ValidateSafetyDepositBoxV2Args = exports.SafetyDepositConfig = exports.InitAuctionManagerV2Args = exports.AmountRange = exports.TupleNumericType = exports.AuctionManagerStatus = exports.BidRedemptionTicketV2 = void 0;
const web3_js_1 = __webpack_require__(5681);
const bn_js_1 = __importDefault(__webpack_require__(4894));
const bs58_1 = __importDefault(__webpack_require__(2815));
const borsh_1 = __webpack_require__(7384);
const actions_1 = __webpack_require__(6618);
const utils_1 = __webpack_require__(398);
const deprecatedStates_1 = __webpack_require__(6517);
__exportStar(__webpack_require__(8658), exports);
__exportStar(__webpack_require__(1162), exports);
__exportStar(__webpack_require__(1860), exports);
__exportStar(__webpack_require__(1665), exports);
__exportStar(__webpack_require__(7020), exports);
__exportStar(__webpack_require__(8290), exports);
__exportStar(__webpack_require__(3784), exports);
__exportStar(__webpack_require__(6556), exports);
__exportStar(__webpack_require__(2921), exports);
__exportStar(__webpack_require__(6517), exports);
exports.METAPLEX_PREFIX = 'metaplex';
exports.INDEX = 'index';
exports.CACHE = 'cache';
exports.TOTALS = 'totals';
exports.MAX_INDEXED_ELEMENTS = 100;
exports.ORIGINAL_AUTHORITY_LOOKUP_SIZE = 33;
exports.MAX_PRIZE_TRACKING_TICKET_SIZE = 1 + 32 + 8 + 8 + 8 + 50;
exports.MAX_WHITELISTED_CREATOR_SIZE = 2 + 32 + 10;
exports.MAX_PAYOUT_TICKET_SIZE = 1 + 32 + 8;
var MetaplexKey;
(function (MetaplexKey) {
    MetaplexKey[MetaplexKey["Uninitialized"] = 0] = "Uninitialized";
    MetaplexKey[MetaplexKey["OriginalAuthorityLookupV1"] = 1] = "OriginalAuthorityLookupV1";
    MetaplexKey[MetaplexKey["BidRedemptionTicketV1"] = 2] = "BidRedemptionTicketV1";
    MetaplexKey[MetaplexKey["StoreV1"] = 3] = "StoreV1";
    MetaplexKey[MetaplexKey["WhitelistedCreatorV1"] = 4] = "WhitelistedCreatorV1";
    MetaplexKey[MetaplexKey["PayoutTicketV1"] = 5] = "PayoutTicketV1";
    MetaplexKey[MetaplexKey["SafetyDepositValidationTicketV1"] = 6] = "SafetyDepositValidationTicketV1";
    MetaplexKey[MetaplexKey["AuctionManagerV1"] = 7] = "AuctionManagerV1";
    MetaplexKey[MetaplexKey["PrizeTrackingTicketV1"] = 8] = "PrizeTrackingTicketV1";
    MetaplexKey[MetaplexKey["SafetyDepositConfigV1"] = 9] = "SafetyDepositConfigV1";
    MetaplexKey[MetaplexKey["AuctionManagerV2"] = 10] = "AuctionManagerV2";
    MetaplexKey[MetaplexKey["BidRedemptionTicketV2"] = 11] = "BidRedemptionTicketV2";
    MetaplexKey[MetaplexKey["AuctionWinnerTokenTypeTrackerV1"] = 12] = "AuctionWinnerTokenTypeTrackerV1";
    MetaplexKey[MetaplexKey["StoreIndexerV1"] = 13] = "StoreIndexerV1";
    MetaplexKey[MetaplexKey["AuctionCacheV1"] = 14] = "AuctionCacheV1";
    MetaplexKey[MetaplexKey["PackSet"] = 15] = "PackSet";
})(MetaplexKey = exports.MetaplexKey || (exports.MetaplexKey = {}));
class PrizeTrackingTicket {
    constructor(args) {
        this.key = MetaplexKey.PrizeTrackingTicketV1;
        this.key = MetaplexKey.PrizeTrackingTicketV1;
        this.metadata = args.metadata;
        this.supplySnapshot = args.supplySnapshot;
        this.expectedRedemptions = args.expectedRedemptions;
        this.redemptions = args.redemptions;
    }
}
exports.PrizeTrackingTicket = PrizeTrackingTicket;
class PayoutTicket {
    constructor(args) {
        this.key = MetaplexKey.PayoutTicketV1;
        this.key = MetaplexKey.PayoutTicketV1;
        this.recipient = args.recipient;
        this.amountPaid = args.amountPaid;
    }
}
exports.PayoutTicket = PayoutTicket;
class StoreIndexer {
    constructor(args) {
        this.key = MetaplexKey.StoreIndexerV1;
        this.key = MetaplexKey.StoreIndexerV1;
        this.store = args.store;
        this.page = args.page;
        this.auctionCaches = args.auctionCaches;
    }
}
exports.StoreIndexer = StoreIndexer;
class AuctionCache {
    constructor(args) {
        this.key = MetaplexKey.AuctionCacheV1;
        this.key = MetaplexKey.AuctionCacheV1;
        this.store = args.store;
        this.timestamp = args.timestamp;
        this.metadata = args.metadata;
        this.auction = args.auction;
        this.vault = args.vault;
        this.auctionManager = args.auctionManager;
    }
}
exports.AuctionCache = AuctionCache;
class AuctionManager {
    constructor(args) {
        var _a;
        this.pubkey = args.instance.pubkey;
        this.instance = args.instance;
        this.numWinners = args.auction.info.bidState.max;
        this.safetyDepositBoxesExpected =
            this.instance.info.key == MetaplexKey.AuctionManagerV2
                ? new bn_js_1.default(args.vault.info.tokenTypeCount)
                : new bn_js_1.default(this.instance.info.state.winningConfigItemsValidated);
        this.store = this.instance.info.store;
        this.authority = this.instance.info.authority;
        this.vault = this.instance.info.vault;
        this.acceptPayment = this.instance.info.acceptPayment;
        this.auction = this.instance.info.auction;
        this.status = this.instance.info.state.status;
        this.safetyDepositConfigs = args.safetyDepositConfigs;
        this.bidRedemptions = args.bidRedemptions;
        this.participationConfig =
            this.instance.info.key == MetaplexKey.AuctionManagerV2
                ? ((_a = this.safetyDepositConfigs) === null || _a === void 0 ? void 0 : _a.filter(s => s.info.participationConfig).map(s => {
                    var _a, _b, _c;
                    return ({
                        winnerConstraint: ((_a = s.info.participationConfig) === null || _a === void 0 ? void 0 : _a.winnerConstraint) ||
                            WinningConstraint.NoParticipationPrize,
                        nonWinningConstraint: ((_b = s.info.participationConfig) === null || _b === void 0 ? void 0 : _b.nonWinningConstraint) ||
                            NonWinningConstraint.GivenForFixedPrice,
                        fixedPrice: ((_c = s.info.participationConfig) === null || _c === void 0 ? void 0 : _c.fixedPrice) || null,
                        safetyDepositBoxIndex: s.info.order.toNumber(),
                    });
                })[0]) || undefined
                : this.instance.info.settings
                    .participationConfig || undefined;
    }
    isItemClaimed(winnerIndex, safetyDepositBoxIndex) {
        if (this.instance.info.key == MetaplexKey.AuctionManagerV1) {
            const asV1 = this.instance.info;
            const itemIndex = asV1.settings.winningConfigs[winnerIndex].items.findIndex(i => i.safetyDepositBoxIndex == safetyDepositBoxIndex);
            return asV1.state.winningConfigStates[winnerIndex].items[itemIndex]
                .claimed;
        }
        else {
            const winner = this.bidRedemptions.find(b => b.info.winnerIndex && b.info.winnerIndex.eq(new bn_js_1.default(winnerIndex)));
            if (!winner) {
                return false;
            }
            else {
                return winner.info.getBidRedeemed(safetyDepositBoxIndex);
            }
        }
    }
    getAmountForWinner(winnerIndex, safetyDepositBoxIndex) {
        var _a;
        if (this.instance.info.key == MetaplexKey.AuctionManagerV1) {
            return new bn_js_1.default(((_a = this.instance.info.settings.winningConfigs[winnerIndex].items.find(i => i.safetyDepositBoxIndex == safetyDepositBoxIndex)) === null || _a === void 0 ? void 0 : _a.amount) || 0);
        }
        else {
            const safetyDepositConfig = this.safetyDepositConfigs[safetyDepositBoxIndex];
            return safetyDepositConfig.info.getAmountForWinner(new bn_js_1.default(winnerIndex));
        }
    }
    getItemsFromSafetyDepositBoxes(metadataByMint, masterEditionsByPrintingMint, metadataByMasterEdition, masterEditions, boxes) {
        var _a;
        if (this.instance.info.key == MetaplexKey.AuctionManagerV1) {
            return this.instance.info.settings.winningConfigs.map(w => {
                return w.items.map(it => {
                    var _a, _b, _c;
                    let metadata = metadataByMint[(_a = boxes[it.safetyDepositBoxIndex]) === null || _a === void 0 ? void 0 : _a.info.tokenMint];
                    if (!metadata) {
                        // Means is a limited edition v1, so the tokenMint is the printingMint
                        const masterEdition = masterEditionsByPrintingMint[(_b = boxes[it.safetyDepositBoxIndex]) === null || _b === void 0 ? void 0 : _b.info.tokenMint];
                        if (masterEdition) {
                            metadata = metadataByMasterEdition[masterEdition.pubkey];
                        }
                    }
                    return {
                        metadata,
                        winningConfigType: it.winningConfigType,
                        safetyDeposit: boxes[it.safetyDepositBoxIndex],
                        amount: new bn_js_1.default(it.amount),
                        masterEdition: ((_c = metadata === null || metadata === void 0 ? void 0 : metadata.info) === null || _c === void 0 ? void 0 : _c.masterEdition)
                            ? masterEditions[metadata.info.masterEdition]
                            : undefined,
                    };
                });
            });
        }
        else {
            const items = [];
            for (let i = 0; i < this.numWinners.toNumber(); i++) {
                const newWinnerArr = [];
                items.push(newWinnerArr);
                (_a = this.safetyDepositConfigs) === null || _a === void 0 ? void 0 : _a.forEach(s => {
                    var _a;
                    const amount = s.info.getAmountForWinner(new bn_js_1.default(i));
                    if (amount.gt(new bn_js_1.default(0))) {
                        const safetyDeposit = boxes[s.info.order.toNumber()];
                        const metadata = metadataByMint[safetyDeposit.info.tokenMint];
                        newWinnerArr.push({
                            metadata,
                            winningConfigType: s.info.winningConfigType,
                            safetyDeposit,
                            amount,
                            masterEdition: ((_a = metadata === null || metadata === void 0 ? void 0 : metadata.info) === null || _a === void 0 ? void 0 : _a.masterEdition)
                                ? masterEditions[metadata.info.masterEdition]
                                : undefined,
                        });
                    }
                });
            }
            return items;
        }
    }
}
exports.AuctionManager = AuctionManager;
class AuctionManagerV2 {
    constructor(args) {
        this.key = MetaplexKey.AuctionManagerV2;
        this.store = args.store;
        this.authority = args.authority;
        this.auction = args.auction;
        this.vault = args.vault;
        this.acceptPayment = args.acceptPayment;
        this.state = args.state;
        const auction = (0, utils_1.programIds)().auction;
        (0, actions_1.getAuctionExtended)({
            auctionProgramId: auction,
            resource: this.vault,
        }).then(val => (this.auctionDataExtended = val));
    }
}
exports.AuctionManagerV2 = AuctionManagerV2;
class AuctionManagerStateV2 {
    constructor(args) {
        this.status = AuctionManagerStatus.Initialized;
        this.safetyConfigItemsValidated = new bn_js_1.default(0);
        this.bidsPushedToAcceptPayment = new bn_js_1.default(0);
        this.hasParticipation = false;
        Object.assign(this, args);
    }
}
exports.AuctionManagerStateV2 = AuctionManagerStateV2;
class ParticipationStateV2 {
    constructor(args) {
        this.collectedToAcceptPayment = new bn_js_1.default(0);
        Object.assign(this, args);
    }
}
exports.ParticipationStateV2 = ParticipationStateV2;
class ParticipationConfigV2 {
    constructor(args) {
        this.winnerConstraint = WinningConstraint.NoParticipationPrize;
        this.nonWinningConstraint = NonWinningConstraint.GivenForFixedPrice;
        this.fixedPrice = new bn_js_1.default(0);
        Object.assign(this, args);
    }
}
exports.ParticipationConfigV2 = ParticipationConfigV2;
class RedeemBidArgs {
    constructor() {
        this.instruction = 2;
    }
}
exports.RedeemBidArgs = RedeemBidArgs;
class RedeemFullRightsTransferBidArgs {
    constructor() {
        this.instruction = 3;
    }
}
exports.RedeemFullRightsTransferBidArgs = RedeemFullRightsTransferBidArgs;
class StartAuctionArgs {
    constructor() {
        this.instruction = 5;
    }
}
exports.StartAuctionArgs = StartAuctionArgs;
class EndAuctionArgs {
    constructor(args) {
        this.instruction = 20;
        this.reveal = args.reveal;
    }
}
exports.EndAuctionArgs = EndAuctionArgs;
class ClaimBidArgs {
    constructor() {
        this.instruction = 6;
    }
}
exports.ClaimBidArgs = ClaimBidArgs;
var ProxyCallAddress;
(function (ProxyCallAddress) {
    ProxyCallAddress[ProxyCallAddress["RedeemBid"] = 0] = "RedeemBid";
    ProxyCallAddress[ProxyCallAddress["RedeemFullRightsTransferBid"] = 1] = "RedeemFullRightsTransferBid";
})(ProxyCallAddress = exports.ProxyCallAddress || (exports.ProxyCallAddress = {}));
class RedeemUnusedWinningConfigItemsAsAuctioneerArgs {
    constructor(args) {
        this.instruction = 12;
        this.winningConfigItemIndex = args.winningConfigItemIndex;
        this.proxyCall = args.proxyCall;
    }
}
exports.RedeemUnusedWinningConfigItemsAsAuctioneerArgs = RedeemUnusedWinningConfigItemsAsAuctioneerArgs;
class EmptyPaymentAccountArgs {
    constructor(args) {
        this.instruction = 7;
        this.winningConfigIndex = args.winningConfigIndex;
        this.winningConfigItemIndex = args.winningConfigItemIndex;
        this.creatorIndex = args.creatorIndex;
    }
}
exports.EmptyPaymentAccountArgs = EmptyPaymentAccountArgs;
class SetStoreArgs {
    constructor(args) {
        this.instruction = 8;
        this.public = args.public;
    }
}
exports.SetStoreArgs = SetStoreArgs;
class SetWhitelistedCreatorArgs {
    constructor(args) {
        this.instruction = 9;
        this.activated = args.activated;
    }
}
exports.SetWhitelistedCreatorArgs = SetWhitelistedCreatorArgs;
class DecommissionAuctionManagerArgs {
    constructor() {
        this.instruction = 13;
    }
}
exports.DecommissionAuctionManagerArgs = DecommissionAuctionManagerArgs;
class RedeemPrintingV2BidArgs {
    constructor(args) {
        this.instruction = 14;
        this.editionOffset = args.editionOffset;
        this.winIndex = args.winIndex;
    }
}
exports.RedeemPrintingV2BidArgs = RedeemPrintingV2BidArgs;
class WithdrawMasterEditionArgs {
    constructor() {
        this.instruction = 15;
    }
}
exports.WithdrawMasterEditionArgs = WithdrawMasterEditionArgs;
class RedeemParticipationBidV3Args {
    constructor(args) {
        this.instruction = 19;
        this.winIndex = args.winIndex;
    }
}
exports.RedeemParticipationBidV3Args = RedeemParticipationBidV3Args;
class SetStoreIndexArgs {
    constructor(args) {
        this.instruction = 21;
        this.page = args.page;
        this.offset = args.offset;
    }
}
exports.SetStoreIndexArgs = SetStoreIndexArgs;
class SetAuctionCacheArgs {
    constructor() {
        this.instruction = 22;
    }
}
exports.SetAuctionCacheArgs = SetAuctionCacheArgs;
var WinningConstraint;
(function (WinningConstraint) {
    WinningConstraint[WinningConstraint["NoParticipationPrize"] = 0] = "NoParticipationPrize";
    WinningConstraint[WinningConstraint["ParticipationPrizeGiven"] = 1] = "ParticipationPrizeGiven";
})(WinningConstraint = exports.WinningConstraint || (exports.WinningConstraint = {}));
var NonWinningConstraint;
(function (NonWinningConstraint) {
    NonWinningConstraint[NonWinningConstraint["NoParticipationPrize"] = 0] = "NoParticipationPrize";
    NonWinningConstraint[NonWinningConstraint["GivenForFixedPrice"] = 1] = "GivenForFixedPrice";
    NonWinningConstraint[NonWinningConstraint["GivenForBidPrice"] = 2] = "GivenForBidPrice";
})(NonWinningConstraint = exports.NonWinningConstraint || (exports.NonWinningConstraint = {}));
var WinningConfigType;
(function (WinningConfigType) {
    /// You may be selling your one-of-a-kind NFT for the first time, but not it's accompanying Metadata,
    /// of which you would like to retain ownership. You get 100% of the payment the first sale, then
    /// royalties forever after.
    ///
    /// You may be re-selling something like a Limited/Open Edition print from another auction,
    /// a master edition record token by itself (Without accompanying metadata/printing ownership), etc.
    /// This means artists will get royalty fees according to the top level royalty % on the metadata
    /// split according to their percentages of contribution.
    ///
    /// No metadata ownership is transferred in this instruction, which means while you may be transferring
    /// the token for a limited/open edition away, you would still be (nominally) the owner of the limited edition
    /// metadata, though it confers no rights or privileges of any kind.
    WinningConfigType[WinningConfigType["TokenOnlyTransfer"] = 0] = "TokenOnlyTransfer";
    /// Means you are auctioning off the master edition record and it's metadata ownership as well as the
    /// token itself. The other person will be able to mint authorization tokens and make changes to the
    /// artwork.
    WinningConfigType[WinningConfigType["FullRightsTransfer"] = 1] = "FullRightsTransfer";
    /// Means you are using authorization tokens to print off editions during the auction using
    /// from a MasterEditionV1
    WinningConfigType[WinningConfigType["PrintingV1"] = 2] = "PrintingV1";
    /// Means you are using the MasterEditionV2 to print off editions
    WinningConfigType[WinningConfigType["PrintingV2"] = 3] = "PrintingV2";
    /// Means you are using a MasterEditionV2 as a participation prize.
    WinningConfigType[WinningConfigType["Participation"] = 4] = "Participation";
})(WinningConfigType = exports.WinningConfigType || (exports.WinningConfigType = {}));
const decodeStoreIndexer = (buffer) => {
    return (0, borsh_1.deserializeUnchecked)(exports.SCHEMA, StoreIndexer, buffer);
};
exports.decodeStoreIndexer = decodeStoreIndexer;
const decodeAuctionCache = (buffer) => {
    return (0, borsh_1.deserializeUnchecked)(exports.SCHEMA, AuctionCache, buffer);
};
exports.decodeAuctionCache = decodeAuctionCache;
const decodePrizeTrackingTicket = (buffer) => {
    return (0, borsh_1.deserializeUnchecked)(exports.SCHEMA, PrizeTrackingTicket, buffer);
};
exports.decodePrizeTrackingTicket = decodePrizeTrackingTicket;
const decodeWhitelistedCreator = (buffer) => {
    return (0, borsh_1.deserializeUnchecked)(exports.SCHEMA, WhitelistedCreator, buffer);
};
exports.decodeWhitelistedCreator = decodeWhitelistedCreator;
const WhitelistedCreatorParser = (pubkey, account) => ({
    pubkey,
    account,
    info: (0, exports.decodeWhitelistedCreator)(account.data),
});
exports.WhitelistedCreatorParser = WhitelistedCreatorParser;
const decodeStore = (buffer) => {
    return (0, borsh_1.deserializeUnchecked)(exports.SCHEMA, Store, buffer);
};
exports.decodeStore = decodeStore;
const decodeAuctionManager = (buffer) => {
    return buffer[0] == MetaplexKey.AuctionManagerV1
        ? (0, borsh_1.deserializeUnchecked)(exports.SCHEMA, deprecatedStates_1.AuctionManagerV1, buffer)
        : (0, borsh_1.deserializeUnchecked)(exports.SCHEMA, AuctionManagerV2, buffer);
};
exports.decodeAuctionManager = decodeAuctionManager;
const decodeBidRedemptionTicket = (buffer) => {
    return (buffer[0] == MetaplexKey.BidRedemptionTicketV1
        ? (0, borsh_1.deserializeUnchecked)(exports.SCHEMA, deprecatedStates_1.BidRedemptionTicketV1, buffer)
        : new BidRedemptionTicketV2({
            key: MetaplexKey.BidRedemptionTicketV2,
            data: buffer.toJSON().data,
        }));
};
exports.decodeBidRedemptionTicket = decodeBidRedemptionTicket;
const decodeSafetyDepositConfig = (buffer) => {
    return new SafetyDepositConfig({
        data: buffer,
    });
};
exports.decodeSafetyDepositConfig = decodeSafetyDepositConfig;
const decodePayoutTicket = (buffer) => {
    return (0, borsh_1.deserializeUnchecked)(exports.SCHEMA, PayoutTicket, buffer);
};
exports.decodePayoutTicket = decodePayoutTicket;
class WhitelistedCreator {
    constructor(args) {
        this.key = MetaplexKey.WhitelistedCreatorV1;
        this.activated = true;
        this.address = args.address;
        this.activated = args.activated;
    }
}
exports.WhitelistedCreator = WhitelistedCreator;
class Store {
    constructor(args) {
        this.key = MetaplexKey.StoreV1;
        this.public = true;
        this.key = MetaplexKey.StoreV1;
        this.public = args.public;
        this.auctionProgram = args.auctionProgram;
        this.tokenVaultProgram = args.tokenVaultProgram;
        this.tokenMetadataProgram = args.tokenMetadataProgram;
        this.tokenProgram = args.tokenProgram;
    }
}
exports.Store = Store;
class BidRedemptionTicketV2 {
    constructor(args) {
        this.key = MetaplexKey.BidRedemptionTicketV2;
        this.data = [];
        Object.assign(this, args);
        let offset = 2;
        if (this.data[1] == 0) {
            this.winnerIndex = null;
        }
        else {
            this.winnerIndex = new bn_js_1.default(this.data.slice(2, 8), 'le');
            offset += 8;
        }
        this.auctionManager = bs58_1.default.encode(this.data.slice(offset, offset + 32));
    }
    getBidRedeemed(order) {
        let offset = 42;
        if (this.data[1] == 0) {
            offset -= 8;
        }
        const index = Math.floor(order / 8) + offset;
        const positionFromRight = 7 - (order % 8);
        const mask = Math.pow(2, positionFromRight);
        const appliedMask = this.data[index] & mask;
        return appliedMask != 0;
    }
}
exports.BidRedemptionTicketV2 = BidRedemptionTicketV2;
var AuctionManagerStatus;
(function (AuctionManagerStatus) {
    AuctionManagerStatus[AuctionManagerStatus["Initialized"] = 0] = "Initialized";
    AuctionManagerStatus[AuctionManagerStatus["Validated"] = 1] = "Validated";
    AuctionManagerStatus[AuctionManagerStatus["Running"] = 2] = "Running";
    AuctionManagerStatus[AuctionManagerStatus["Disbursing"] = 3] = "Disbursing";
    AuctionManagerStatus[AuctionManagerStatus["Finished"] = 4] = "Finished";
})(AuctionManagerStatus = exports.AuctionManagerStatus || (exports.AuctionManagerStatus = {}));
var TupleNumericType;
(function (TupleNumericType) {
    TupleNumericType[TupleNumericType["U8"] = 1] = "U8";
    TupleNumericType[TupleNumericType["U16"] = 2] = "U16";
    TupleNumericType[TupleNumericType["U32"] = 4] = "U32";
    TupleNumericType[TupleNumericType["U64"] = 8] = "U64";
})(TupleNumericType = exports.TupleNumericType || (exports.TupleNumericType = {}));
class AmountRange {
    constructor(args) {
        this.amount = args.amount;
        this.length = args.length;
    }
}
exports.AmountRange = AmountRange;
class InitAuctionManagerV2Args {
    constructor(args) {
        this.instruction = 17;
        this.amountType = TupleNumericType.U8;
        this.lengthType = TupleNumericType.U8;
        this.maxRanges = new bn_js_1.default(1);
        this.amountType = args.amountType;
        this.lengthType = args.lengthType;
        this.maxRanges = args.maxRanges;
    }
}
exports.InitAuctionManagerV2Args = InitAuctionManagerV2Args;
class SafetyDepositConfig {
    constructor(args) {
        this.key = MetaplexKey.SafetyDepositConfigV1;
        this.auctionManager = web3_js_1.SystemProgram.programId.toBase58();
        this.order = new bn_js_1.default(0);
        this.winningConfigType = WinningConfigType.PrintingV2;
        this.amountType = TupleNumericType.U8;
        this.lengthType = TupleNumericType.U8;
        this.amountRanges = [];
        this.participationConfig = null;
        this.participationState = null;
        if (args.directArgs) {
            Object.assign(this, args.directArgs);
        }
        else if (args.data) {
            this.auctionManager = bs58_1.default.encode(args.data.slice(1, 33));
            this.order = new bn_js_1.default(args.data.slice(33, 41), 'le');
            this.winningConfigType = args.data[41];
            this.amountType = args.data[42];
            this.lengthType = args.data[43];
            const lengthOfArray = new bn_js_1.default(args.data.slice(44, 48), 'le');
            this.amountRanges = [];
            let offset = 48;
            for (let i = 0; i < lengthOfArray.toNumber(); i++) {
                const amount = this.getBNFromData(args.data, offset, this.amountType);
                offset += this.amountType;
                const length = this.getBNFromData(args.data, offset, this.lengthType);
                offset += this.lengthType;
                this.amountRanges.push(new AmountRange({ amount, length }));
            }
            if (args.data[offset] == 0) {
                offset += 1;
                this.participationConfig = null;
            }
            else {
                // pick up participation config manually
                const winnerConstraintAsNumber = args.data[offset + 1];
                const nonWinnerConstraintAsNumber = args.data[offset + 2];
                let fixedPrice = null;
                offset += 3;
                if (args.data[offset] == 1) {
                    fixedPrice = new bn_js_1.default(args.data.slice(offset + 1, offset + 9), 'le');
                    offset += 9;
                }
                else {
                    offset += 1;
                }
                this.participationConfig = new ParticipationConfigV2({
                    winnerConstraint: winnerConstraintAsNumber,
                    nonWinningConstraint: nonWinnerConstraintAsNumber,
                    fixedPrice: fixedPrice,
                });
            }
            if (args.data[offset] == 0) {
                offset += 1;
                this.participationState = null;
            }
            else {
                // pick up participation state manually
                const collectedToAcceptPayment = new bn_js_1.default(args.data.slice(offset + 1, offset + 9), 'le');
                offset += 9;
                this.participationState = new ParticipationStateV2({
                    collectedToAcceptPayment,
                });
            }
        }
    }
    getBNFromData(data, offset, dataType) {
        switch (dataType) {
            case TupleNumericType.U8:
                return new bn_js_1.default(data[offset], 'le');
            case TupleNumericType.U16:
                return new bn_js_1.default(data.slice(offset, offset + 2), 'le');
            case TupleNumericType.U32:
                return new bn_js_1.default(data.slice(offset, offset + 4), 'le');
            case TupleNumericType.U64:
                return new bn_js_1.default(data.slice(offset, offset + 8), 'le');
        }
    }
    getAmountForWinner(winner) {
        let start = new bn_js_1.default(0);
        for (let i = 0; i < this.amountRanges.length; i++) {
            const end = start.add(this.amountRanges[i].length);
            if (winner.gte(start) && winner.lt(end)) {
                return this.amountRanges[i].amount;
            }
            start = end;
        }
        return new bn_js_1.default(0);
    }
}
exports.SafetyDepositConfig = SafetyDepositConfig;
class ValidateSafetyDepositBoxV2Args {
    constructor(safetyDeposit) {
        this.instruction = 18;
        this.safetyDepositConfig = safetyDeposit;
    }
}
exports.ValidateSafetyDepositBoxV2Args = ValidateSafetyDepositBoxV2Args;
exports.SCHEMA = new Map([
    ...deprecatedStates_1.DEPRECATED_SCHEMA,
    [
        StoreIndexer,
        {
            kind: 'struct',
            fields: [
                ['key', 'u8'],
                ['store', 'pubkeyAsString'],
                ['page', 'u64'],
                ['auctionCaches', ['pubkeyAsString']],
            ],
        },
    ],
    [
        AuctionCache,
        {
            kind: 'struct',
            fields: [
                ['key', 'u8'],
                ['store', 'pubkeyAsString'],
                ['timestamp', 'u64'],
                ['metadata', ['pubkeyAsString']],
                ['auction', 'pubkeyAsString'],
                ['vault', 'pubkeyAsString'],
                ['auctionManager', 'pubkeyAsString'],
            ],
        },
    ],
    [
        PrizeTrackingTicket,
        {
            kind: 'struct',
            fields: [
                ['key', 'u8'],
                ['metadata', 'pubkeyAsString'],
                ['supplySnapshot', 'u64'],
                ['expectedRedemptions', 'u64'],
                ['redemptions', 'u64'],
            ],
        },
    ],
    [
        AuctionManagerV2,
        {
            kind: 'struct',
            fields: [
                ['key', 'u8'],
                ['store', 'pubkeyAsString'],
                ['authority', 'pubkeyAsString'],
                ['auction', 'pubkeyAsString'],
                ['vault', 'pubkeyAsString'],
                ['acceptPayment', 'pubkeyAsString'],
                ['state', AuctionManagerStateV2],
            ],
        },
    ],
    [
        ParticipationConfigV2,
        {
            kind: 'struct',
            fields: [
                ['winnerConstraint', 'u8'],
                ['nonWinningConstraint', 'u8'],
                ['fixedPrice', { kind: 'option', type: 'u64' }],
            ],
        },
    ],
    [
        WhitelistedCreator,
        {
            kind: 'struct',
            fields: [
                ['key', 'u8'],
                ['address', 'pubkeyAsString'],
                ['activated', 'u8'],
            ],
        },
    ],
    [
        Store,
        {
            kind: 'struct',
            fields: [
                ['key', 'u8'],
                ['public', 'u8'],
                ['auctionProgram', 'pubkeyAsString'],
                ['tokenVaultProgram', 'pubkeyAsString'],
                ['tokenMetadataProgram', 'pubkeyAsString'],
                ['tokenProgram', 'pubkeyAsString'],
            ],
        },
    ],
    [
        AuctionManagerStateV2,
        {
            kind: 'struct',
            fields: [
                ['status', 'u8'],
                ['safetyConfigItemsValidated', 'u64'],
                ['bidsPushedToAcceptPayment', 'u64'],
                ['hasParticipation', 'u8'],
            ],
        },
    ],
    [
        ParticipationStateV2,
        {
            kind: 'struct',
            fields: [['collectedToAcceptPayment', 'u64']],
        },
    ],
    [
        PayoutTicket,
        {
            kind: 'struct',
            fields: [
                ['key', 'u8'],
                ['recipient', 'pubkeyAsString'],
                ['amountPaid', 'u64'],
            ],
        },
    ],
    [
        AmountRange,
        {
            kind: 'struct',
            fields: [
                ['amount', 'u64'],
                ['length', 'u64'],
            ],
        },
    ],
    [
        SafetyDepositConfig,
        {
            kind: 'struct',
            fields: [
                ['key', 'u8'],
                ['auctionManager', 'pubkeyAsString'],
                ['order', 'u64'],
                ['winningConfigType', 'u8'],
                ['amountType', 'u8'],
                ['lengthType', 'u8'],
                ['amountRanges', [AmountRange]],
                [
                    'participationConfig',
                    { kind: 'option', type: ParticipationConfigV2 },
                ],
                ['participationState', { kind: 'option', type: ParticipationStateV2 }],
            ],
        },
    ],
    [
        RedeemUnusedWinningConfigItemsAsAuctioneerArgs,
        {
            kind: 'struct',
            fields: [
                ['instruction', 'u8'],
                ['winningConfigItemIndex', 'u8'],
                ['proxyCall', 'u8'],
            ],
        },
    ],
    [
        DecommissionAuctionManagerArgs,
        {
            kind: 'struct',
            fields: [['instruction', 'u8']],
        },
    ],
    [
        RedeemPrintingV2BidArgs,
        {
            kind: 'struct',
            fields: [
                ['instruction', 'u8'],
                ['editionOffset', 'u64'],
                ['winIndex', 'u64'],
            ],
        },
    ],
    [
        WithdrawMasterEditionArgs,
        {
            kind: 'struct',
            fields: [['instruction', 'u8']],
        },
    ],
    [
        RedeemParticipationBidV3Args,
        {
            kind: 'struct',
            fields: [
                ['instruction', 'u8'],
                ['winIndex', { kind: 'option', type: 'u64' }],
            ],
        },
    ],
    [
        InitAuctionManagerV2Args,
        {
            kind: 'struct',
            fields: [
                ['instruction', 'u8'],
                ['amountType', 'u8'],
                ['lengthType', 'u8'],
                ['maxRanges', 'u64'],
            ],
        },
    ],
    [
        ValidateSafetyDepositBoxV2Args,
        {
            kind: 'struct',
            fields: [
                ['instruction', 'u8'],
                ['safetyDepositConfig', SafetyDepositConfig],
            ],
        },
    ],
    [
        RedeemBidArgs,
        {
            kind: 'struct',
            fields: [['instruction', 'u8']],
        },
    ],
    [
        RedeemFullRightsTransferBidArgs,
        {
            kind: 'struct',
            fields: [['instruction', 'u8']],
        },
    ],
    [
        StartAuctionArgs,
        {
            kind: 'struct',
            fields: [['instruction', 'u8']],
        },
    ],
    [
        EndAuctionArgs,
        {
            kind: 'struct',
            fields: [
                ['instruction', 'u8'],
                ['reveal', { kind: 'option', type: [bn_js_1.default] }],
            ],
        },
    ],
    [
        ClaimBidArgs,
        {
            kind: 'struct',
            fields: [['instruction', 'u8']],
        },
    ],
    [
        SetAuctionCacheArgs,
        {
            kind: 'struct',
            fields: [['instruction', 'u8']],
        },
    ],
    [
        SetStoreIndexArgs,
        {
            kind: 'struct',
            fields: [
                ['instruction', 'u8'],
                ['page', 'u64'],
                ['offset', 'u64'],
            ],
        },
    ],
    [
        EmptyPaymentAccountArgs,
        {
            kind: 'struct',
            fields: [
                ['instruction', 'u8'],
                ['winningConfigIndex', { kind: 'option', type: 'u8' }],
                ['winningConfigItemIndex', { kind: 'option', type: 'u8' }],
                ['creatorIndex', { kind: 'option', type: 'u8' }],
            ],
        },
    ],
    [
        SetStoreArgs,
        {
            kind: 'struct',
            fields: [
                ['instruction', 'u8'],
                ['public', 'u8'], //bool
            ],
        },
    ],
    [
        SetWhitelistedCreatorArgs,
        {
            kind: 'struct',
            fields: [
                ['instruction', 'u8'],
                ['activated', 'u8'], //bool
            ],
        },
    ],
]);
async function getAuctionManagerKey(vault, auctionKey) {
    const PROGRAM_IDS = (0, utils_1.programIds)();
    return (await (0, utils_1.findProgramAddress)([Buffer.from(exports.METAPLEX_PREFIX), (0, utils_1.toPublicKey)(auctionKey).toBuffer()], (0, utils_1.toPublicKey)(PROGRAM_IDS.metaplex)))[0];
}
exports.getAuctionManagerKey = getAuctionManagerKey;
async function getAuctionKeys(vault) {
    const PROGRAM_IDS = (0, utils_1.programIds)();
    const auctionKey = (await (0, utils_1.findProgramAddress)([
        Buffer.from(actions_1.AUCTION_PREFIX),
        (0, utils_1.toPublicKey)(PROGRAM_IDS.auction).toBuffer(),
        (0, utils_1.toPublicKey)(vault).toBuffer(),
    ], (0, utils_1.toPublicKey)(PROGRAM_IDS.auction)))[0];
    const auctionManagerKey = await getAuctionManagerKey(vault, auctionKey);
    return { auctionKey, auctionManagerKey };
}
exports.getAuctionKeys = getAuctionKeys;
async function getBidRedemption(auctionKey, bidMetadata) {
    const PROGRAM_IDS = (0, utils_1.programIds)();
    return (await (0, utils_1.findProgramAddress)([
        Buffer.from(exports.METAPLEX_PREFIX),
        (0, utils_1.toPublicKey)(auctionKey).toBuffer(),
        (0, utils_1.toPublicKey)(bidMetadata).toBuffer(),
    ], (0, utils_1.toPublicKey)(PROGRAM_IDS.metaplex)))[0];
}
exports.getBidRedemption = getBidRedemption;
async function getBidderKeys(auctionKey, bidder) {
    const PROGRAM_IDS = (0, utils_1.programIds)();
    const bidMetadata = (await (0, utils_1.findProgramAddress)([
        Buffer.from(actions_1.AUCTION_PREFIX),
        (0, utils_1.toPublicKey)(PROGRAM_IDS.auction).toBuffer(),
        (0, utils_1.toPublicKey)(auctionKey).toBuffer(),
        (0, utils_1.toPublicKey)(bidder).toBuffer(),
        Buffer.from(actions_1.METADATA),
    ], (0, utils_1.toPublicKey)(PROGRAM_IDS.auction)))[0];
    const bidRedemption = await getBidRedemption(auctionKey, bidMetadata);
    return { bidMetadata, bidRedemption };
}
exports.getBidderKeys = getBidderKeys;
async function getOriginalAuthority(auctionKey, metadata) {
    const PROGRAM_IDS = (0, utils_1.programIds)();
    return (await (0, utils_1.findProgramAddress)([
        Buffer.from(exports.METAPLEX_PREFIX),
        (0, utils_1.toPublicKey)(auctionKey).toBuffer(),
        (0, utils_1.toPublicKey)(metadata).toBuffer(),
    ], (0, utils_1.toPublicKey)(PROGRAM_IDS.metaplex)))[0];
}
exports.getOriginalAuthority = getOriginalAuthority;
const isCreatorPartOfTheStore = async (creatorAddress, pubkey, store) => {
    const creatorKeyInStore = await getWhitelistedCreator(creatorAddress, store);
    return creatorKeyInStore === pubkey;
};
exports.isCreatorPartOfTheStore = isCreatorPartOfTheStore;
async function getWhitelistedCreator(creator, storeId) {
    const PROGRAM_IDS = (0, utils_1.programIds)();
    const store = storeId || PROGRAM_IDS.store;
    if (!store) {
        throw new Error('Store not initialized');
    }
    return (await (0, utils_1.findProgramAddress)([
        Buffer.from(exports.METAPLEX_PREFIX),
        (0, utils_1.toPublicKey)(PROGRAM_IDS.metaplex).toBuffer(),
        (0, utils_1.toPublicKey)(store).toBuffer(),
        (0, utils_1.toPublicKey)(creator).toBuffer(),
    ], (0, utils_1.toPublicKey)(PROGRAM_IDS.metaplex)))[0];
}
exports.getWhitelistedCreator = getWhitelistedCreator;
async function getPrizeTrackingTicket(auctionManager, mint) {
    const PROGRAM_IDS = (0, utils_1.programIds)();
    const store = PROGRAM_IDS.store;
    if (!store) {
        throw new Error('Store not initialized');
    }
    return (await (0, utils_1.findProgramAddress)([
        Buffer.from(exports.METAPLEX_PREFIX),
        (0, utils_1.toPublicKey)(PROGRAM_IDS.metaplex).toBuffer(),
        (0, utils_1.toPublicKey)(auctionManager).toBuffer(),
        (0, utils_1.toPublicKey)(mint).toBuffer(),
    ], (0, utils_1.toPublicKey)(PROGRAM_IDS.metaplex)))[0];
}
exports.getPrizeTrackingTicket = getPrizeTrackingTicket;
async function getAuctionWinnerTokenTypeTracker(auctionManager) {
    const PROGRAM_IDS = (0, utils_1.programIds)();
    const store = PROGRAM_IDS.store;
    if (!store) {
        throw new Error('Store not initialized');
    }
    return (await (0, utils_1.findProgramAddress)([
        Buffer.from(exports.METAPLEX_PREFIX),
        (0, utils_1.toPublicKey)(PROGRAM_IDS.metaplex).toBuffer(),
        (0, utils_1.toPublicKey)(auctionManager).toBuffer(),
        Buffer.from(exports.TOTALS),
    ], (0, utils_1.toPublicKey)(PROGRAM_IDS.metaplex)))[0];
}
exports.getAuctionWinnerTokenTypeTracker = getAuctionWinnerTokenTypeTracker;
async function getSafetyDepositConfig(auctionManager, safetyDeposit) {
    const PROGRAM_IDS = (0, utils_1.programIds)();
    const store = PROGRAM_IDS.store;
    if (!store) {
        throw new Error('Store not initialized');
    }
    return (await (0, utils_1.findProgramAddress)([
        Buffer.from(exports.METAPLEX_PREFIX),
        (0, utils_1.toPublicKey)(PROGRAM_IDS.metaplex).toBuffer(),
        (0, utils_1.toPublicKey)(auctionManager).toBuffer(),
        (0, utils_1.toPublicKey)(safetyDeposit).toBuffer(),
    ], (0, utils_1.toPublicKey)(PROGRAM_IDS.metaplex)))[0];
}
exports.getSafetyDepositConfig = getSafetyDepositConfig;
async function getStoreIndexer(page) {
    const PROGRAM_IDS = (0, utils_1.programIds)();
    const store = PROGRAM_IDS.store;
    if (!store) {
        throw new Error('Store not initialized');
    }
    return (await (0, utils_1.findProgramAddress)([
        Buffer.from(exports.METAPLEX_PREFIX),
        (0, utils_1.toPublicKey)(PROGRAM_IDS.metaplex).toBuffer(),
        (0, utils_1.toPublicKey)(store).toBuffer(),
        Buffer.from(exports.INDEX),
        Buffer.from(page.toString()),
    ], (0, utils_1.toPublicKey)(PROGRAM_IDS.metaplex)))[0];
}
exports.getStoreIndexer = getStoreIndexer;
async function getAuctionCache(auction) {
    const PROGRAM_IDS = (0, utils_1.programIds)();
    const store = PROGRAM_IDS.store;
    if (!store) {
        throw new Error('Store not initialized');
    }
    console.log('Auction', auction);
    return (await (0, utils_1.findProgramAddress)([
        Buffer.from(exports.METAPLEX_PREFIX),
        (0, utils_1.toPublicKey)(PROGRAM_IDS.metaplex).toBuffer(),
        (0, utils_1.toPublicKey)(store).toBuffer(),
        (0, utils_1.toPublicKey)(auction).toBuffer(),
        Buffer.from(exports.CACHE),
    ], (0, utils_1.toPublicKey)(PROGRAM_IDS.metaplex)))[0];
}
exports.getAuctionCache = getAuctionCache;
async function getPayoutTicket(auctionManager, winnerConfigIndex, winnerConfigItemIndex, creatorIndex, safetyDepositBox, recipient) {
    const PROGRAM_IDS = (0, utils_1.programIds)();
    return (await (0, utils_1.findProgramAddress)([
        Buffer.from(exports.METAPLEX_PREFIX),
        (0, utils_1.toPublicKey)(auctionManager).toBuffer(),
        Buffer.from(winnerConfigIndex !== null && winnerConfigIndex !== undefined
            ? winnerConfigIndex.toString()
            : 'participation'),
        Buffer.from(winnerConfigItemIndex !== null && winnerConfigItemIndex !== undefined
            ? winnerConfigItemIndex.toString()
            : '0'),
        Buffer.from(creatorIndex !== null && creatorIndex !== undefined
            ? creatorIndex.toString()
            : 'auctioneer'),
        (0, utils_1.toPublicKey)(safetyDepositBox).toBuffer(),
        (0, utils_1.toPublicKey)(recipient).toBuffer(),
    ], (0, utils_1.toPublicKey)(PROGRAM_IDS.metaplex)))[0];
}
exports.getPayoutTicket = getPayoutTicket;
//# sourceMappingURL=index.js.map

/***/ }),

/***/ 3607:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

var __webpack_unused_export__;

__webpack_unused_export__ = ({ value: true });
exports.J = void 0;
const web3_js_1 = __webpack_require__(5681);
const borsh_1 = __webpack_require__(7384);
const _1 = __webpack_require__(4373);
const utils_1 = __webpack_require__(398);
async function initAuctionManagerV2(vault, auctionManagerAuthority, payer, acceptPaymentAccount, store, amountType, lengthType, maxRanges, instructions) {
    const PROGRAM_IDS = (0, utils_1.programIds)();
    const { auctionKey, auctionManagerKey } = await (0, _1.getAuctionKeys)(vault);
    const value = new _1.InitAuctionManagerV2Args({
        amountType,
        lengthType,
        maxRanges,
    });
    const tokenTracker = await (0, _1.getAuctionWinnerTokenTypeTracker)(auctionManagerKey);
    const data = Buffer.from((0, borsh_1.serialize)(_1.SCHEMA, value));
    const keys = [
        {
            pubkey: (0, utils_1.toPublicKey)(auctionManagerKey),
            isSigner: false,
            isWritable: true,
        },
        {
            pubkey: (0, utils_1.toPublicKey)(tokenTracker),
            isSigner: false,
            isWritable: true,
        },
        {
            pubkey: (0, utils_1.toPublicKey)(vault),
            isSigner: false,
            isWritable: false,
        },
        {
            pubkey: (0, utils_1.toPublicKey)(auctionKey),
            isSigner: false,
            isWritable: false,
        },
        {
            pubkey: (0, utils_1.toPublicKey)(auctionManagerAuthority),
            isSigner: false,
            isWritable: false,
        },
        {
            pubkey: (0, utils_1.toPublicKey)(payer),
            isSigner: true,
            isWritable: false,
        },
        {
            pubkey: (0, utils_1.toPublicKey)(acceptPaymentAccount),
            isSigner: false,
            isWritable: false,
        },
        {
            pubkey: (0, utils_1.toPublicKey)(store),
            isSigner: false,
            isWritable: false,
        },
        {
            pubkey: web3_js_1.SystemProgram.programId,
            isSigner: false,
            isWritable: false,
        },
        {
            pubkey: web3_js_1.SYSVAR_RENT_PUBKEY,
            isSigner: false,
            isWritable: false,
        },
    ];
    instructions.push(new web3_js_1.TransactionInstruction({
        keys,
        programId: (0, utils_1.toPublicKey)(PROGRAM_IDS.metaplex),
        data,
    }));
}
exports.J = initAuctionManagerV2;
//# sourceMappingURL=initAuctionManagerV2.js.map

/***/ }),

/***/ 1162:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.redeemBid = void 0;
const web3_js_1 = __webpack_require__(5681);
const borsh_1 = __webpack_require__(7384);
const _1 = __webpack_require__(4373);
const actions_1 = __webpack_require__(6618);
const utils_1 = __webpack_require__(398);
async function redeemBid(vault, safetyDepositTokenStore, destination, safetyDeposit, fractionMint, bidder, payer, masterEdition, reservationList, isPrintingType, instructions, 
// If this is an auctioneer trying to reclaim a specific winning index, pass it here,
// and this will instead call the proxy route instead of the real one, wrapping the original
// redemption call in an override call that forces the winning index if the auctioneer is authorized.
auctioneerReclaimIndex) {
    const PROGRAM_IDS = (0, utils_1.programIds)();
    const store = PROGRAM_IDS.store;
    if (!store) {
        throw new Error('Store not initialized');
    }
    const { auctionKey, auctionManagerKey } = await (0, _1.getAuctionKeys)(vault);
    const { bidRedemption, bidMetadata } = await (0, _1.getBidderKeys)(auctionKey, bidder);
    const transferAuthority = (await (0, utils_1.findProgramAddress)([
        Buffer.from(actions_1.VAULT_PREFIX),
        (0, utils_1.toPublicKey)(PROGRAM_IDS.vault).toBuffer(),
        (0, utils_1.toPublicKey)(vault).toBuffer(),
    ], (0, utils_1.toPublicKey)(PROGRAM_IDS.vault)))[0];
    const safetyDepositConfig = await (0, _1.getSafetyDepositConfig)(auctionManagerKey, safetyDeposit);
    const auctionExtended = await (0, actions_1.getAuctionExtended)({
        auctionProgramId: PROGRAM_IDS.auction,
        resource: vault,
    });
    const value = auctioneerReclaimIndex !== undefined
        ? new _1.RedeemUnusedWinningConfigItemsAsAuctioneerArgs({
            winningConfigItemIndex: auctioneerReclaimIndex,
            proxyCall: _1.ProxyCallAddress.RedeemBid,
        })
        : new _1.RedeemBidArgs();
    const data = Buffer.from((0, borsh_1.serialize)(_1.SCHEMA, value));
    const keys = [
        {
            pubkey: (0, utils_1.toPublicKey)(auctionManagerKey),
            isSigner: false,
            isWritable: true,
        },
        {
            pubkey: (0, utils_1.toPublicKey)(safetyDepositTokenStore),
            isSigner: false,
            isWritable: true,
        },
        {
            pubkey: (0, utils_1.toPublicKey)(destination),
            isSigner: false,
            isWritable: true,
        },
        {
            pubkey: (0, utils_1.toPublicKey)(bidRedemption),
            isSigner: false,
            isWritable: true,
        },
        {
            pubkey: (0, utils_1.toPublicKey)(safetyDeposit),
            isSigner: false,
            isWritable: true,
        },
        {
            pubkey: (0, utils_1.toPublicKey)(vault),
            isSigner: false,
            isWritable: true,
        },
        {
            pubkey: (0, utils_1.toPublicKey)(fractionMint),
            isSigner: false,
            isWritable: true,
        },
        {
            pubkey: (0, utils_1.toPublicKey)(auctionKey),
            isSigner: false,
            isWritable: false,
        },
        {
            pubkey: (0, utils_1.toPublicKey)(bidMetadata),
            isSigner: false,
            isWritable: false,
        },
        {
            pubkey: (0, utils_1.toPublicKey)(bidder),
            isSigner: false,
            isWritable: false,
        },
        {
            pubkey: (0, utils_1.toPublicKey)(payer),
            isSigner: true,
            isWritable: false,
        },
        {
            pubkey: PROGRAM_IDS.token,
            isSigner: false,
            isWritable: false,
        },
        {
            pubkey: (0, utils_1.toPublicKey)(PROGRAM_IDS.vault),
            isSigner: false,
            isWritable: false,
        },
        {
            pubkey: (0, utils_1.toPublicKey)(PROGRAM_IDS.metadata),
            isSigner: false,
            isWritable: false,
        },
        {
            pubkey: store,
            isSigner: false,
            isWritable: false,
        },
        {
            pubkey: web3_js_1.SystemProgram.programId,
            isSigner: false,
            isWritable: false,
        },
        {
            pubkey: web3_js_1.SYSVAR_RENT_PUBKEY,
            isSigner: false,
            isWritable: false,
        },
        {
            pubkey: (0, utils_1.toPublicKey)(transferAuthority),
            isSigner: false,
            isWritable: false,
        },
        {
            pubkey: (0, utils_1.toPublicKey)(safetyDepositConfig),
            isSigner: false,
            isWritable: false,
        },
        {
            pubkey: (0, utils_1.toPublicKey)(auctionExtended),
            isSigner: false,
            isWritable: false,
        },
    ];
    if (isPrintingType && masterEdition && reservationList) {
        keys.push({
            pubkey: (0, utils_1.toPublicKey)(masterEdition),
            isSigner: false,
            isWritable: true,
        });
        keys.push({
            pubkey: (0, utils_1.toPublicKey)(reservationList),
            isSigner: false,
            isWritable: true,
        });
    }
    instructions.push(new web3_js_1.TransactionInstruction({
        keys,
        programId: (0, utils_1.toPublicKey)(PROGRAM_IDS.metaplex),
        data,
    }));
}
exports.redeemBid = redeemBid;
//# sourceMappingURL=redeemBid.js.map

/***/ }),

/***/ 1860:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.redeemFullRightsTransferBid = void 0;
const web3_js_1 = __webpack_require__(5681);
const borsh_1 = __webpack_require__(7384);
const _1 = __webpack_require__(4373);
const actions_1 = __webpack_require__(6618);
const utils_1 = __webpack_require__(398);
async function redeemFullRightsTransferBid(vault, safetyDepositTokenStore, destination, safetyDeposit, fractionMint, bidder, payer, instructions, masterMetadata, newAuthority, 
// If this is an auctioneer trying to reclaim a specific winning index, pass it here,
// and this will instead call the proxy route instead of the real one, wrapping the original
// redemption call in an override call that forces the winning index if the auctioneer is authorized.
auctioneerReclaimIndex) {
    const PROGRAM_IDS = (0, utils_1.programIds)();
    const store = PROGRAM_IDS.store;
    if (!store) {
        throw new Error('Store not initialized');
    }
    const { auctionKey, auctionManagerKey } = await (0, _1.getAuctionKeys)(vault);
    const { bidRedemption, bidMetadata } = await (0, _1.getBidderKeys)(auctionKey, bidder);
    const transferAuthority = (await (0, utils_1.findProgramAddress)([
        Buffer.from(actions_1.VAULT_PREFIX),
        (0, utils_1.toPublicKey)(PROGRAM_IDS.vault).toBuffer(),
        (0, utils_1.toPublicKey)(vault).toBuffer(),
    ], (0, utils_1.toPublicKey)(PROGRAM_IDS.vault)))[0];
    const safetyDepositConfig = await (0, _1.getSafetyDepositConfig)(auctionManagerKey, safetyDeposit);
    const auctionExtended = await (0, actions_1.getAuctionExtended)({
        auctionProgramId: PROGRAM_IDS.auction,
        resource: vault,
    });
    const value = auctioneerReclaimIndex !== undefined
        ? new _1.RedeemUnusedWinningConfigItemsAsAuctioneerArgs({
            winningConfigItemIndex: auctioneerReclaimIndex,
            proxyCall: _1.ProxyCallAddress.RedeemFullRightsTransferBid,
        })
        : new _1.RedeemFullRightsTransferBidArgs();
    const data = Buffer.from((0, borsh_1.serialize)(_1.SCHEMA, value));
    const keys = [
        {
            pubkey: (0, utils_1.toPublicKey)(auctionManagerKey),
            isSigner: false,
            isWritable: true,
        },
        {
            pubkey: (0, utils_1.toPublicKey)(safetyDepositTokenStore),
            isSigner: false,
            isWritable: true,
        },
        {
            pubkey: (0, utils_1.toPublicKey)(destination),
            isSigner: false,
            isWritable: true,
        },
        {
            pubkey: (0, utils_1.toPublicKey)(bidRedemption),
            isSigner: false,
            isWritable: true,
        },
        {
            pubkey: (0, utils_1.toPublicKey)(safetyDeposit),
            isSigner: false,
            isWritable: true,
        },
        {
            pubkey: (0, utils_1.toPublicKey)(vault),
            isSigner: false,
            isWritable: true,
        },
        {
            pubkey: (0, utils_1.toPublicKey)(fractionMint),
            isSigner: false,
            isWritable: true,
        },
        {
            pubkey: (0, utils_1.toPublicKey)(auctionKey),
            isSigner: false,
            isWritable: false,
        },
        {
            pubkey: (0, utils_1.toPublicKey)(bidMetadata),
            isSigner: false,
            isWritable: false,
        },
        {
            pubkey: (0, utils_1.toPublicKey)(bidder),
            isSigner: false,
            isWritable: false,
        },
        {
            pubkey: (0, utils_1.toPublicKey)(payer),
            isSigner: true,
            isWritable: false,
        },
        {
            pubkey: PROGRAM_IDS.token,
            isSigner: false,
            isWritable: false,
        },
        {
            pubkey: (0, utils_1.toPublicKey)(PROGRAM_IDS.vault),
            isSigner: false,
            isWritable: false,
        },
        {
            pubkey: (0, utils_1.toPublicKey)(PROGRAM_IDS.metadata),
            isSigner: false,
            isWritable: false,
        },
        {
            pubkey: store,
            isSigner: false,
            isWritable: false,
        },
        {
            pubkey: web3_js_1.SystemProgram.programId,
            isSigner: false,
            isWritable: false,
        },
        {
            pubkey: web3_js_1.SYSVAR_RENT_PUBKEY,
            isSigner: false,
            isWritable: false,
        },
        {
            pubkey: (0, utils_1.toPublicKey)(masterMetadata),
            isSigner: false,
            isWritable: true,
        },
        {
            pubkey: (0, utils_1.toPublicKey)(newAuthority),
            isSigner: false,
            isWritable: false,
        },
        {
            pubkey: (0, utils_1.toPublicKey)(transferAuthority),
            isSigner: false,
            isWritable: false,
        },
        {
            pubkey: (0, utils_1.toPublicKey)(safetyDepositConfig),
            isSigner: false,
            isWritable: false,
        },
        {
            pubkey: (0, utils_1.toPublicKey)(auctionExtended),
            isSigner: false,
            isWritable: false,
        },
    ];
    instructions.push(new web3_js_1.TransactionInstruction({
        keys,
        programId: (0, utils_1.toPublicKey)(PROGRAM_IDS.metaplex),
        data,
    }));
}
exports.redeemFullRightsTransferBid = redeemFullRightsTransferBid;
//# sourceMappingURL=redeemFullRightsTransferBid.js.map

/***/ }),

/***/ 3784:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.redeemParticipationBidV3 = void 0;
const web3_js_1 = __webpack_require__(5681);
const borsh_1 = __webpack_require__(7384);
const _1 = __webpack_require__(4373);
const actions_1 = __webpack_require__(6618);
const utils_1 = __webpack_require__(398);
async function redeemParticipationBidV3(vault, safetyDepositTokenStore, destination, safetyDeposit, bidder, payer, metadata, masterEdition, originalMint, transferAuthority, acceptPaymentAccount, tokenPaymentAccount, newMint, edition, winIndex, instructions) {
    const PROGRAM_IDS = (0, utils_1.programIds)();
    const store = PROGRAM_IDS.store;
    if (!store) {
        throw new Error('Store not initialized');
    }
    const { auctionKey, auctionManagerKey } = await (0, _1.getAuctionKeys)(vault);
    const auctionDataExtended = await (0, actions_1.getAuctionExtended)({
        auctionProgramId: PROGRAM_IDS.auction,
        resource: vault,
    });
    const { bidRedemption, bidMetadata } = await (0, _1.getBidderKeys)(auctionKey, bidder);
    const prizeTrackingTicket = await (0, _1.getPrizeTrackingTicket)(auctionManagerKey, originalMint);
    const newMetadata = await (0, actions_1.getMetadata)(newMint);
    const newEdition = await (0, actions_1.getEdition)(newMint);
    const editionMarkPda = await (0, actions_1.getEditionMarkPda)(originalMint, edition);
    const safetyDepositConfig = await (0, _1.getSafetyDepositConfig)(auctionManagerKey, safetyDeposit);
    const value = new _1.RedeemParticipationBidV3Args({ winIndex });
    const data = Buffer.from((0, borsh_1.serialize)(_1.SCHEMA, value));
    const keys = [
        {
            pubkey: (0, utils_1.toPublicKey)(auctionManagerKey),
            isSigner: false,
            isWritable: true,
        },
        {
            pubkey: (0, utils_1.toPublicKey)(safetyDepositTokenStore),
            isSigner: false,
            isWritable: true,
        },
        {
            pubkey: (0, utils_1.toPublicKey)(destination),
            isSigner: false,
            isWritable: true,
        },
        {
            pubkey: (0, utils_1.toPublicKey)(bidRedemption),
            isSigner: false,
            isWritable: true,
        },
        {
            pubkey: (0, utils_1.toPublicKey)(safetyDeposit),
            isSigner: false,
            isWritable: false,
        },
        {
            pubkey: (0, utils_1.toPublicKey)(vault),
            isSigner: false,
            isWritable: false,
        },
        {
            pubkey: (0, utils_1.toPublicKey)(safetyDepositConfig),
            isSigner: false,
            isWritable: true,
        },
        {
            pubkey: (0, utils_1.toPublicKey)(auctionKey),
            isSigner: false,
            isWritable: false,
        },
        {
            pubkey: (0, utils_1.toPublicKey)(bidMetadata),
            isSigner: false,
            isWritable: false,
        },
        {
            pubkey: (0, utils_1.toPublicKey)(bidder),
            isSigner: false,
            isWritable: true,
        },
        {
            pubkey: (0, utils_1.toPublicKey)(payer),
            isSigner: true,
            isWritable: true,
        },
        {
            pubkey: PROGRAM_IDS.token,
            isSigner: false,
            isWritable: false,
        },
        {
            pubkey: (0, utils_1.toPublicKey)(PROGRAM_IDS.vault),
            isSigner: false,
            isWritable: false,
        },
        {
            pubkey: (0, utils_1.toPublicKey)(PROGRAM_IDS.metadata),
            isSigner: false,
            isWritable: false,
        },
        {
            pubkey: store,
            isSigner: false,
            isWritable: false,
        },
        {
            pubkey: web3_js_1.SystemProgram.programId,
            isSigner: false,
            isWritable: false,
        },
        {
            pubkey: web3_js_1.SYSVAR_RENT_PUBKEY,
            isSigner: false,
            isWritable: false,
        },
        {
            pubkey: (0, utils_1.toPublicKey)(transferAuthority),
            isSigner: true,
            isWritable: false,
        },
        {
            pubkey: (0, utils_1.toPublicKey)(acceptPaymentAccount),
            isSigner: false,
            isWritable: true,
        },
        {
            pubkey: (0, utils_1.toPublicKey)(tokenPaymentAccount),
            isSigner: false,
            isWritable: true,
        },
        {
            pubkey: (0, utils_1.toPublicKey)(prizeTrackingTicket),
            isSigner: false,
            isWritable: true,
        },
        {
            pubkey: (0, utils_1.toPublicKey)(newMetadata),
            isSigner: false,
            isWritable: true,
        },
        {
            pubkey: (0, utils_1.toPublicKey)(newEdition),
            isSigner: false,
            isWritable: true,
        },
        {
            pubkey: (0, utils_1.toPublicKey)(masterEdition),
            isSigner: false,
            isWritable: true,
        },
        {
            pubkey: (0, utils_1.toPublicKey)(newMint),
            isSigner: false,
            isWritable: true,
        },
        {
            pubkey: (0, utils_1.toPublicKey)(editionMarkPda),
            isSigner: false,
            isWritable: true,
        },
        {
            // Mint authority (this) is going to be the payer since the bidder
            // may not be signer hre - we may be redeeming for someone else (permissionless)
            // and during the txn, mint authority is removed from us and given to master edition.
            // The ATA account is already owned by bidder by default. No signing needed
            pubkey: (0, utils_1.toPublicKey)(payer),
            isSigner: true,
            isWritable: false,
        },
        {
            pubkey: (0, utils_1.toPublicKey)(metadata),
            isSigner: false,
            isWritable: false,
        },
        {
            pubkey: (0, utils_1.toPublicKey)(auctionDataExtended),
            isSigner: false,
            isWritable: false,
        },
    ];
    instructions.push(new web3_js_1.TransactionInstruction({
        keys,
        programId: (0, utils_1.toPublicKey)(PROGRAM_IDS.metaplex),
        data,
    }));
}
exports.redeemParticipationBidV3 = redeemParticipationBidV3;
//# sourceMappingURL=redeemParticipationBidV3.js.map

/***/ }),

/***/ 6556:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.redeemPrintingV2Bid = void 0;
const web3_js_1 = __webpack_require__(5681);
const borsh_1 = __webpack_require__(7384);
const _1 = __webpack_require__(4373);
const actions_1 = __webpack_require__(6618);
const utils_1 = __webpack_require__(398);
async function redeemPrintingV2Bid(vault, safetyDepositTokenStore, tokenAccount, safetyDeposit, bidder, payer, metadata, masterEdition, originalMint, newMint, edition, editionOffset, winIndex, instructions) {
    const PROGRAM_IDS = (0, utils_1.programIds)();
    const store = PROGRAM_IDS.store;
    if (!store) {
        throw new Error('Store not initialized');
    }
    const { auctionKey, auctionManagerKey } = await (0, _1.getAuctionKeys)(vault);
    const { bidRedemption, bidMetadata } = await (0, _1.getBidderKeys)(auctionKey, bidder);
    const prizeTrackingTicket = await (0, _1.getPrizeTrackingTicket)(auctionManagerKey, originalMint);
    const safetyDepositConfig = await (0, _1.getSafetyDepositConfig)(auctionManagerKey, safetyDeposit);
    const newMetadata = await (0, actions_1.getMetadata)(newMint);
    const newEdition = await (0, actions_1.getEdition)(newMint);
    const editionMarkPda = await (0, actions_1.getEditionMarkPda)(originalMint, edition);
    const value = new _1.RedeemPrintingV2BidArgs({ editionOffset, winIndex });
    const data = Buffer.from((0, borsh_1.serialize)(_1.SCHEMA, value));
    const extended = await (0, actions_1.getAuctionExtended)({
        auctionProgramId: PROGRAM_IDS.auction,
        resource: vault,
    });
    const keys = [
        {
            pubkey: (0, utils_1.toPublicKey)(auctionManagerKey),
            isSigner: false,
            isWritable: true,
        },
        {
            pubkey: (0, utils_1.toPublicKey)(safetyDepositTokenStore),
            isSigner: false,
            isWritable: true,
        },
        {
            pubkey: (0, utils_1.toPublicKey)(tokenAccount),
            isSigner: false,
            isWritable: true,
        },
        {
            pubkey: (0, utils_1.toPublicKey)(bidRedemption),
            isSigner: false,
            isWritable: true,
        },
        {
            pubkey: (0, utils_1.toPublicKey)(safetyDeposit),
            isSigner: false,
            isWritable: true,
        },
        {
            pubkey: (0, utils_1.toPublicKey)(vault),
            isSigner: false,
            isWritable: true,
        },
        {
            pubkey: (0, utils_1.toPublicKey)(safetyDepositConfig),
            isSigner: false,
            isWritable: false,
        },
        {
            pubkey: (0, utils_1.toPublicKey)(auctionKey),
            isSigner: false,
            isWritable: false,
        },
        {
            pubkey: (0, utils_1.toPublicKey)(bidMetadata),
            isSigner: false,
            isWritable: false,
        },
        {
            pubkey: (0, utils_1.toPublicKey)(bidder),
            isSigner: false,
            isWritable: false,
        },
        {
            pubkey: (0, utils_1.toPublicKey)(payer),
            isSigner: true,
            isWritable: true,
        },
        {
            pubkey: PROGRAM_IDS.token,
            isSigner: false,
            isWritable: false,
        },
        {
            pubkey: (0, utils_1.toPublicKey)(PROGRAM_IDS.vault),
            isSigner: false,
            isWritable: false,
        },
        {
            pubkey: (0, utils_1.toPublicKey)(PROGRAM_IDS.metadata),
            isSigner: false,
            isWritable: false,
        },
        {
            pubkey: store,
            isSigner: false,
            isWritable: false,
        },
        {
            pubkey: web3_js_1.SystemProgram.programId,
            isSigner: false,
            isWritable: false,
        },
        {
            pubkey: web3_js_1.SYSVAR_RENT_PUBKEY,
            isSigner: false,
            isWritable: false,
        },
        {
            pubkey: (0, utils_1.toPublicKey)(prizeTrackingTicket),
            isSigner: false,
            isWritable: true,
        },
        {
            pubkey: (0, utils_1.toPublicKey)(newMetadata),
            isSigner: false,
            isWritable: true,
        },
        {
            pubkey: (0, utils_1.toPublicKey)(newEdition),
            isSigner: false,
            isWritable: true,
        },
        {
            pubkey: (0, utils_1.toPublicKey)(masterEdition),
            isSigner: false,
            isWritable: true,
        },
        {
            pubkey: (0, utils_1.toPublicKey)(newMint),
            isSigner: false,
            isWritable: true,
        },
        {
            pubkey: (0, utils_1.toPublicKey)(editionMarkPda),
            isSigner: false,
            isWritable: true,
        },
        {
            // Mint authority (this) is going to be the payer since the bidder
            // may not be signer hre - we may be redeeming for someone else (permissionless)
            // and during the txn, mint authority is removed from us and given to master edition.
            // The ATA account is already owned by bidder by default. No signing needed
            pubkey: (0, utils_1.toPublicKey)(payer),
            isSigner: true,
            isWritable: false,
        },
        {
            pubkey: (0, utils_1.toPublicKey)(metadata),
            isSigner: false,
            isWritable: false,
        },
        {
            pubkey: (0, utils_1.toPublicKey)(extended),
            isSigner: false,
            isWritable: false,
        },
    ];
    instructions.push(new web3_js_1.TransactionInstruction({
        keys,
        programId: (0, utils_1.toPublicKey)(PROGRAM_IDS.metaplex),
        data,
    }));
}
exports.redeemPrintingV2Bid = redeemPrintingV2Bid;
//# sourceMappingURL=redeemPrintingV2Bid.js.map

/***/ }),

/***/ 3446:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

var __webpack_unused_export__;

__webpack_unused_export__ = ({ value: true });
exports.t = void 0;
const web3_js_1 = __webpack_require__(5681);
const borsh_1 = __webpack_require__(7384);
const _1 = __webpack_require__(4373);
const utils_1 = __webpack_require__(398);
async function setAuctionCache(auctionCache, payer, auction, safetyDepositBox, auctionManager, page, instructions) {
    const PROGRAM_IDS = (0, utils_1.programIds)();
    const store = PROGRAM_IDS.store;
    if (!store) {
        throw new Error('Store not initialized');
    }
    const value = new _1.SetAuctionCacheArgs();
    const data = Buffer.from((0, borsh_1.serialize)(_1.SCHEMA, value));
    const keys = [
        {
            pubkey: (0, utils_1.toPublicKey)(auctionCache),
            isSigner: false,
            isWritable: true,
        },
        {
            pubkey: (0, utils_1.toPublicKey)(payer),
            isSigner: true,
            isWritable: false,
        },
        {
            pubkey: (0, utils_1.toPublicKey)(auction),
            isSigner: false,
            isWritable: false,
        },
        {
            pubkey: (0, utils_1.toPublicKey)(safetyDepositBox),
            isSigner: false,
            isWritable: false,
        },
        {
            pubkey: (0, utils_1.toPublicKey)(auctionManager),
            isSigner: false,
            isWritable: false,
        },
        {
            pubkey: (0, utils_1.toPublicKey)(store),
            isSigner: false,
            isWritable: false,
        },
        {
            pubkey: PROGRAM_IDS.system,
            isSigner: false,
            isWritable: false,
        },
        {
            pubkey: web3_js_1.SYSVAR_RENT_PUBKEY,
            isSigner: false,
            isWritable: false,
        },
        {
            pubkey: web3_js_1.SYSVAR_CLOCK_PUBKEY,
            isSigner: false,
            isWritable: false,
        },
    ];
    instructions.push(new web3_js_1.TransactionInstruction({
        keys,
        programId: (0, utils_1.toPublicKey)(PROGRAM_IDS.metaplex),
        data,
    }));
}
exports.t = setAuctionCache;
//# sourceMappingURL=setAuctionCache.js.map

/***/ }),

/***/ 712:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

var __webpack_unused_export__;

__webpack_unused_export__ = ({ value: true });
exports.P = void 0;
const web3_js_1 = __webpack_require__(5681);
const borsh_1 = __webpack_require__(7384);
const _1 = __webpack_require__(4373);
const utils_1 = __webpack_require__(398);
async function setStore(isPublic, admin, payer, instructions) {
    const PROGRAM_IDS = (0, utils_1.programIds)();
    const store = PROGRAM_IDS.store;
    if (!store) {
        throw new Error('Store not initialized');
    }
    const value = new _1.SetStoreArgs({ public: isPublic });
    const data = Buffer.from((0, borsh_1.serialize)(_1.SCHEMA, value));
    const keys = [
        {
            pubkey: (0, utils_1.toPublicKey)(store),
            isSigner: false,
            isWritable: true,
        },
        {
            pubkey: (0, utils_1.toPublicKey)(admin),
            isSigner: true,
            isWritable: false,
        },
        {
            pubkey: (0, utils_1.toPublicKey)(payer),
            isSigner: true,
            isWritable: false,
        },
        { pubkey: PROGRAM_IDS.token, isSigner: false, isWritable: false },
        {
            pubkey: (0, utils_1.toPublicKey)(PROGRAM_IDS.vault),
            isSigner: false,
            isWritable: false,
        },
        {
            pubkey: (0, utils_1.toPublicKey)(PROGRAM_IDS.metadata),
            isSigner: false,
            isWritable: false,
        },
        {
            pubkey: (0, utils_1.toPublicKey)(PROGRAM_IDS.auction),
            isSigner: false,
            isWritable: false,
        },
        {
            pubkey: PROGRAM_IDS.system,
            isSigner: false,
            isWritable: false,
        },
        {
            pubkey: web3_js_1.SYSVAR_RENT_PUBKEY,
            isSigner: false,
            isWritable: false,
        },
    ];
    instructions.push(new web3_js_1.TransactionInstruction({
        keys,
        programId: (0, utils_1.toPublicKey)(PROGRAM_IDS.metaplex),
        data,
    }));
}
exports.P = setStore;
//# sourceMappingURL=setStore.js.map

/***/ }),

/***/ 3290:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

var __webpack_unused_export__;

__webpack_unused_export__ = ({ value: true });
exports.I = void 0;
const web3_js_1 = __webpack_require__(5681);
const borsh_1 = __webpack_require__(7384);
const _1 = __webpack_require__(4373);
const utils_1 = __webpack_require__(398);
async function setStoreIndex(storeIndex, auctionCache, payer, page, offset, instructions, belowCache, aboveCache) {
    const PROGRAM_IDS = (0, utils_1.programIds)();
    const store = PROGRAM_IDS.store;
    if (!store) {
        throw new Error('Store not initialized');
    }
    const value = new _1.SetStoreIndexArgs({ page, offset });
    const data = Buffer.from((0, borsh_1.serialize)(_1.SCHEMA, value));
    const keys = [
        {
            pubkey: (0, utils_1.toPublicKey)(storeIndex),
            isSigner: false,
            isWritable: true,
        },
        {
            pubkey: (0, utils_1.toPublicKey)(payer),
            isSigner: true,
            isWritable: false,
        },
        {
            pubkey: (0, utils_1.toPublicKey)(auctionCache),
            isSigner: false,
            isWritable: false,
        },
        {
            pubkey: (0, utils_1.toPublicKey)(store),
            isSigner: false,
            isWritable: false,
        },
        {
            pubkey: PROGRAM_IDS.system,
            isSigner: false,
            isWritable: false,
        },
        {
            pubkey: web3_js_1.SYSVAR_RENT_PUBKEY,
            isSigner: false,
            isWritable: false,
        },
    ];
    if (aboveCache) {
        keys.push({
            pubkey: (0, utils_1.toPublicKey)(aboveCache),
            isSigner: false,
            isWritable: false,
        });
    }
    if (belowCache) {
        keys.push({
            pubkey: (0, utils_1.toPublicKey)(belowCache),
            isSigner: false,
            isWritable: false,
        });
    }
    instructions.push(new web3_js_1.TransactionInstruction({
        keys,
        programId: (0, utils_1.toPublicKey)(PROGRAM_IDS.metaplex),
        data,
    }));
}
exports.I = setStoreIndex;
//# sourceMappingURL=setStoreIndex.js.map

/***/ }),

/***/ 8042:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

var __webpack_unused_export__;

__webpack_unused_export__ = ({ value: true });
exports.K = void 0;
const web3_js_1 = __webpack_require__(5681);
const borsh_1 = __webpack_require__(7384);
const _1 = __webpack_require__(4373);
const utils_1 = __webpack_require__(398);
async function setWhitelistedCreator(creator, activated, admin, payer, instructions) {
    const PROGRAM_IDS = (0, utils_1.programIds)();
    const store = PROGRAM_IDS.store;
    if (!store) {
        throw new Error('Store not initialized');
    }
    const whitelistedCreatorPDAKey = await (0, _1.getWhitelistedCreator)(creator);
    const value = new _1.SetWhitelistedCreatorArgs({ activated });
    const data = Buffer.from((0, borsh_1.serialize)(_1.SCHEMA, value));
    const keys = [
        {
            pubkey: (0, utils_1.toPublicKey)(whitelistedCreatorPDAKey),
            isSigner: false,
            isWritable: true,
        },
        {
            pubkey: (0, utils_1.toPublicKey)(admin),
            isSigner: true,
            isWritable: false,
        },
        {
            pubkey: (0, utils_1.toPublicKey)(payer),
            isSigner: true,
            isWritable: false,
        },
        {
            pubkey: (0, utils_1.toPublicKey)(creator),
            isSigner: false,
            isWritable: false,
        },
        {
            pubkey: store,
            isSigner: false,
            isWritable: false,
        },
        {
            pubkey: PROGRAM_IDS.system,
            isSigner: false,
            isWritable: false,
        },
        {
            pubkey: web3_js_1.SYSVAR_RENT_PUBKEY,
            isSigner: false,
            isWritable: false,
        },
    ];
    instructions.push(new web3_js_1.TransactionInstruction({
        keys,
        programId: (0, utils_1.toPublicKey)(PROGRAM_IDS.metaplex),
        data,
    }));
}
exports.K = setWhitelistedCreator;
//# sourceMappingURL=setWhitelistedCreator.js.map

/***/ }),

/***/ 7020:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.startAuction = void 0;
const web3_js_1 = __webpack_require__(5681);
const borsh_1 = __webpack_require__(7384);
const _1 = __webpack_require__(4373);
const utils_1 = __webpack_require__(398);
async function startAuction(vault, auctionManagerAuthority, instructions) {
    const PROGRAM_IDS = (0, utils_1.programIds)();
    const store = PROGRAM_IDS.store;
    if (!store) {
        throw new Error('Store not initialized');
    }
    const { auctionKey, auctionManagerKey } = await (0, _1.getAuctionKeys)(vault);
    const value = new _1.StartAuctionArgs();
    const data = Buffer.from((0, borsh_1.serialize)(_1.SCHEMA, value));
    const keys = [
        {
            pubkey: (0, utils_1.toPublicKey)(auctionManagerKey),
            isSigner: false,
            isWritable: true,
        },
        {
            pubkey: (0, utils_1.toPublicKey)(auctionKey),
            isSigner: false,
            isWritable: true,
        },
        {
            pubkey: (0, utils_1.toPublicKey)(auctionManagerAuthority),
            isSigner: true,
            isWritable: false,
        },
        {
            pubkey: store,
            isSigner: false,
            isWritable: false,
        },
        {
            pubkey: (0, utils_1.toPublicKey)(PROGRAM_IDS.auction),
            isSigner: false,
            isWritable: false,
        },
        {
            pubkey: web3_js_1.SYSVAR_CLOCK_PUBKEY,
            isSigner: false,
            isWritable: false,
        },
    ];
    instructions.push(new web3_js_1.TransactionInstruction({
        keys,
        programId: (0, utils_1.toPublicKey)(PROGRAM_IDS.metaplex),
        data,
    }));
}
exports.startAuction = startAuction;
//# sourceMappingURL=startAuction.js.map

/***/ }),

/***/ 3751:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

var __webpack_unused_export__;

__webpack_unused_export__ = ({ value: true });
exports.e = void 0;
const web3_js_1 = __webpack_require__(5681);
const borsh_1 = __webpack_require__(7384);
const _1 = __webpack_require__(4373);
const utils_1 = __webpack_require__(398);
async function validateSafetyDepositBoxV2(vault, metadata, safetyDepositBox, safetyDepositTokenStore, tokenMint, auctionManagerAuthority, metadataAuthority, payer, instructions, edition, whitelistedCreator, store, safetyDepositConfig) {
    const PROGRAM_IDS = (0, utils_1.programIds)();
    const { auctionKey, auctionManagerKey } = await (0, _1.getAuctionKeys)(vault);
    const originalAuthorityLookup = await (0, _1.getOriginalAuthority)(auctionKey, metadata);
    const safetyDepositConfigKey = await (0, _1.getSafetyDepositConfig)(auctionManagerKey, safetyDepositBox);
    const tokenTracker = await (0, _1.getAuctionWinnerTokenTypeTracker)(auctionManagerKey);
    const value = new _1.ValidateSafetyDepositBoxV2Args(safetyDepositConfig);
    const data = Buffer.from((0, borsh_1.serialize)(_1.SCHEMA, value));
    const keys = [
        {
            pubkey: (0, utils_1.toPublicKey)(safetyDepositConfigKey),
            isSigner: false,
            isWritable: true,
        },
        {
            pubkey: (0, utils_1.toPublicKey)(tokenTracker),
            isSigner: false,
            isWritable: true,
        },
        {
            pubkey: (0, utils_1.toPublicKey)(auctionManagerKey),
            isSigner: false,
            isWritable: true,
        },
        {
            pubkey: (0, utils_1.toPublicKey)(metadata),
            isSigner: false,
            isWritable: true,
        },
        {
            pubkey: (0, utils_1.toPublicKey)(originalAuthorityLookup),
            isSigner: false,
            isWritable: true,
        },
        {
            pubkey: (0, utils_1.toPublicKey)(whitelistedCreator || web3_js_1.SystemProgram.programId),
            isSigner: false,
            isWritable: false,
        },
        {
            pubkey: (0, utils_1.toPublicKey)(store),
            isSigner: false,
            isWritable: false,
        },
        {
            pubkey: (0, utils_1.toPublicKey)(safetyDepositBox),
            isSigner: false,
            isWritable: false,
        },
        {
            pubkey: (0, utils_1.toPublicKey)(safetyDepositTokenStore),
            isSigner: false,
            isWritable: false,
        },
        {
            pubkey: (0, utils_1.toPublicKey)(tokenMint),
            isSigner: false,
            isWritable: false,
        },
        {
            pubkey: (0, utils_1.toPublicKey)(edition),
            isSigner: false,
            isWritable: false,
        },
        {
            pubkey: (0, utils_1.toPublicKey)(vault),
            isSigner: false,
            isWritable: false,
        },
        {
            pubkey: (0, utils_1.toPublicKey)(auctionManagerAuthority),
            isSigner: true,
            isWritable: false,
        },
        {
            pubkey: (0, utils_1.toPublicKey)(metadataAuthority),
            isSigner: true,
            isWritable: false,
        },
        {
            pubkey: (0, utils_1.toPublicKey)(payer),
            isSigner: true,
            isWritable: false,
        },
        {
            pubkey: (0, utils_1.toPublicKey)(PROGRAM_IDS.metadata),
            isSigner: false,
            isWritable: false,
        },
        {
            pubkey: web3_js_1.SystemProgram.programId,
            isSigner: false,
            isWritable: false,
        },
        {
            pubkey: web3_js_1.SYSVAR_RENT_PUBKEY,
            isSigner: false,
            isWritable: false,
        },
    ];
    instructions.push(new web3_js_1.TransactionInstruction({
        keys,
        programId: (0, utils_1.toPublicKey)(PROGRAM_IDS.metaplex),
        data,
    }));
}
exports.e = validateSafetyDepositBoxV2;
//# sourceMappingURL=validateSafetyDepositBoxV2.js.map

/***/ }),

/***/ 2921:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.withdrawMasterEdition = void 0;
const web3_js_1 = __webpack_require__(5681);
const borsh_1 = __webpack_require__(7384);
const _1 = __webpack_require__(4373);
const actions_1 = __webpack_require__(6618);
const utils_1 = __webpack_require__(398);
async function withdrawMasterEdition(vault, safetyDepositTokenStore, destination, safetyDeposit, fractionMint, mint, instructions) {
    const PROGRAM_IDS = (0, utils_1.programIds)();
    const store = PROGRAM_IDS.store;
    if (!store) {
        throw new Error('Store not initialized');
    }
    const { auctionKey, auctionManagerKey } = await (0, _1.getAuctionKeys)(vault);
    const prizeTrackingTicket = await (0, _1.getPrizeTrackingTicket)(auctionManagerKey, mint);
    const vaultAuthority = (await (0, utils_1.findProgramAddress)([
        Buffer.from(actions_1.VAULT_PREFIX),
        (0, utils_1.toPublicKey)(PROGRAM_IDS.vault).toBuffer(),
        (0, utils_1.toPublicKey)(vault).toBuffer(),
    ], (0, utils_1.toPublicKey)(PROGRAM_IDS.vault)))[0];
    const auctionExtended = (await (0, utils_1.findProgramAddress)([
        Buffer.from(actions_1.AUCTION_PREFIX),
        (0, utils_1.toPublicKey)(PROGRAM_IDS.auction).toBuffer(),
        (0, utils_1.toPublicKey)(vault).toBuffer(),
        Buffer.from(actions_1.EXTENDED),
    ], (0, utils_1.toPublicKey)(PROGRAM_IDS.auction)))[0];
    const safetyDepositConfig = await (0, _1.getSafetyDepositConfig)(auctionManagerKey, safetyDeposit);
    const value = new _1.WithdrawMasterEditionArgs();
    const data = Buffer.from((0, borsh_1.serialize)(_1.SCHEMA, value));
    const keys = [
        {
            pubkey: (0, utils_1.toPublicKey)(auctionManagerKey),
            isSigner: false,
            isWritable: true,
        },
        {
            pubkey: (0, utils_1.toPublicKey)(safetyDepositTokenStore),
            isSigner: false,
            isWritable: true,
        },
        {
            pubkey: (0, utils_1.toPublicKey)(destination),
            isSigner: false,
            isWritable: true,
        },
        {
            pubkey: (0, utils_1.toPublicKey)(safetyDeposit),
            isSigner: false,
            isWritable: true,
        },
        {
            pubkey: (0, utils_1.toPublicKey)(vault),
            isSigner: false,
            isWritable: true,
        },
        {
            pubkey: (0, utils_1.toPublicKey)(fractionMint),
            isSigner: false,
            isWritable: true,
        },
        {
            pubkey: (0, utils_1.toPublicKey)(prizeTrackingTicket),
            isSigner: false,
            isWritable: false,
        },
        {
            pubkey: (0, utils_1.toPublicKey)(vaultAuthority),
            isSigner: false,
            isWritable: false,
        },
        {
            pubkey: (0, utils_1.toPublicKey)(auctionKey),
            isSigner: false,
            isWritable: false,
        },
        {
            pubkey: (0, utils_1.toPublicKey)(auctionExtended),
            isSigner: false,
            isWritable: false,
        },
        {
            pubkey: PROGRAM_IDS.token,
            isSigner: false,
            isWritable: false,
        },
        {
            pubkey: (0, utils_1.toPublicKey)(PROGRAM_IDS.vault),
            isSigner: false,
            isWritable: false,
        },
        {
            pubkey: (0, utils_1.toPublicKey)(store),
            isSigner: false,
            isWritable: false,
        },
        {
            pubkey: web3_js_1.SYSVAR_RENT_PUBKEY,
            isSigner: false,
            isWritable: false,
        },
        {
            pubkey: (0, utils_1.toPublicKey)(safetyDepositConfig),
            isSigner: false,
            isWritable: false,
        },
    ];
    instructions.push(new web3_js_1.TransactionInstruction({
        keys,
        programId: (0, utils_1.toPublicKey)(PROGRAM_IDS.metaplex),
        data,
    }));
}
exports.withdrawMasterEdition = withdrawMasterEdition;
//# sourceMappingURL=withdrawMasterEdition.js.map

/***/ }),

/***/ 7290:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.getCardsByPackSet = exports.decodePackCard = exports.PACK_CARD_SCHEMA = exports.PackCard = void 0;
const borsh_1 = __webpack_require__(7384);
const __1 = __webpack_require__(1152);
const __2 = __webpack_require__(9819);
const web3_1 = __webpack_require__(8460);
class PackCard {
    constructor(args) {
        this.key = __1.PackKey.PackCard;
        this.key = __1.PackKey.PackSet;
        this.packSet = args.packSet;
        this.master = args.master;
        this.metadata = args.metadata;
        this.tokenAccount = args.tokenAccount;
        this.maxSupply = args.maxSupply;
        this.weight = args.weight;
    }
}
exports.PackCard = PackCard;
exports.PACK_CARD_SCHEMA = new Map([
    [
        PackCard,
        {
            kind: 'struct',
            fields: [
                ['key', 'u8'],
                ['packSet', 'pubkeyAsString'],
                ['master', 'pubkeyAsString'],
                ['metadata', 'pubkeyAsString'],
                ['tokenAccount', 'pubkeyAsString'],
                ['maxSupply', 'u32'],
                ['weight', 'u16'],
            ],
        },
    ],
]);
const decodePackCard = (buffer) => {
    return (0, borsh_1.deserializeUnchecked)(exports.PACK_CARD_SCHEMA, PackCard, buffer);
};
exports.decodePackCard = decodePackCard;
const getCardsByPackSet = ({ connection, packSetKey, }) => (0, web3_1.getProgramAccounts)(connection, __2.PACK_CREATE_ID.toString(), {
    filters: [
        {
            dataSize: __1.MAX_PACK_CARD_SIZE,
        },
        {
            memcmp: {
                offset: 1,
                bytes: packSetKey,
            },
        },
    ],
});
exports.getCardsByPackSet = getCardsByPackSet;
//# sourceMappingURL=PackCard.js.map

/***/ }),

/***/ 6160:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.getPackSetByPubkey = exports.getPackSets = exports.decodePackSet = exports.PACK_SET_SCHEMA = exports.PackSet = void 0;
const web3_js_1 = __webpack_require__(5681);
const borsh_1 = __webpack_require__(7384);
const __1 = __webpack_require__(1152);
const __2 = __webpack_require__(9819);
const web3_1 = __webpack_require__(8460);
class PackSet {
    constructor(args) {
        this.key = __1.PackKey.PackSet;
        this.key = __1.PackKey.PackSet;
        this.store = args.store;
        this.authority = args.authority;
        this.description = args.description.replace(/\0/g, '');
        this.uri = args.uri.replace(/\0/g, '');
        this.name = new TextDecoder().decode(args.name).replace(/\0/g, '');
        this.packCards = args.packCards;
        this.packVouchers = args.packVouchers;
        this.totalWeight = args.totalWeight;
        this.totalEditions = args.totalEditions;
        this.mutable = !!args.mutable;
        this.packState = args.packState;
        this.allowedAmountToRedeem = args.allowedAmountToRedeem;
        this.distributionType = args.distributionType;
        this.redeemStartDate = args.redeemStartDate;
        this.redeemEndDate = args.redeemEndDate;
        this.randomOracle = args.randomOracle;
    }
}
exports.PackSet = PackSet;
exports.PACK_SET_SCHEMA = new Map([
    [
        PackSet,
        {
            kind: 'struct',
            fields: [
                ['accountType', 'u8'],
                ['store', 'pubkeyAsString'],
                ['authority', 'pubkeyAsString'],
                ['description', 'string'],
                ['uri', 'string'],
                ['name', [32]],
                ['packCards', 'u32'],
                ['packVouchers', 'u32'],
                ['totalWeight', 'u64'],
                ['totalEditions', 'u64'],
                ['mutable', 'u8'],
                ['packState', 'u8'],
                ['distributionType', 'u8'],
                ['allowedAmountToRedeem', 'u32'],
                ['redeemStartDate', 'u64'],
                ['redeemEndDate', { kind: 'option', type: 'u64' }],
                ['randomOracle', 'pubkeyAsString'],
            ],
        },
    ],
]);
const decodePackSet = (buffer) => {
    return (0, borsh_1.deserializeUnchecked)(exports.PACK_SET_SCHEMA, PackSet, buffer);
};
exports.decodePackSet = decodePackSet;
const getPackSets = ({ connection, storeId, }) => {
    if (!storeId) {
        return Promise.resolve([]);
    }
    return (0, web3_1.getProgramAccounts)(connection, __2.PACK_CREATE_ID.toString(), {
        filters: [
            {
                dataSize: __1.MAX_PACK_SET_SIZE,
            },
            {
                memcmp: {
                    offset: 1,
                    bytes: storeId.toBase58(),
                },
            },
        ],
    });
};
exports.getPackSets = getPackSets;
const getPackSetByPubkey = async (connection, pubkey) => {
    const info = await connection.getAccountInfo(new web3_js_1.PublicKey(pubkey));
    if (!info) {
        throw new Error(`Unable to find account: ${pubkey}`);
    }
    return {
        pubkey,
        account: info,
    };
};
exports.getPackSetByPubkey = getPackSetByPubkey;
//# sourceMappingURL=PackSet.js.map

/***/ }),

/***/ 6575:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.getVouchersByPackSet = exports.decodePackVoucher = exports.PACK_VOUCHER_SCHEMA = exports.PackVoucher = void 0;
const borsh_1 = __webpack_require__(7384);
const __1 = __webpack_require__(1152);
const __2 = __webpack_require__(9819);
const web3_1 = __webpack_require__(8460);
class PackVoucher {
    constructor(args) {
        this.key = __1.PackKey.PackVoucher;
        this.key = __1.PackKey.PackSet;
        this.packSet = args.packSet;
        this.master = args.master;
        this.metadata = args.metadata;
    }
}
exports.PackVoucher = PackVoucher;
exports.PACK_VOUCHER_SCHEMA = new Map([
    [
        PackVoucher,
        {
            kind: 'struct',
            fields: [
                ['key', 'u8'],
                ['packSet', 'pubkeyAsString'],
                ['master', 'pubkeyAsString'],
                ['metadata', 'pubkeyAsString'],
            ],
        },
    ],
]);
const decodePackVoucher = (buffer) => {
    return (0, borsh_1.deserializeUnchecked)(exports.PACK_VOUCHER_SCHEMA, PackVoucher, buffer);
};
exports.decodePackVoucher = decodePackVoucher;
const getVouchersByPackSet = ({ connection, packSetKey, }) => (0, web3_1.getProgramAccounts)(connection, __2.PACK_CREATE_ID.toString(), {
    filters: [
        {
            dataSize: __1.MAX_PACK_VOUCHER_SIZE,
        },
        {
            memcmp: {
                offset: 1,
                bytes: (0, __2.toPublicKey)(packSetKey).toBase58(),
            },
        },
    ],
});
exports.getVouchersByPackSet = getVouchersByPackSet;
//# sourceMappingURL=PackVoucher.js.map

/***/ }),

/***/ 9437:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.getProvingProcessByPubkey = exports.getProvingProcessByPackSetAndWallet = exports.decodePackProvingProcess = exports.PACK_PROVING_PROCESS_SCHEMA = exports.ProvingProcess = void 0;
const web3_js_1 = __webpack_require__(5681);
const borsh_1 = __webpack_require__(7384);
const __1 = __webpack_require__(1152);
const __2 = __webpack_require__(9819);
const web3_1 = __webpack_require__(8460);
class ProvingProcess {
    constructor(args) {
        this.key = __1.PackKey.ProvingProcess;
        this.key = __1.PackKey.PackSet;
        this.walletKey = args.walletKey;
        this.isExhausted = Boolean(args.isExhausted);
        this.voucherMint = args.voucherMint;
        this.packSet = args.packSet;
        this.cardsToRedeem = args.cardsToRedeem;
        this.cardsRedeemed = args.cardsRedeemed;
    }
}
exports.ProvingProcess = ProvingProcess;
exports.PACK_PROVING_PROCESS_SCHEMA = new Map([
    [
        ProvingProcess,
        {
            kind: 'struct',
            fields: [
                ['key', 'u8'],
                ['walletKey', 'pubkeyAsString'],
                ['isExhausted', 'u8'],
                ['voucherMint', 'pubkeyAsString'],
                ['packSet', 'pubkeyAsString'],
                ['cardsRedeemed', 'u32'],
                ['cardsToRedeem', 'map32'], //BTreeMap<u32, u32>
            ],
        },
    ],
]);
const decodePackProvingProcess = (buffer) => {
    return (0, borsh_1.deserializeUnchecked)(exports.PACK_PROVING_PROCESS_SCHEMA, ProvingProcess, buffer);
};
exports.decodePackProvingProcess = decodePackProvingProcess;
const getProvingProcessByPackSetAndWallet = ({ connection, packSetKey, walletKey, }) => (0, web3_1.getProgramAccounts)(connection, __2.PACK_CREATE_ID.toString(), {
    commitment: 'processed',
    filters: [
        {
            dataSize: __1.MAX_PACK_PROVING_PROCESS_SIZE,
        },
        {
            memcmp: {
                offset: 1,
                bytes: (0, __2.toPublicKey)(walletKey).toBase58(),
            },
        },
        {
            memcmp: {
                offset: 1 + 32 + 1 + 32,
                bytes: (0, __2.toPublicKey)(packSetKey).toBase58(),
            },
        },
    ],
});
exports.getProvingProcessByPackSetAndWallet = getProvingProcessByPackSetAndWallet;
const getProvingProcessByPubkey = async (connection, pubkey) => {
    const info = await connection.getAccountInfo(new web3_js_1.PublicKey(pubkey), 'processed');
    if (!info) {
        throw new Error(`Unable to find account: ${pubkey}`);
    }
    return {
        pubkey,
        account: info,
        info: (0, exports.decodePackProvingProcess)(Buffer.from(info === null || info === void 0 ? void 0 : info.data)),
    };
};
exports.getProvingProcessByPubkey = getProvingProcessByPubkey;
//# sourceMappingURL=ProvingProcess.js.map

/***/ }),

/***/ 2245:
/***/ ((__unused_webpack_module, exports) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.MAX_PACK_PROVING_PROCESS_SIZE = exports.MAX_PACK_VOUCHER_SIZE = exports.MAX_PACK_CARD_SIZE = exports.MAX_PACK_SET_SIZE = void 0;
exports.MAX_PACK_SET_SIZE = 885;
exports.MAX_PACK_CARD_SIZE = 145;
exports.MAX_PACK_VOUCHER_SIZE = 1 + 32 + 32 + 32;
exports.MAX_PACK_PROVING_PROCESS_SIZE = 1 + 32 + 1 + 32 + 32 + 4 + 800;
//# sourceMappingURL=constants.js.map

/***/ }),

/***/ 934:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.findPackVoucherProgramAddress = exports.findPackCardProgramAddress = exports.findPackConfigProgramAddress = exports.findProvingProcessProgramAddress = exports.getProgramAuthority = exports.CONFIG_PREFIX = exports.PROVING_PROCESS_PREFIX = exports.VOUCHER_PREFIX = exports.CARD_PREFIX = exports.PACKS_PREFIX = void 0;
const web3_js_1 = __webpack_require__(5681);
const __1 = __webpack_require__(9819);
exports.PACKS_PREFIX = 'packs';
exports.CARD_PREFIX = 'card';
exports.VOUCHER_PREFIX = 'voucher';
exports.PROVING_PROCESS_PREFIX = 'proving';
exports.CONFIG_PREFIX = 'config';
async function getProgramAuthority() {
    const PROGRAM_IDS = (0, __1.programIds)();
    return (await (0, __1.findProgramAddress)([
        Buffer.from(exports.PACKS_PREFIX),
        (0, __1.toPublicKey)(PROGRAM_IDS.pack_create).toBuffer(),
    ], (0, __1.toPublicKey)(PROGRAM_IDS.pack_create)))[0];
}
exports.getProgramAuthority = getProgramAuthority;
async function findProvingProcessProgramAddress(packSetKey, userWallet, voucherMint) {
    const PROGRAM_IDS = (0, __1.programIds)();
    return (await (0, __1.findProgramAddress)([
        Buffer.from(exports.PROVING_PROCESS_PREFIX),
        packSetKey.toBuffer(),
        userWallet.toBuffer(),
        voucherMint.toBuffer(),
    ], (0, __1.toPublicKey)(PROGRAM_IDS.pack_create)))[0];
}
exports.findProvingProcessProgramAddress = findProvingProcessProgramAddress;
async function findPackConfigProgramAddress(packSetKey) {
    const PROGRAM_IDS = (0, __1.programIds)();
    return (await (0, __1.findProgramAddress)([Buffer.from(exports.CONFIG_PREFIX), packSetKey.toBuffer()], (0, __1.toPublicKey)(PROGRAM_IDS.pack_create)))[0];
}
exports.findPackConfigProgramAddress = findPackConfigProgramAddress;
async function findPackCardProgramAddress(pack, index) {
    return findProgramAddressByPrefix(pack, index, exports.CARD_PREFIX);
}
exports.findPackCardProgramAddress = findPackCardProgramAddress;
async function findPackVoucherProgramAddress(pack, index) {
    return findProgramAddressByPrefix(pack, index, exports.VOUCHER_PREFIX);
}
exports.findPackVoucherProgramAddress = findPackVoucherProgramAddress;
async function findProgramAddressByPrefix(packSetKey, index, prefix) {
    const PROGRAM_IDS = (0, __1.programIds)();
    const numberBuffer = Buffer.allocUnsafe(4);
    numberBuffer.writeUInt16LE(index);
    return (await (0, __1.findProgramAddress)([Buffer.from(prefix), new web3_js_1.PublicKey(packSetKey).toBuffer(), numberBuffer], (0, __1.toPublicKey)(PROGRAM_IDS.pack_create)))[0];
}
//# sourceMappingURL=find.js.map

/***/ }),

/***/ 1152:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
__exportStar(__webpack_require__(2245), exports);
__exportStar(__webpack_require__(8160), exports);
__exportStar(__webpack_require__(7840), exports);
__exportStar(__webpack_require__(8050), exports);
__exportStar(__webpack_require__(934), exports);
//# sourceMappingURL=index.js.map

/***/ }),

/***/ 1048:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.activate = void 0;
const web3_js_1 = __webpack_require__(5681);
const borsh_1 = __webpack_require__(7384);
const utils_1 = __webpack_require__(398);
const packs_1 = __webpack_require__(1559);
async function activate({ packSetKey, authority, }) {
    const PROGRAM_IDS = (0, utils_1.programIds)();
    const value = new packs_1.ActivatePackArgs();
    const data = Buffer.from((0, borsh_1.serialize)(packs_1.PACKS_SCHEMA, value));
    const keys = [
        // pack_set
        {
            pubkey: (0, utils_1.toPublicKey)(packSetKey),
            isSigner: false,
            isWritable: true,
        },
        // signer authority
        {
            pubkey: (0, utils_1.toPublicKey)(authority),
            isSigner: true,
            isWritable: false,
        },
    ];
    return new web3_js_1.TransactionInstruction({
        keys,
        programId: (0, utils_1.toPublicKey)(PROGRAM_IDS.pack_create),
        data,
    });
}
exports.activate = activate;
//# sourceMappingURL=activate.js.map

/***/ }),

/***/ 4912:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.addCardToPack = void 0;
const web3_js_1 = __webpack_require__(5681);
const borsh_1 = __webpack_require__(7384);
const __1 = __webpack_require__(9819);
const utils_1 = __webpack_require__(398);
const packs_1 = __webpack_require__(1559);
const find_1 = __webpack_require__(934);
async function addCardToPack({ maxSupply, weight, index, packSetKey, authority, mint, tokenAccount, toAccount, }) {
    const PROGRAM_IDS = (0, utils_1.programIds)();
    const value = new packs_1.AddCardToPackArgs({
        maxSupply,
        weight,
        index,
    });
    const store = PROGRAM_IDS.store;
    if (!store) {
        throw new Error('Store not initialized');
    }
    const masterMetadataKey = await (0, __1.getMetadata)(mint);
    const masterEdition = await (0, __1.getEdition)(mint);
    const programAuthority = await (0, find_1.getProgramAuthority)();
    const packCard = await (0, find_1.findPackCardProgramAddress)(packSetKey, index);
    const packConfig = await (0, find_1.findPackConfigProgramAddress)(packSetKey);
    const { pubkey: sourceKey } = tokenAccount;
    const data = Buffer.from((0, borsh_1.serialize)(packs_1.PACKS_SCHEMA, value));
    const keys = [
        // pack_set
        {
            pubkey: (0, utils_1.toPublicKey)(packSetKey),
            isSigner: false,
            isWritable: true,
        },
        // pack_config
        {
            pubkey: (0, utils_1.toPublicKey)(packConfig),
            isSigner: false,
            isWritable: true,
        },
        // pack_card
        {
            pubkey: (0, utils_1.toPublicKey)(packCard),
            isSigner: false,
            isWritable: true,
        },
        // signer authority
        {
            pubkey: (0, utils_1.toPublicKey)(authority),
            isSigner: true,
            isWritable: false,
        },
        // master_edition
        {
            pubkey: (0, utils_1.toPublicKey)(masterEdition),
            isSigner: false,
            isWritable: false,
        },
        // master_metadata
        {
            pubkey: (0, utils_1.toPublicKey)(masterMetadataKey),
            isSigner: false,
            isWritable: false,
        },
        // mint
        {
            pubkey: (0, utils_1.toPublicKey)(mint),
            isSigner: false,
            isWritable: false,
        },
        // source
        {
            pubkey: (0, utils_1.toPublicKey)(sourceKey),
            isSigner: false,
            isWritable: true,
        },
        // token_account
        {
            pubkey: (0, utils_1.toPublicKey)(toAccount.publicKey),
            isSigner: false,
            isWritable: true,
        },
        // program_authority
        {
            pubkey: (0, utils_1.toPublicKey)(programAuthority),
            isSigner: false,
            isWritable: false,
        },
        // store
        {
            pubkey: (0, utils_1.toPublicKey)(store),
            isSigner: false,
            isWritable: false,
        },
        // rent
        {
            pubkey: (0, utils_1.toPublicKey)(web3_js_1.SYSVAR_RENT_PUBKEY),
            isSigner: false,
            isWritable: false,
        },
        // system_program
        {
            pubkey: web3_js_1.SystemProgram.programId,
            isSigner: false,
            isWritable: false,
        },
        // spl_token program
        {
            pubkey: (0, utils_1.programIds)().token,
            isSigner: false,
            isWritable: false,
        },
    ];
    return new web3_js_1.TransactionInstruction({
        keys,
        programId: (0, utils_1.toPublicKey)(PROGRAM_IDS.pack_create),
        data,
    });
}
exports.addCardToPack = addCardToPack;
//# sourceMappingURL=addCardToPack.js.map

/***/ }),

/***/ 8996:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.addVoucherToPack = void 0;
const web3_js_1 = __webpack_require__(5681);
const borsh_1 = __webpack_require__(7384);
const __1 = __webpack_require__(9819);
const utils_1 = __webpack_require__(398);
const find_1 = __webpack_require__(934);
async function addVoucherToPack({ index, packSetKey, authority, mint, tokenAccount, }) {
    const PROGRAM_IDS = (0, utils_1.programIds)();
    const value = new __1.AddVoucherToPackArgs();
    const masterMetadataKey = await (0, __1.getMetadata)(mint);
    const masterEdition = await (0, __1.getEdition)(mint);
    const packVoucher = await (0, find_1.findPackVoucherProgramAddress)(packSetKey, index);
    const { pubkey: sourceKey } = tokenAccount;
    const store = PROGRAM_IDS.store;
    if (!store) {
        throw new Error('Store not initialized');
    }
    const data = Buffer.from((0, borsh_1.serialize)(__1.PACKS_SCHEMA, value));
    const keys = [
        // pack_set
        {
            pubkey: (0, utils_1.toPublicKey)(packSetKey),
            isSigner: false,
            isWritable: true,
        },
        // pack_voucher
        {
            pubkey: (0, utils_1.toPublicKey)(packVoucher),
            isSigner: false,
            isWritable: true,
        },
        // signer authority
        {
            pubkey: (0, utils_1.toPublicKey)(authority),
            isSigner: true,
            isWritable: true,
        },
        // voucher_owner
        {
            pubkey: (0, utils_1.toPublicKey)(authority),
            isSigner: true,
            isWritable: false,
        },
        // master_edition
        {
            pubkey: (0, utils_1.toPublicKey)(masterEdition),
            isSigner: false,
            isWritable: false,
        },
        // master_metadata
        {
            pubkey: (0, utils_1.toPublicKey)(masterMetadataKey),
            isSigner: false,
            isWritable: false,
        },
        // mint
        {
            pubkey: (0, utils_1.toPublicKey)(mint),
            isSigner: false,
            isWritable: false,
        },
        // source
        {
            pubkey: (0, utils_1.toPublicKey)(sourceKey),
            isSigner: false,
            isWritable: true,
        },
        // store
        {
            pubkey: (0, utils_1.toPublicKey)(store),
            isSigner: false,
            isWritable: false,
        },
        // rent
        {
            pubkey: (0, utils_1.toPublicKey)(web3_js_1.SYSVAR_RENT_PUBKEY),
            isSigner: false,
            isWritable: false,
        },
        // system_program
        {
            pubkey: web3_js_1.SystemProgram.programId,
            isSigner: false,
            isWritable: false,
        },
        // spl_token program
        {
            pubkey: (0, utils_1.programIds)().token,
            isSigner: false,
            isWritable: false,
        },
    ];
    return new web3_js_1.TransactionInstruction({
        keys,
        programId: (0, utils_1.toPublicKey)(PROGRAM_IDS.pack_create),
        data,
    });
}
exports.addVoucherToPack = addVoucherToPack;
//# sourceMappingURL=addVoucherToPack.js.map

/***/ }),

/***/ 8703:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.claimPack = void 0;
const web3_js_1 = __webpack_require__(5681);
const borsh_1 = __webpack_require__(7384);
const utils_1 = __webpack_require__(398);
const __1 = __webpack_require__(9819);
const find_1 = __webpack_require__(934);
async function claimPack({ index, packSetKey, wallet, voucherMint, userToken, newMint, metadataMint, edition, randomOracle, }) {
    const PROGRAM_IDS = (0, utils_1.programIds)();
    const value = new __1.ClaimPackArgs({ index });
    const provingProcess = await (0, find_1.findProvingProcessProgramAddress)((0, utils_1.toPublicKey)(packSetKey), wallet, (0, utils_1.toPublicKey)(voucherMint));
    const packCard = await (0, find_1.findPackCardProgramAddress)((0, utils_1.toPublicKey)(packSetKey), index);
    const newMetadata = await (0, __1.getMetadata)(newMint);
    const metadata = await (0, __1.getMetadata)(metadataMint);
    const newEdition = await (0, __1.getEdition)(newMint);
    const masterEdition = await (0, __1.getEdition)(metadataMint);
    const editionMarkPda = await (0, __1.getEditionMarkPda)(metadataMint, edition);
    const programAuthority = await (0, find_1.getProgramAuthority)();
    const data = Buffer.from((0, borsh_1.serialize)(__1.PACKS_SCHEMA, value));
    const keys = [
        // pack_set
        {
            pubkey: (0, utils_1.toPublicKey)(packSetKey),
            isSigner: false,
            isWritable: false,
        },
        // proving_process
        {
            pubkey: (0, utils_1.toPublicKey)(provingProcess),
            isSigner: false,
            isWritable: true,
        },
        // user_wallet
        {
            pubkey: wallet,
            isSigner: true,
            isWritable: true,
        },
        // program_authority
        {
            pubkey: (0, utils_1.toPublicKey)(programAuthority),
            isSigner: false,
            isWritable: false,
        },
        // pack_card
        {
            pubkey: (0, utils_1.toPublicKey)(packCard),
            isSigner: false,
            isWritable: true,
        },
        // user_token_acc
        {
            pubkey: (0, utils_1.toPublicKey)(userToken),
            isSigner: false,
            isWritable: true,
        },
        // new_metadata_acc
        {
            pubkey: (0, utils_1.toPublicKey)(newMetadata),
            isSigner: false,
            isWritable: true,
        },
        // new_edition_acc
        {
            pubkey: (0, utils_1.toPublicKey)(newEdition),
            isSigner: false,
            isWritable: true,
        },
        // master_edition_acc
        {
            pubkey: (0, utils_1.toPublicKey)(masterEdition),
            isSigner: false,
            isWritable: true,
        },
        // new_mint_account
        {
            pubkey: (0, utils_1.toPublicKey)(newMint),
            isSigner: false,
            isWritable: true,
        },
        // new_mint_authority_acc
        {
            pubkey: wallet,
            isSigner: true,
            isWritable: true,
        },
        // metadata_acc
        {
            pubkey: (0, utils_1.toPublicKey)(metadata),
            isSigner: false,
            isWritable: true,
        },
        // metadata_mint_acc
        {
            pubkey: (0, utils_1.toPublicKey)(metadataMint),
            isSigner: false,
            isWritable: true,
        },
        // edition_mark
        {
            pubkey: (0, utils_1.toPublicKey)(editionMarkPda),
            isSigner: false,
            isWritable: true,
        },
        // rent
        {
            pubkey: (0, utils_1.toPublicKey)(web3_js_1.SYSVAR_RENT_PUBKEY),
            isSigner: false,
            isWritable: false,
        },
        // randomness_oracle
        {
            pubkey: (0, utils_1.toPublicKey)(randomOracle),
            isSigner: false,
            isWritable: false,
        },
        // metaplex_token_metadata
        {
            pubkey: (0, utils_1.toPublicKey)((0, utils_1.programIds)().metadata),
            isSigner: false,
            isWritable: false,
        },
        // spl_token program
        {
            pubkey: (0, utils_1.programIds)().token,
            isSigner: false,
            isWritable: false,
        },
        // system_program
        {
            pubkey: web3_js_1.SystemProgram.programId,
            isSigner: false,
            isWritable: false,
        },
    ];
    return new web3_js_1.TransactionInstruction({
        keys,
        programId: (0, utils_1.toPublicKey)(PROGRAM_IDS.pack_create),
        data,
    });
}
exports.claimPack = claimPack;
//# sourceMappingURL=claimPack.js.map

/***/ }),

/***/ 402:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.cleanUp = void 0;
const web3_js_1 = __webpack_require__(5681);
const borsh_1 = __webpack_require__(7384);
const utils_1 = __webpack_require__(398);
const packs_1 = __webpack_require__(1559);
const find_1 = __webpack_require__(934);
async function cleanUp(packSetKey) {
    const PROGRAM_IDS = (0, utils_1.programIds)();
    const value = new packs_1.CleanUpArgs();
    const store = PROGRAM_IDS.store;
    if (!store) {
        throw new Error('Store not initialized');
    }
    const packConfig = await (0, find_1.findPackConfigProgramAddress)(packSetKey);
    const data = Buffer.from((0, borsh_1.serialize)(packs_1.PACKS_SCHEMA, value));
    const keys = [
        // pack_set
        {
            pubkey: (0, utils_1.toPublicKey)(packSetKey),
            isSigner: false,
            isWritable: true,
        },
        // pack_config
        {
            pubkey: (0, utils_1.toPublicKey)(packConfig),
            isSigner: false,
            isWritable: true,
        },
    ];
    return new web3_js_1.TransactionInstruction({
        keys,
        programId: (0, utils_1.toPublicKey)(PROGRAM_IDS.pack_create),
        data,
    });
}
exports.cleanUp = cleanUp;
//# sourceMappingURL=cleanUp.js.map

/***/ }),

/***/ 8160:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
__exportStar(__webpack_require__(1048), exports);
__exportStar(__webpack_require__(4912), exports);
__exportStar(__webpack_require__(8996), exports);
__exportStar(__webpack_require__(1289), exports);
__exportStar(__webpack_require__(8703), exports);
__exportStar(__webpack_require__(402), exports);
__exportStar(__webpack_require__(1289), exports);
__exportStar(__webpack_require__(1392), exports);
//# sourceMappingURL=index.js.map

/***/ }),

/***/ 1289:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.initPackSet = void 0;
const web3_js_1 = __webpack_require__(5681);
const borsh_1 = __webpack_require__(7384);
const metaplex_1 = __webpack_require__(4373);
const utils_1 = __webpack_require__(398);
const __1 = __webpack_require__(9819);
async function initPackSet({ name, description, uri, mutable, distributionType, allowedAmountToRedeem, redeemStartDate, redeemEndDate, packSetKey, authority, }) {
    const PROGRAM_IDS = (0, utils_1.programIds)();
    const value = new __1.InitPackSetArgs({
        name,
        description,
        uri,
        mutable,
        distributionType,
        allowedAmountToRedeem,
        redeemStartDate,
        redeemEndDate,
    });
    const store = PROGRAM_IDS.store;
    if (!store) {
        throw new Error('Store not initialized');
    }
    const whitelistedCreator = await (0, metaplex_1.getWhitelistedCreator)(authority);
    const data = Buffer.from((0, borsh_1.serialize)(__1.PACKS_SCHEMA, value));
    const keys = [
        {
            pubkey: (0, utils_1.toPublicKey)(packSetKey),
            isSigner: false,
            isWritable: true,
        },
        {
            pubkey: (0, utils_1.toPublicKey)(authority),
            isSigner: true,
            isWritable: false,
        },
        {
            pubkey: (0, utils_1.toPublicKey)(store),
            isSigner: false,
            isWritable: false,
        },
        {
            pubkey: PROGRAM_IDS.oracle,
            isSigner: false,
            isWritable: false,
        },
        {
            pubkey: (0, utils_1.toPublicKey)(web3_js_1.SYSVAR_RENT_PUBKEY),
            isSigner: false,
            isWritable: false,
        },
        {
            pubkey: (0, utils_1.toPublicKey)(web3_js_1.SYSVAR_CLOCK_PUBKEY),
            isSigner: false,
            isWritable: false,
        },
        {
            pubkey: (0, utils_1.toPublicKey)(whitelistedCreator),
            isSigner: false,
            isWritable: false,
        },
    ];
    return new web3_js_1.TransactionInstruction({
        keys,
        programId: (0, utils_1.toPublicKey)(PROGRAM_IDS.pack_create),
        data,
    });
}
exports.initPackSet = initPackSet;
//# sourceMappingURL=initPackSet.js.map

/***/ }),

/***/ 1392:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.requestCardToRedeem = void 0;
const web3_js_1 = __webpack_require__(5681);
const borsh_1 = __webpack_require__(7384);
const utils_1 = __webpack_require__(398);
const __1 = __webpack_require__(9819);
const find_1 = __webpack_require__(934);
async function requestCardToRedeem({ index, packSetKey, editionKey, editionMint, voucherKey, tokenAccount, wallet, randomOracle, }) {
    const PROGRAM_IDS = (0, utils_1.programIds)();
    const value = new __1.RequestCardToRedeemArgs({
        index,
    });
    const store = PROGRAM_IDS.store;
    if (!store) {
        throw new Error('Store not initialized');
    }
    const provingProcess = await (0, find_1.findProvingProcessProgramAddress)(packSetKey, wallet, (0, utils_1.toPublicKey)(editionMint));
    const packConfig = await (0, find_1.findPackConfigProgramAddress)(packSetKey);
    const data = Buffer.from((0, borsh_1.serialize)(__1.PACKS_SCHEMA, value));
    const keys = [
        // pack_set
        {
            pubkey: (0, utils_1.toPublicKey)(packSetKey),
            isSigner: false,
            isWritable: false,
        },
        // pack_config
        {
            pubkey: (0, utils_1.toPublicKey)(packConfig),
            isSigner: false,
            isWritable: true,
        },
        // store
        {
            pubkey: (0, utils_1.toPublicKey)(store),
            isSigner: false,
            isWritable: false,
        },
        // edition
        {
            pubkey: (0, utils_1.toPublicKey)(editionKey),
            isSigner: false,
            isWritable: false,
        },
        // edition_mint
        {
            pubkey: (0, utils_1.toPublicKey)(editionMint),
            isSigner: false,
            isWritable: true,
        },
        // pack_voucher
        {
            pubkey: (0, utils_1.toPublicKey)(voucherKey),
            isSigner: false,
            isWritable: false,
        },
        // proving_process
        {
            pubkey: (0, utils_1.toPublicKey)(provingProcess),
            isSigner: false,
            isWritable: true,
        },
        // user_wallet
        {
            pubkey: wallet,
            isSigner: true,
            isWritable: true,
        },
        // randomness_oracle
        {
            pubkey: (0, utils_1.toPublicKey)(randomOracle),
            isSigner: false,
            isWritable: false,
        },
        // clock
        {
            pubkey: (0, utils_1.toPublicKey)(web3_js_1.SYSVAR_CLOCK_PUBKEY),
            isSigner: false,
            isWritable: false,
        },
        // rent
        {
            pubkey: (0, utils_1.toPublicKey)(web3_js_1.SYSVAR_RENT_PUBKEY),
            isSigner: false,
            isWritable: false,
        },
        // spl_token program
        {
            pubkey: (0, utils_1.programIds)().token,
            isSigner: false,
            isWritable: false,
        },
        // system_program
        {
            pubkey: web3_js_1.SystemProgram.programId,
            isSigner: false,
            isWritable: false,
        },
    ];
    if (tokenAccount) {
        // user_token_account
        keys.push({
            pubkey: (0, utils_1.toPublicKey)(tokenAccount),
            isSigner: false,
            isWritable: true,
        });
    }
    return new web3_js_1.TransactionInstruction({
        keys,
        programId: (0, utils_1.toPublicKey)(PROGRAM_IDS.pack_create),
        data,
    });
}
exports.requestCardToRedeem = requestCardToRedeem;
//# sourceMappingURL=requestCardToRedeem.js.map

/***/ }),

/***/ 7840:
/***/ ((__unused_webpack_module, exports) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
//# sourceMappingURL=interface.js.map

/***/ }),

/***/ 8050:
/***/ ((__unused_webpack_module, exports) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.PackSetState = exports.PackKey = exports.PackDistributionType = void 0;
var PackDistributionType;
(function (PackDistributionType) {
    PackDistributionType[PackDistributionType["MaxSupply"] = 0] = "MaxSupply";
    PackDistributionType[PackDistributionType["Fixed"] = 1] = "Fixed";
    PackDistributionType[PackDistributionType["Unlimited"] = 2] = "Unlimited";
})(PackDistributionType = exports.PackDistributionType || (exports.PackDistributionType = {}));
var PackKey;
(function (PackKey) {
    PackKey[PackKey["Uninitialized"] = 0] = "Uninitialized";
    PackKey[PackKey["PackSet"] = 1] = "PackSet";
    PackKey[PackKey["PackCard"] = 2] = "PackCard";
    PackKey[PackKey["PackVoucher"] = 3] = "PackVoucher";
    PackKey[PackKey["ProvingProcess"] = 4] = "ProvingProcess";
})(PackKey = exports.PackKey || (exports.PackKey = {}));
var PackSetState;
(function (PackSetState) {
    PackSetState[PackSetState["NotActivated"] = 0] = "NotActivated";
    PackSetState[PackSetState["Activated"] = 1] = "Activated";
    PackSetState[PackSetState["Deactivated"] = 2] = "Deactivated";
    PackSetState[PackSetState["Ended"] = 3] = "Ended";
})(PackSetState = exports.PackSetState || (exports.PackSetState = {}));
//# sourceMappingURL=types.js.map

/***/ }),

/***/ 7777:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.getAssetCostToStore = exports.ARWEAVE_UPLOAD_ENDPOINT = exports.LAMPORT_MULTIPLIER = void 0;
const arweave_cost_1 = __webpack_require__(5179);
const web3_js_1 = __webpack_require__(5681);
exports.LAMPORT_MULTIPLIER = web3_js_1.LAMPORTS_PER_SOL;
exports.ARWEAVE_UPLOAD_ENDPOINT = 'https://us-central1-metaplex-studios.cloudfunctions.net/uploadFile';
async function getAssetCostToStore(files) {
    const sizes = files.map(f => f.size);
    const result = await (0, arweave_cost_1.calculate)(sizes);
    return web3_js_1.LAMPORTS_PER_SOL * result.solana;
}
exports.getAssetCostToStore = getAssetCostToStore;
//# sourceMappingURL=assets.js.map

/***/ }),

/***/ 7094:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.extendBorsh = void 0;
const web3_js_1 = __webpack_require__(5681);
const borsh_1 = __webpack_require__(7384);
const bs58_1 = __importDefault(__webpack_require__(2815));
const extendBorsh = () => {
    borsh_1.BinaryReader.prototype.readPubkey = function () {
        const reader = this;
        const array = reader.readFixedArray(32);
        return new web3_js_1.PublicKey(array);
    };
    borsh_1.BinaryWriter.prototype.writePubkey = function (value) {
        const writer = this;
        writer.writeFixedArray(value.toBuffer());
    };
    borsh_1.BinaryReader.prototype.readPubkeyAsString = function () {
        const reader = this;
        const array = reader.readFixedArray(32);
        return bs58_1.default.encode(array);
    };
    borsh_1.BinaryWriter.prototype.writePubkeyAsString = function (value) {
        const writer = this;
        writer.writeFixedArray(bs58_1.default.decode(value));
    };
    // BTreeMap<u32, u32>
    borsh_1.BinaryReader.prototype.readMap32 = function () {
        const reader = this;
        const map = new Map();
        const length = reader.readU32();
        for (let i = 0; i < length; i++) {
            const key = reader.readU32();
            const val = reader.readU32();
            map.set(key, val);
        }
        return map;
    };
    // BTreeMap<u32, u32>
    borsh_1.BinaryWriter.prototype.writeMap32 = function (value) {
        const writer = this;
        value.forEach((val, key) => {
            writer.writeU32(key);
            writer.writeU32(val);
        });
    };
};
exports.extendBorsh = extendBorsh;
(0, exports.extendBorsh)();
//# sourceMappingURL=borsh.js.map

/***/ }),

/***/ 611:
/***/ ((__unused_webpack_module, exports) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.createPipelineExecutor = void 0;
async function createPipelineExecutor(data, executor, { delay = 0, jobsCount = 1, sequence = 1, } = {}) {
    function execute(iter) {
        executor(iter.value);
    }
    async function next() {
        if (sequence <= 1) {
            const iter = data.next();
            if (iter.done) {
                return;
            }
            await execute(iter);
        }
        else {
            const promises = [];
            let isDone = false;
            for (let i = 0; i < sequence; i++) {
                const iter = data.next();
                if (!iter.done) {
                    promises.push(execute(iter));
                }
                else {
                    isDone = true;
                    break;
                }
            }
            await Promise.all(promises);
            if (isDone) {
                return;
            }
        }
        if (delay > 0) {
            await new Promise(resolve => setTimeout(resolve, delay));
        }
        else {
            await Promise.resolve();
        }
        await next();
    }
    const result = new Array(jobsCount);
    for (let i = 0; i < jobsCount; i++) {
        result[i] = next();
    }
    await Promise.all(result);
}
exports.createPipelineExecutor = createPipelineExecutor;
//# sourceMappingURL=createPipelineExecutor.js.map

/***/ }),

/***/ 9757:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.EventEmitter = exports.MarketUpdateEvent = exports.CacheDeleteEvent = exports.CacheUpdateEvent = void 0;
const eventemitter3_1 = __webpack_require__(9553);
class CacheUpdateEvent {
    constructor(id, isNew, parser, isActive) {
        this.id = id;
        this.parser = parser;
        this.isNew = isNew;
        this.isActive = isActive;
    }
}
exports.CacheUpdateEvent = CacheUpdateEvent;
CacheUpdateEvent.type = 'CacheUpdate';
class CacheDeleteEvent {
    constructor(id) {
        this.id = id;
    }
}
exports.CacheDeleteEvent = CacheDeleteEvent;
CacheDeleteEvent.type = 'CacheUpdate';
class MarketUpdateEvent {
    constructor(ids) {
        this.ids = ids;
    }
}
exports.MarketUpdateEvent = MarketUpdateEvent;
MarketUpdateEvent.type = 'MarketUpdate';
class EventEmitter {
    constructor() {
        this.emitter = new eventemitter3_1.EventEmitter();
    }
    onMarket(callback) {
        this.emitter.on(MarketUpdateEvent.type, callback);
        return () => this.emitter.removeListener(MarketUpdateEvent.type, callback);
    }
    onCache(callback) {
        this.emitter.on(CacheUpdateEvent.type, callback);
        return () => this.emitter.removeListener(CacheUpdateEvent.type, callback);
    }
    raiseMarketUpdated(ids) {
        this.emitter.emit(MarketUpdateEvent.type, new MarketUpdateEvent(ids));
    }
    raiseCacheUpdated(id, isNew, parser, isActive) {
        this.emitter.emit(CacheUpdateEvent.type, new CacheUpdateEvent(id, isNew, parser, isActive));
    }
    raiseCacheDeleted(id) {
        this.emitter.emit(CacheDeleteEvent.type, new CacheDeleteEvent(id));
    }
}
exports.EventEmitter = EventEmitter;
//# sourceMappingURL=eventEmitter.js.map

/***/ }),

/***/ 4182:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.getTokenListContainerPromise = void 0;
const spl_token_registry_1 = __webpack_require__(407);
let _cachedTokenListContainerPromise;
function getTokenListContainerPromise() {
    if (_cachedTokenListContainerPromise == null) {
        _cachedTokenListContainerPromise = new spl_token_registry_1.TokenListProvider().resolve();
    }
    return _cachedTokenListContainerPromise;
}
exports.getTokenListContainerPromise = getTokenListContainerPromise;
//# sourceMappingURL=getTokenListContainerPromise.js.map

/***/ }),

/***/ 9556:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SYSTEM = exports.ORACLE_ID = exports.PACK_CREATE_ID = exports.METAPLEX_ID = exports.AUCTION_ID = exports.VAULT_ID = exports.METADATA_PROGRAM_ID = exports.MEMO_ID = exports.BPF_UPGRADE_LOADER_ID = exports.SPL_ASSOCIATED_TOKEN_ACCOUNT_PROGRAM_ID = exports.TOKEN_PROGRAM_ID = exports.WRAPPED_SOL_MINT = exports.pubkeyToString = exports.toPublicKey = exports.LazyAccountInfoProxy = void 0;
const web3_js_1 = __webpack_require__(5681);
class LazyAccountInfoProxy {
    constructor() {
        this.executable = false;
        this.owner = '';
        this.lamports = 0;
    }
    get data() {
        //
        return undefined;
    }
}
exports.LazyAccountInfoProxy = LazyAccountInfoProxy;
const PubKeysInternedMap = new Map();
const toPublicKey = (key) => {
    if (typeof key !== 'string') {
        return key;
    }
    let result = PubKeysInternedMap.get(key);
    if (!result) {
        result = new web3_js_1.PublicKey(key);
        PubKeysInternedMap.set(key, result);
    }
    return result;
};
exports.toPublicKey = toPublicKey;
const pubkeyToString = (key = '') => {
    return typeof key === 'string' ? key : (key === null || key === void 0 ? void 0 : key.toBase58()) || '';
};
exports.pubkeyToString = pubkeyToString;
exports.WRAPPED_SOL_MINT = new web3_js_1.PublicKey('So11111111111111111111111111111111111111112');
exports.TOKEN_PROGRAM_ID = new web3_js_1.PublicKey('TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA');
exports.SPL_ASSOCIATED_TOKEN_ACCOUNT_PROGRAM_ID = new web3_js_1.PublicKey('ATokenGPvbdGVxr1b2hvZbsiqW5xWH25efTNsLJA8knL');
exports.BPF_UPGRADE_LOADER_ID = new web3_js_1.PublicKey('BPFLoaderUpgradeab1e11111111111111111111111');
exports.MEMO_ID = new web3_js_1.PublicKey('MemoSq4gqABAXKb96qnH8TysNcWxMyWCqXgDLGmfcHr');
exports.METADATA_PROGRAM_ID = 'metaqbxxUerdq28cj1RbAWkYQm3ybzjb6a8bt518x1s';
exports.VAULT_ID = 'vau1zxA2LbssAUEF7Gpw91zMM1LvXrvpzJtmZ58rPsn';
exports.AUCTION_ID = 'auctxRXPeJoc4817jDhf4HbjnhEcr1cCXenosMhK5R8';
exports.METAPLEX_ID = 'p1exdMJcjVao65QdewkaZRUnU6VPSXhus9n2GzWfh98';
exports.PACK_CREATE_ID = new web3_js_1.PublicKey('packFeFNZzMfD9aVWL7QbGz1WcU7R9zpf6pvNsw2BLu');
exports.ORACLE_ID = new web3_js_1.PublicKey('rndshKFf48HhGaPbaCd3WQYtgCNKzRgVQ3U2we4Cvf9');
exports.SYSTEM = new web3_js_1.PublicKey('11111111111111111111111111111111');
//# sourceMappingURL=ids.js.map

/***/ }),

/***/ 398:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.shortvec = exports.Layout = void 0;
__exportStar(__webpack_require__(9757), exports);
__exportStar(__webpack_require__(9556), exports);
__exportStar(__webpack_require__(6120), exports);
exports.Layout = __importStar(__webpack_require__(2753));
__exportStar(__webpack_require__(5858), exports);
__exportStar(__webpack_require__(7392), exports);
__exportStar(__webpack_require__(3097), exports);
__exportStar(__webpack_require__(5511), exports);
exports.shortvec = __importStar(__webpack_require__(3798));
__exportStar(__webpack_require__(3923), exports);
__exportStar(__webpack_require__(7094), exports);
__exportStar(__webpack_require__(611), exports);
__exportStar(__webpack_require__(7777), exports);
__exportStar(__webpack_require__(4182), exports);
//# sourceMappingURL=index.js.map

/***/ }),

/***/ 3923:
/***/ ((__unused_webpack_module, exports) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.isValidHttpUrl = void 0;
function isValidHttpUrl(text) {
    if (text.startsWith('http:') || text.startsWith('https:')) {
        return true;
    }
    return false;
}
exports.isValidHttpUrl = isValidHttpUrl;
//# sourceMappingURL=isValidHttpUrl.js.map

/***/ }),

/***/ 2753:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.rustString = exports.uint128 = exports.uint64 = exports.publicKey = void 0;
const web3_js_1 = __webpack_require__(5681);
const bn_js_1 = __importDefault(__webpack_require__(4894));
const BufferLayout = __importStar(__webpack_require__(2949));
/**
 * Layout for a public key
 */
const publicKey = (property = 'publicKey') => {
    const publicKeyLayout = BufferLayout.blob(32, property);
    const _decode = publicKeyLayout.decode.bind(publicKeyLayout);
    const _encode = publicKeyLayout.encode.bind(publicKeyLayout);
    publicKeyLayout.decode = (buffer, offset) => {
        const data = _decode(buffer, offset);
        return new web3_js_1.PublicKey(data);
    };
    publicKeyLayout.encode = (key, buffer, offset) => {
        return _encode(key.toBuffer(), buffer, offset);
    };
    return publicKeyLayout;
};
exports.publicKey = publicKey;
/**
 * Layout for a 64bit unsigned value
 */
const uint64 = (property = 'uint64') => {
    const layout = BufferLayout.blob(8, property);
    const _decode = layout.decode.bind(layout);
    const _encode = layout.encode.bind(layout);
    layout.decode = (buffer, offset) => {
        const data = _decode(buffer, offset);
        return new bn_js_1.default([...data]
            .reverse()
            .map(i => `00${i.toString(16)}`.slice(-2))
            .join(''), 16);
    };
    layout.encode = (num, buffer, offset) => {
        const a = num.toArray().reverse();
        let b = Buffer.from(a);
        if (b.length !== 8) {
            const zeroPad = Buffer.alloc(8);
            b.copy(zeroPad);
            b = zeroPad;
        }
        return _encode(b, buffer, offset);
    };
    return layout;
};
exports.uint64 = uint64;
// TODO: wrap in BN (what about decimals?)
const uint128 = (property = 'uint128') => {
    const layout = BufferLayout.blob(16, property);
    const _decode = layout.decode.bind(layout);
    const _encode = layout.encode.bind(layout);
    layout.decode = (buffer, offset) => {
        const data = _decode(buffer, offset);
        return new bn_js_1.default([...data]
            .reverse()
            .map(i => `00${i.toString(16)}`.slice(-2))
            .join(''), 16);
    };
    layout.encode = (num, buffer, offset) => {
        const a = num.toArray().reverse();
        let b = Buffer.from(a);
        if (b.length !== 16) {
            const zeroPad = Buffer.alloc(16);
            b.copy(zeroPad);
            b = zeroPad;
        }
        return _encode(b, buffer, offset);
    };
    return layout;
};
exports.uint128 = uint128;
/**
 * Layout for a Rust String type
 */
const rustString = (property = 'string') => {
    const rsl = BufferLayout.struct([
        BufferLayout.u32('length'),
        BufferLayout.u32('lengthPadding'),
        BufferLayout.blob(BufferLayout.offset(BufferLayout.u32(), -8), 'chars'),
    ], property);
    const _decode = rsl.decode.bind(rsl);
    const _encode = rsl.encode.bind(rsl);
    rsl.decode = (buffer, offset) => {
        const data = _decode(buffer, offset);
        return data.chars.toString('utf8');
    };
    rsl.encode = (str, buffer, offset) => {
        const data = {
            chars: Buffer.from(str, 'utf8'),
        };
        return _encode(data, buffer, offset);
    };
    return rsl;
};
exports.rustString = rustString;
//# sourceMappingURL=layout.js.map

/***/ }),

/***/ 5858:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.notify = void 0;
const react_1 = __importDefault(__webpack_require__(9297));
const antd_1 = __webpack_require__(953);
// import Link from '../components/Link';
function notify({ message = '', description = undefined, txid = '', type = 'info', placement = 'bottomLeft', }) {
    if (txid) {
        //   <Link
        //     external
        //     to={'https://explorer.solana.com/tx/' + txid}
        //     style={{ color: '#0000ff' }}
        //   >
        //     View transaction {txid.slice(0, 8)}...{txid.slice(txid.length - 8)}
        //   </Link>
        description = react_1.default.createElement(react_1.default.Fragment, null);
    }
    antd_1.notification[type]({
        message: react_1.default.createElement("span", { style: { color: 'black' } }, message),
        description: (react_1.default.createElement("span", { style: { color: 'black', opacity: 0.5 } }, description)),
        placement,
        style: {
            backgroundColor: 'white',
        },
    });
}
exports.notify = notify;
//# sourceMappingURL=notifications.js.map

/***/ }),

/***/ 6120:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.programIds = exports.setProgramIds = exports.getStoreID = void 0;
const __1 = __webpack_require__(9819);
const utils_1 = __webpack_require__(398);
const ids_1 = __webpack_require__(9556);
const getStoreID = async (storeOwnerAddress) => {
    if (!storeOwnerAddress) {
        return undefined;
    }
    console.log('Store owner', storeOwnerAddress, ids_1.METAPLEX_ID);
    const programs = await (0, utils_1.findProgramAddress)([
        Buffer.from('metaplex'),
        (0, ids_1.toPublicKey)(ids_1.METAPLEX_ID).toBuffer(),
        (0, ids_1.toPublicKey)(storeOwnerAddress).toBuffer(),
    ], (0, ids_1.toPublicKey)(ids_1.METAPLEX_ID));
    const storeAddress = programs[0];
    return storeAddress;
};
exports.getStoreID = getStoreID;
const setProgramIds = async (store) => {
    STORE = store ? (0, ids_1.toPublicKey)(store) : undefined;
};
exports.setProgramIds = setProgramIds;
let STORE;
const programIds = () => {
    return {
        token: ids_1.TOKEN_PROGRAM_ID,
        associatedToken: ids_1.SPL_ASSOCIATED_TOKEN_ACCOUNT_PROGRAM_ID,
        bpf_upgrade_loader: ids_1.BPF_UPGRADE_LOADER_ID,
        system: ids_1.SYSTEM,
        metadata: ids_1.METADATA_PROGRAM_ID,
        memo: ids_1.MEMO_ID,
        vault: ids_1.VAULT_ID,
        auction: ids_1.AUCTION_ID,
        metaplex: ids_1.METAPLEX_ID,
        pack_create: ids_1.PACK_CREATE_ID,
        oracle: __1.ORACLE_ID,
        store: STORE,
    };
};
exports.programIds = programIds;
//# sourceMappingURL=programIds.js.map

/***/ }),

/***/ 3798:
/***/ ((__unused_webpack_module, exports) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.encodeLength = exports.decodeLength = void 0;
function decodeLength(bytes) {
    let len = 0;
    let size = 0;
    for (;;) {
        const elem = bytes.shift();
        //@ts-ignore
        len |= (elem & 0x7f) << (size * 7);
        size += 1;
        //@ts-ignore
        if ((elem & 0x80) === 0) {
            break;
        }
    }
    return len;
}
exports.decodeLength = decodeLength;
function encodeLength(bytes, len) {
    let rem_len = len;
    for (;;) {
        let elem = rem_len & 0x7f;
        rem_len >>= 7;
        if (rem_len === 0) {
            bytes.push(elem);
            break;
        }
        else {
            elem |= 0x80;
            bytes.push(elem);
        }
    }
}
exports.encodeLength = encodeLength;
//# sourceMappingURL=shortvec.js.map

/***/ }),

/***/ 5511:
/***/ ((__unused_webpack_module, exports) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.getSearchParams = exports.fromUTF8Array = exports.toUTF8Array = void 0;
// credit https://stackoverflow.com/questions/18729405/how-to-convert-utf8-string-to-byte-array
function toUTF8Array(str) {
    const utf8 = [];
    for (let i = 0; i < str.length; i++) {
        let charcode = str.charCodeAt(i);
        if (charcode < 0x80)
            utf8.push(charcode);
        else if (charcode < 0x800) {
            utf8.push(0xc0 | (charcode >> 6), 0x80 | (charcode & 0x3f));
        }
        else if (charcode < 0xd800 || charcode >= 0xe000) {
            utf8.push(0xe0 | (charcode >> 12), 0x80 | ((charcode >> 6) & 0x3f), 0x80 | (charcode & 0x3f));
        }
        // surrogate pair
        else {
            i++;
            // UTF-16 encodes 0x10000-0x10FFFF by
            // subtracting 0x10000 and splitting the
            // 20 bits of 0x0-0xFFFFF into two halves
            charcode =
                0x10000 + (((charcode & 0x3ff) << 10) | (str.charCodeAt(i) & 0x3ff));
            utf8.push(0xf0 | (charcode >> 18), 0x80 | ((charcode >> 12) & 0x3f), 0x80 | ((charcode >> 6) & 0x3f), 0x80 | (charcode & 0x3f));
        }
    }
    return utf8;
}
exports.toUTF8Array = toUTF8Array;
//courtesy https://gist.github.com/joni/3760795
function fromUTF8Array(data) {
    // array of bytes
    let str = '', i;
    for (i = 0; i < data.length; i++) {
        const value = data[i];
        if (value < 0x80) {
            str += String.fromCharCode(value);
        }
        else if (value > 0xbf && value < 0xe0) {
            str += String.fromCharCode(((value & 0x1f) << 6) | (data[i + 1] & 0x3f));
            i += 1;
        }
        else if (value > 0xdf && value < 0xf0) {
            str += String.fromCharCode(((value & 0x0f) << 12) |
                ((data[i + 1] & 0x3f) << 6) |
                (data[i + 2] & 0x3f));
            i += 2;
        }
        else {
            // surrogate pair
            const charCode = (((value & 0x07) << 18) |
                ((data[i + 1] & 0x3f) << 12) |
                ((data[i + 2] & 0x3f) << 6) |
                (data[i + 3] & 0x3f)) -
                0x010000;
            str += String.fromCharCode((charCode >> 10) | 0xd800, (charCode & 0x03ff) | 0xdc00);
            i += 3;
        }
    }
    return str;
}
exports.fromUTF8Array = fromUTF8Array;
function getSearchParams(search) {
    const searchParams = new URLSearchParams(search);
    const searchData = {};
    for (const key of searchParams.keys()) {
        searchData[key] = searchParams.get(key);
    }
    return searchData;
}
exports.getSearchParams = getSearchParams;
//# sourceMappingURL=strings.js.map

/***/ }),

/***/ 3097:
/***/ ((__unused_webpack_module, exports) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.useLocalStorage = void 0;
const useLocalStorage = () => {
    const isBrowser = (() => typeof window !== 'undefined')();
    const getItem = (key) => {
        return isBrowser ? window.localStorage[key] : '';
    };
    const setItem = (key, value) => {
        if (isBrowser) {
            window.localStorage.setItem(key, value);
            return true;
        }
        return false;
    };
    const removeItem = (key) => {
        window.localStorage.removeItem(key);
    };
    return {
        getItem,
        setItem,
        removeItem,
    };
};
exports.useLocalStorage = useLocalStorage;
//# sourceMappingURL=useLocalStorage.js.map

/***/ }),

/***/ 7392:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.royalty = exports.sleep = exports.convert = exports.formatPct = exports.formatNumber = exports.formatUSD = exports.formatTokenAmount = exports.formatAmount = exports.tryParseKey = exports.fromLamports = exports.wadToLamports = exports.toLamports = exports.chunks = exports.STABLE_COINS = exports.isKnownMint = exports.getTokenIcon = exports.getTokenByName = exports.getVerboseTokenName = exports.getTokenName = exports.shortenAddress = exports.findProgramAddress = exports.useLocalStorageState = exports.formatPriceNumber = void 0;
const react_1 = __webpack_require__(9297);
const web3_js_1 = __webpack_require__(5681);
const bn_js_1 = __importDefault(__webpack_require__(4894));
const constants_1 = __webpack_require__(7093);
const useLocalStorage_1 = __webpack_require__(3097);
exports.formatPriceNumber = new Intl.NumberFormat('en-US', {
    style: 'decimal',
    minimumFractionDigits: 2,
    maximumFractionDigits: 8,
});
function useLocalStorageState(key, defaultState) {
    const localStorage = (0, useLocalStorage_1.useLocalStorage)();
    const [state, setState] = (0, react_1.useState)(() => {
        console.debug('Querying local storage', key);
        const storedState = localStorage.getItem(key);
        console.debug('Retrieved local storage', storedState);
        if (storedState) {
            return JSON.parse(storedState);
        }
        return defaultState;
    });
    const setLocalStorageState = (0, react_1.useCallback)(newState => {
        const changed = state !== newState;
        if (!changed) {
            return;
        }
        setState(newState);
        if (newState === null) {
            localStorage.removeItem(key);
        }
        else {
            try {
                localStorage.setItem(key, JSON.stringify(newState));
            }
            catch {
                // ignore
            }
        }
    }, [state, key]);
    return [state, setLocalStorageState];
}
exports.useLocalStorageState = useLocalStorageState;
const findProgramAddress = async (seeds, programId) => {
    const localStorage = (0, useLocalStorage_1.useLocalStorage)();
    const key = 'pda-' +
        seeds.reduce((agg, item) => agg + item.toString('hex'), '') +
        programId.toString();
    const cached = localStorage.getItem(key);
    if (cached) {
        const value = JSON.parse(cached);
        return [value.key, parseInt(value.nonce)];
    }
    const result = await web3_js_1.PublicKey.findProgramAddress(seeds, programId);
    try {
        localStorage.setItem(key, JSON.stringify({
            key: result[0].toBase58(),
            nonce: result[1],
        }));
    }
    catch {
        // ignore
    }
    return [result[0].toBase58(), result[1]];
};
exports.findProgramAddress = findProgramAddress;
// shorten the checksummed version of the input address to have 4 characters at start and end
function shortenAddress(address, chars = 4) {
    return `${address.slice(0, chars)}...${address.slice(-chars)}`;
}
exports.shortenAddress = shortenAddress;
function getTokenName(map, mint, shorten = true) {
    var _a;
    const mintAddress = typeof mint === 'string' ? mint : mint === null || mint === void 0 ? void 0 : mint.toBase58();
    if (!mintAddress) {
        return 'N/A';
    }
    const knownSymbol = (_a = map.get(mintAddress)) === null || _a === void 0 ? void 0 : _a.symbol;
    if (knownSymbol) {
        return knownSymbol;
    }
    return shorten ? `${mintAddress.substring(0, 5)}...` : mintAddress;
}
exports.getTokenName = getTokenName;
function getVerboseTokenName(map, mint, shorten = true) {
    var _a;
    const mintAddress = typeof mint === 'string' ? mint : mint === null || mint === void 0 ? void 0 : mint.toBase58();
    if (!mintAddress) {
        return 'N/A';
    }
    const knownName = (_a = map.get(mintAddress)) === null || _a === void 0 ? void 0 : _a.name;
    if (knownName) {
        return knownName;
    }
    return shorten ? `${mintAddress.substring(0, 5)}...` : mintAddress;
}
exports.getVerboseTokenName = getVerboseTokenName;
function getTokenByName(tokenMap, name) {
    let token = null;
    for (const val of tokenMap.values()) {
        if (val.symbol === name) {
            token = val;
            break;
        }
    }
    return token;
}
exports.getTokenByName = getTokenByName;
function getTokenIcon(map, mintAddress) {
    var _a;
    const address = typeof mintAddress === 'string' ? mintAddress : mintAddress === null || mintAddress === void 0 ? void 0 : mintAddress.toBase58();
    if (!address) {
        return;
    }
    return (_a = map.get(address)) === null || _a === void 0 ? void 0 : _a.logoURI;
}
exports.getTokenIcon = getTokenIcon;
function isKnownMint(map, mintAddress) {
    return !!map.get(mintAddress);
}
exports.isKnownMint = isKnownMint;
exports.STABLE_COINS = new Set(['USDC', 'wUSDC', 'USDT']);
function chunks(array, size) {
    return Array.apply(0, new Array(Math.ceil(array.length / size))).map((_, index) => array.slice(index * size, (index + 1) * size));
}
exports.chunks = chunks;
function toLamports(account, mint) {
    var _a;
    if (!account) {
        return 0;
    }
    const amount = typeof account === 'number' ? account : (_a = account.info.amount) === null || _a === void 0 ? void 0 : _a.toNumber();
    const precision = Math.pow(10, (mint === null || mint === void 0 ? void 0 : mint.decimals) || 0);
    return Math.floor(amount * precision);
}
exports.toLamports = toLamports;
function wadToLamports(amount) {
    return (amount === null || amount === void 0 ? void 0 : amount.div(constants_1.WAD)) || constants_1.ZERO;
}
exports.wadToLamports = wadToLamports;
function fromLamports(account, mint, rate = 1.0) {
    if (!account) {
        return 0;
    }
    const amount = Math.floor(typeof account === 'number'
        ? account
        : bn_js_1.default.isBN(account)
            ? account.toNumber()
            : account.info.amount.toNumber());
    const precision = Math.pow(10, (mint === null || mint === void 0 ? void 0 : mint.decimals) || 9);
    return (amount / precision) * rate;
}
exports.fromLamports = fromLamports;
const tryParseKey = (key) => {
    try {
        return new web3_js_1.PublicKey(key);
    }
    catch (error) {
        return null;
    }
};
exports.tryParseKey = tryParseKey;
const SI_SYMBOL = ['', 'k', 'M', 'G', 'T', 'P', 'E'];
const abbreviateNumber = (number, precision) => {
    const tier = (Math.log10(number) / 3) | 0;
    let scaled = number;
    const suffix = SI_SYMBOL[tier];
    if (tier !== 0) {
        const scale = Math.pow(10, tier * 3);
        scaled = number / scale;
    }
    // Added this to remove unneeded decimals when abbreviating number
    precision = Number.isInteger(scaled) ? 0 : precision;
    //console.log("Number", scaled, precision)
    return scaled.toFixed(precision) + suffix;
};
const formatAmount = (val, precision = 2, abbr = true) => (abbr ? abbreviateNumber(val, precision) : val.toFixed(precision));
exports.formatAmount = formatAmount;
function formatTokenAmount(account, mint, rate = 1.0, prefix = '', suffix = '', precision = 3, abbr = false) {
    if (!account) {
        return '';
    }
    return `${[prefix]}${(0, exports.formatAmount)(fromLamports(account, mint, rate), precision, abbr)}${suffix}`;
}
exports.formatTokenAmount = formatTokenAmount;
exports.formatUSD = new Intl.NumberFormat('en-US', {
    style: 'currency',
    currency: 'USD',
});
const numberFormater = new Intl.NumberFormat('en-US', {
    style: 'decimal',
    minimumFractionDigits: 2,
    maximumFractionDigits: 2,
});
exports.formatNumber = {
    format: (val) => {
        if (!val) {
            return '--';
        }
        return numberFormater.format(val);
    },
};
exports.formatPct = new Intl.NumberFormat('en-US', {
    style: 'percent',
    minimumFractionDigits: 2,
    maximumFractionDigits: 2,
});
function convert(account, mint, rate = 1.0) {
    var _a;
    if (!account) {
        return 0;
    }
    const amount = typeof account === 'number' ? account : (_a = account.info.amount) === null || _a === void 0 ? void 0 : _a.toNumber();
    const precision = Math.pow(10, (mint === null || mint === void 0 ? void 0 : mint.decimals) || 0);
    const result = (amount / precision) * rate;
    return result;
}
exports.convert = convert;
function sleep(ms) {
    return new Promise(resolve => setTimeout(resolve, ms));
}
exports.sleep = sleep;
function royalty(value) {
    return `${((value || 0) / 100).toFixed(2)}%`;
}
exports.royalty = royalty;
//# sourceMappingURL=utils.js.map

/***/ }),

/***/ 760:
/***/ ((module) => {

module.exports = JSON.parse('{"EDshWM3jBy2YUszMiFLAFLx3WkbtqR9An7JZzvg22R1P":{"name":"Deployer Admin","image":"https://pbs.twimg.com/profile_images/1393399819213983746/2a8l5muc_400x400.png","description":"","background":""},"CduMjFZLBeg3A9wMP3hQCoU1RQzzCpgSvQNXfCi1GCSB":{"name":"Bartosz Lipinski","image":"https://pbs.twimg.com/profile_images/1393353972371623938/ZMWvvptg_400x400.jpg","description":"","background":""},"44kiGWWsSgdqPMvmqYgTS78Mx2BKCWzduATkfY4biU97":{"name":"Jordan Prince","image":"https://pbs.twimg.com/profile_images/1393399819213983746/2a8l5muc_400x400.png","description":"","background":""},"3yp9iTsCgZoBsXhtRLB8cWHNcTDeR6VJniRuDrHNTuxU":{"name":"James Madison","image":"https://pbs.twimg.com/profile_images/1393353972371623938/ZMWvvptg_400x400.jpg","description":"","background":""},"SoL351y4uKWtbH14AU1Rhiao96aBM4u57bMi5Vj2XJc":{"name":"Solana","image":"https://pbs.twimg.com/profile_images/1299400345144049665/sPxnVXa7_400x400.jpg","description":"Account used by Solana to mint official NFTs","background":""}}');

/***/ })

};
;